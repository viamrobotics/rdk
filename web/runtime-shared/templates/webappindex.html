<html>
  <head>
    <style type="text/css" media="screen">
      #source {
        position: relative;
        width: 50%;
        height: 50%;
      }
      #map {
        height: 400px;
        width: 100%;
      }
      [v-cloak] {
        display: none;
      }
      #pre-app.connected {
        display: none;
      }
      #connecting {
        display: none;
      }
      #connecting.connecting {
        display: block;
      }
      #connecting-error {
        color: red;
      }
      h3 {
        margin: 0.1em;
        margin-block-end: 0.1em;
      }
    </style>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=" />
    <script>
      window.webrtcEnabled = {{ .WebRTCEnabled }}
      window.webrtcHost = {{ .WebRTCHost }}
      window.webrtcSignalingAddress = {{ .WebRTCSignalingAddress }}
      window.webrtcAdditionalICEServers = {{ .WebRTCAdditionalICEServers }}
      window.bakedAuth = {{ .BakedAuth }} || {};
      window.supportedAuthTypes = {{ .SupportedAuthTypes }} || [];
    </script>
    {{ if .External }}
    <script src="/static/rdk/control.js"></script>
    <script src="/static/rdk/control_helpers.js"></script>
    <script src="/static/rdk/third-party/vue.js"></script>
    <link rel="stylesheet" href="/static/rdk/dls/dls.css" />
    <script type="module">
      import "/static/rdk/dls/dls.umd.min.js";
    </script>
    {{ else }}
    <script src="/static/control.js"></script>
    <script src="/static/control_helpers.js"></script>
    <script src="/static/third-party/vue.js"></script>
    <link rel="stylesheet" href="/static/dls/dls.css" />
    <script type="module">
      import "/static/dls/dls.umd.min.js";
    </script>
    {{ end }}
    <script>
      function roundTo2Decimals(num) {
        num = Math.round(num * 100);
        return num / 100;
      }

      function setError(err) {
        theData.error = err;
      }

      function grpcCallback(err, resp, stringify) {
        if (err) {
          setError(err);
          return;
        }
        if (stringify === undefined || stringify) {
          try {
            if (resp.toJavaScript) {
              theData.res = JSON.stringify(resp.toJavaScript());
            } else {
              theData.res = JSON.stringify(resp.toObject());
            }
          } catch (e) {
            setError(err);
          }
        }
      }

      function fixArmStatus(old) {
        var newStatus = { pos_pieces : [], joint_pieces : [] };
        var fieldSetters = [
          ["x", "X"],
          ["y", "Y"],
          ["z", "Z"],
          ["theta", "Theta"],
          ["o_x", "OX"],
          ["o_y", "OY"],
          ["o_z", "OZ"],
        ];
        for (var j=0; j<fieldSetters.length; j++ ){
            let endPositionField = fieldSetters[j][0];
            newStatus.pos_pieces.push(
              { 
                endPosition : fieldSetters[j],
                endPositionValue : old["end_position"][endPositionField] || 0,
              }
            );
        }
        for (var j=0; j<old["joint_positions"]["degrees"].length; j++ ){
            let endPositionField = fieldSetters[j][0];
            newStatus.joint_pieces.push(
              { 
                joint : j,
                jointValue : old["joint_positions"]["degrees"][j] || 0,
              }
            );
        }
        return newStatus;
      }

      function fixBoardStatus(old) {
        var newStatus = {
          analogsMap: old["analogs"] || [],
          digitalInterruptsMap: old["digital_interrupts"] || [],
        };
        return newStatus;
      }

      function fixGantryStatus(old) {
        var newStatus = { parts: [] };
        if (old["lengths_mm"].length != old["positions_mm"].length) {
          throw "gantry lists different lengths";
        }

        for (var i = 0; i < old["lengths_mm"].length; i++) {
          newStatus.parts.push({ axis: i, pos: old["positions_mm"][i], length: old["lengths_mm"][i] });
        }
        return newStatus;
      }

      function fixInputStatus(old) {
        let events = old["events"] || [];
        let eventsList = events.map((e) => {
          return {
            time: e["time"] || {},
            event: e["event"] || "",
            control: e["control"] || "",
            value: e["value"] || 0.0,
          };
        });
        return { eventsList: eventsList };
      }

      function fixMotorStatus(old) {
        return {
          isOn: old["is_on"] || false,
          positionReporting: old["position_reporting"] || false,
          position: old["position"] || 0,
        };
      }

      function fixServoStatus(old) {
        return { positionDeg: old["position_deg"] || 0 };
      }

      function fixRawStatus(name, status) {
        switch (theApp.resourceNameToSubtypeString(name)) {
          // TODO (RDK-127): generate these using constants
          case "rdk:component:arm":
            status = fixArmStatus(status);
            break;
          case "rdk:component:board":
            status = fixBoardStatus(status);
            break;
          case "rdk:component:gantry":
            status = fixGantryStatus(status);
            break;
          case "rdk:component:input_controller":
            status = fixInputStatus(status);
            break;
          case "rdk:component:motor":
            status = fixMotorStatus(status);
            break;
          case "rdk:component:servo":
            status = fixServoStatus(status);
            break;
        }
        return status;
      }

      firstResult = true;
      async function updateStatus(grpcStatus) {
        var rawStatus = {};
        var status = {};

        grpcStatus.forEach((s) => {
          let nameObj = s.getName().toObject();
          let statusJs = s.getStatus().toJavaScript();
          let fixed = fixRawStatus(nameObj, statusJs);

          let nameStr = theApp.resourceNameToString(nameObj);
          rawStatus[nameStr] = statusJs;
          status[nameStr] = fixed;
        });

        theData.rawStatus = rawStatus;
        theData.status = status;
      }

      async function startup() {
        theData = {
          error: "",
          res: {},
          rawStatus: {},
          status: {},
          pcdClick: {},
          sensorReadings: {},
          resources: [],
          sensorNames: [],
          streamNames: [],
          intervalId: null,
          segmenterNames: [],
          segmenterParameterNames: [],
          segmenterParameters: {},
          segmentAlgo: "",
          fullcloud: null,
          objects: null,
          minPtsPlane: 10000,
          minPtsSegment: 100,
          clusterRad: 5,
          armToggle: {},
          mapOnce: false,
          value: 0,
          imuData: {},
          currentOps: [],
          baseRunStatus: false
        };
        theApp = new Vue({
          el: "#app",
          delimiters: ["${", "}"],
          data: theData,
          components: {},
          methods: {
            parameterType: function (typeName) {
              if (typeName == "int" || typeName == "float64") {
                return "number";
              } else if (typeName == "string" || typeName == "char") {
                return "text";
              }
              return "";
            },
            getSegmenterNames: function () {
              let req = new visionApi.GetSegmenterNamesRequest();
              visionService.getSegmenterNames(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  console.log("error getting segmenter names");
                  console.log(err);
                  return;
                }
                theData.segmenterNames = resp.getSegmenterNamesList();
              });
            },
            getSegmenterParameters: function (name) {
              this.segmentAlgo = name;
              let req = new visionApi.GetSegmenterParametersRequest();
              req.setSegmenterName(name);
              visionService.getSegmenterParameters(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  console.log("error getting segmenter parameters for " + name);
                  console.log(err);
                  return;
                }
                theData.segmenterParameterNames = resp.getSegmenterParametersList();
                theData.segmenterParameters = {};
              });
            },
            filterResources: function (namespace, type, subtype) {
              return theData.resources.filter((elem) => {
                return elem.namespace == namespace && elem.type == type && elem.subtype == subtype;
              }).sort((a, b) => {
                if (a.name < b.name) {
                  return -1;
                }
                if (a.name > b.name) {
                  return 1;
                }
                return 0;
              });
            },
            resourceNameToSubtypeString: function (name) {
              return `${name.namespace}:${name.type}:${name.subtype}`;
            },
            resourceNameToString: function (name) {
              strName = theApp.resourceNameToSubtypeString(name);
              if (name.name !== "") {
                strName += `/${name.name}`;
              }
              return strName;
            },
            stringToResourceName: function (nameStr) {
              let nameParts = nameStr.split("/");
              let name = "";
              if (nameParts.length === 2) {
                name = nameParts[1];
              } else if (nameParts.length === 2) {
                throw "more than one backslash in resource name string";
              }
              let subtypeParts = nameParts[0].split(":");
              if (subtypeParts.length > 3) {
                throw "more than 2 colons in resource name string";
              }
              if (subtypeParts.length < 3) {
                throw "less than 2 colons in resource name string";
              }
              return { namespace: subtypeParts[0], type: subtypeParts[1], subtype: subtypeParts[2], name: name };
            },
            resourceStatusByName: function (name) {
              return theData.status[theApp.resourceNameToString(name)];
            },
            rawResourceStatusByName: function (name) {
              return theData.rawStatus[theApp.resourceNameToString(name)];
            },
            gantryInc: function (name, axis, amount) {
              var g = theApp.resourceStatusByName(name);
              var pos = [];
              for (var i = 0; i < g.parts.length; i++) {
                pos[i] = g.parts[i].pos;
              }
              pos[axis] += amount;

              const req = new gantryApi.MoveToPositionRequest();
              req.setName(name.name);
              req.setPositionsMmList(pos);
              gantryService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            armEndPositionInc: function (name, getterSetter, amount) {
              if (getterSetter[0] == "o" || getterSetter[0] == "O") {
                amount /= 100;
              }
              const arm = theApp.rawResourceStatusByName(name);
              let old = arm["end_position"];
              var newPose = new commonApi.Pose();
              var fieldSetters = [
                ["x", "X"],
                ["y", "Y"],
                ["z", "Z"],
                ["theta", "Theta"],
                ["o_x", "OX"],
                ["o_y", "OY"],
                ["o_z", "OZ"],
              ];
              for (var j = 0; j < fieldSetters.length; j++) {
                let endPositionField = fieldSetters[j][0];
                let endPositionValue = old[endPositionField] || 0;
                const setter = `set${fieldSetters[j][1]}`;
                newPose[setter](endPositionValue);
              }

              const getter = `get${getterSetter}`;
              const setter = `set${getterSetter}`;
              newPose[setter](newPose[getter]() + amount);
              const req = new armApi.MoveToPositionRequest();
              req.setName(name.name);
              req.setTo(newPose);
              armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            armJointInc: function (name, field, amount) {
              const arm = theApp.rawResourceStatusByName(name);
              let old = arm["joint_positions"];
              var newPositionDegs = new armApi.JointPositions();
              var newList = arm["joint_positions"]["degrees"];
              newList[field] += amount;
              newPositionDegs.setDegreesList(newList);
              const req = new armApi.MoveToJointPositionsRequest();
              req.setName(name.name);
              req.setPositionDegs(newPositionDegs);
              armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            armHome: function (name) {
              const arm = theApp.rawResourceStatusByName(name);
              let old = arm["joint_positions"];
              var newPositionDegs = new armApi.JointPositions();
              var newList = arm["joint_positions"]["degrees"];
              for (var i = 0; i < newList.length; i++) {
                newList[i] = 0;
              }
              newPositionDegs.setDegreesList(newList);
              const req = new armApi.MoveToJointPositionsRequest();
              req.setName(name.name);
              req.setPositionDegs(newPositionDegs);
              armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            armModifyAll: function (name) {
              const arm = theApp.resourceStatusByName(name);
              var n = { pos_pieces: [], joint_pieces: [] };
              for (var i = 0; i < arm.pos_pieces.length; i++) {
                n.pos_pieces.push({
                  endPosition: arm.pos_pieces[i].endPosition,
                  endPositionValue: roundTo2Decimals(arm.pos_pieces[i].endPositionValue),

                });
              }
              for (var i = 0; i < arm.joint_pieces.length; i++) {
                n.joint_pieces.push({
                  joint: arm.joint_pieces[i].joint,
                  jointValue: roundTo2Decimals(arm.joint_pieces[i].jointValue),
                });
              }
              theData.armToggle[name.name] = n;
            },
            armModifyAllCancel: function (name) {
              delete theData.armToggle[name.name];
            },
            armModifyAllDoEndPosition: function (name) {
              var newPose = new commonApi.Pose();
              var newPieces = theData.armToggle[name.name].pos_pieces;

              for (var i = 0; i < newPieces.length; i++) {
                var getterSetter = newPieces[i].endPosition[1];
                const setter = `set${getterSetter}`;
                newPose[setter](newPieces[i].endPositionValue);
              }

              const req = new armApi.MoveToPositionRequest();
              req.setName(name.name);
              req.setTo(newPose);
              armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
              delete theData.armToggle[name.name];
            },
            armModifyAllDoJoint: function (name) {
              const arm = theApp.rawResourceStatusByName(name);
              var newPositionDegs = new armApi.JointPositions();
              var newList = arm["joint_positions"]["degrees"];
              var newPieces = theData.armToggle[name.name].joint_pieces;
              for (var i = 0; i < newPieces.length && i < newList.length; i++) {
                newList[newPieces[i].joint] = newPieces[i].jointValue;
              }

              newPositionDegs.setDegreesList(newList);
              const req = new armApi.MoveToJointPositionsRequest();
              req.setName(name.name);
              req.setPositionDegs(newPositionDegs);
              armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
              delete theData.armToggle[name.name];
            },

            gripperAction: function (name, action) {
              let req;
              switch (action) {
                case "open":
                  req = new gripperApi.OpenRequest();
                  req.setName(name);
                  gripperService.open(req, {}, (err, resp) => grpcCallback(err, resp));
                  break;
                case "grab":
                  req = new gripperApi.GrabRequest();
                  req.setName(name);
                  gripperService.grab(req, {}, (err, resp) => grpcCallback(err, resp));
                  break;
              }
            },
            servoMove: function (name, amount) {
              const servo = theApp.rawResourceStatusByName(name);
              var oldAngle = servo["position_deg"] || 0;
              let angle = oldAngle + amount;
              const req = new servoApi.MoveRequest();
              req.setName(name.name);
              req.setAngleDeg(angle);
              servoService.move(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            motorCommand: function (motor, cmd) {
              let req = cmd.request;
              req.setName(motor);

              switch (cmd.type) {
                case "go":
                  motorService.setPower(req, {}, (err, resp) => grpcCallback(err, resp));
                  break;
                case "goFor":
                  motorService.goFor(req, {}, (err, resp) => grpcCallback(err, resp));
                  break;
                case "goTo":
                  motorService.goTo(req, {}, (err, resp) => grpcCallback(err, resp));
                  break;
              }
            },
            hasWebGamepad: function () {
              // TODO (RDK-127): replace these with constants
              return theData.resources.some((elem) => elem.namespace == "rdk" && elem.type == "component" && elem.subtype == "input_controller" && elem.name == "WebGamepad");
            },
            filteredInputControllerList: function () {
              // TODO (RDK-127): replace these with constants
              // filters out WebGamepad
              return theData.resources.filter((elem) => {
                return elem.namespace == "rdk" && elem.type == "component" && elem.subtype == "input_controller" && elem.name !== "WebGamepad";
              });
            },
            inputInject: function (req) {
              inputControllerService.triggerEvent(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            killOp: function (id) {
              var req = new robotApi.KillOperationRequest();
              req.setId(id);
              robotService.killOperation(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            baseKeyboardCtl: function(keys) {
              const {baseName, ...controls} = keys;
              console.log('Keyboard state: %o', controls);

              if (Object.values(controls).every((item) => item === false)) {
                console.log("All keyboard inputs false, stopping base.");
                this.handleBaseActionStop(baseName);
                return;
              } 

              const arcInputs = window.computeKeyboardBaseControls(controls);
              console.log("Arc inputs: %o", arcInputs);
              BaseControlHelper.moveArc(baseName,
                    arcInputs.distance,
                    arcInputs.speed,
                    arcInputs.angle,
                    (err, resp) => {
                      return grpcCallback(err, resp)
                    });
            },
            handleBaseActionStop : function(name) {
              console.log('baseActionHandlerStop');
              let req = new baseApi.StopRequest();
              req.setName(name);
              baseService.stop(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            handleBaseAction : function(movementMode, movementType, spinType, direction) {
              this.baseRunStatus = true;
              console.log('baseActionHandler');
              console.log(movementMode);
              console.log(movementType);
              console.log(spinType);
              console.log(direction);
              let name = this.filterResources('rdk', 'component', 'base')[0].name;
              let req;
              if (
                  movementMode === "Straight" &&
                  movementType === "Continous" &&
                  direction === "Forwards"
              ) {
                  BaseControlHelper.moveStraight(name, 
                    document.getElementById("distance").value * 1, 
                    document.getElementById("speed").value, 
                    (err, resp) => {
                      return grpcCallback(err, resp)
                    });
              } else if (
                  movementMode === "Straight" &&
                  movementType === "Discrete" &&
                  direction === "Forwards"
              ) {
                  BaseControlHelper.moveStraight(name, 
                    document.getElementById("distance").value * 1, 
                    document.getElementById("speed").value, 
                    (err, resp) => {
                      return grpcCallback(err, resp)
                    });
              } else if (
                  movementMode === "Straight" &&
                  movementType === "Continous" &&
                  direction === "Backwards"
              ) {
                  BaseControlHelper.moveStraight(name, 
                    document.getElementById("distance").value * -1, 
                    document.getElementById("speed").value, 
                    (err, resp) => {
                      return grpcCallback(err, resp)
                    });
              } else if (
                  movementMode === "Straight" &&
                  movementType === "Discrete" &&
                  direction === "Backwards"
              ) {
                  BaseControlHelper.moveStraight(name, 
                    document.getElementById("distance").value * -1, 
                    document.getElementById("speed").value, 
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              } else if (
                  movementMode === "Arc" &&
                  spinType === "Clockwise" &&
                  direction === "Forwards"
              ) {
                  BaseControlHelper.moveArc(name,
                    document.getElementById("distance").value * 1,
                    document.getElementById("speed").value,
                    document.getElementById("angle").value,
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              } else if (
                  movementMode === "Arc" &&
                  spinType === "Counterclockwise" &&
                  direction === "Forwards"
              ) {
                  BaseControlHelper.moveArc(name,
                    document.getElementById("distance").value * 1,
                    document.getElementById("speed").value,
                    document.getElementById("angle").value,
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              } else if (
                  movementMode === "Arc" &&
                  spinType === "Clockwise" &&
                  direction === "Backwards"
              ) {
                  BaseControlHelper.moveArc(name,
                    document.getElementById("distance").value * -1,
                    document.getElementById("speed").value,
                    document.getElementById("angle").value,
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              } else if (
                  movementMode === "Arc" &&
                  spinType === "Counterclockwise" &&
                  direction === "Backwards"
              ) {
                  BaseControlHelper.moveArc(name,
                    document.getElementById("distance").value * -1,
                    document.getElementById("speed").value,
                    document.getElementById("angle").value,
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              } else if (
                  movementMode === "Spin" &&
                  spinType === "Clockwise"
              ) {
                  BaseControlHelper.spin(name, 
                    document.getElementById("angle").value * 1, 
                    document.getElementById("speed").value, 
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              } else if (
                  movementMode === "Spin" &&
                  spinType === "Counterclockwise"
              ) {
                  BaseControlHelper.spin(name, 
                    document.getElementById("angle").value * -1, 
                    document.getElementById("speed").value, 
                    (err, resp) => {
                      return grpcCallback(err, resp)
                  });
              }
            },
            renderFrame: function (cameraName) {
              req = new cameraApi.RenderFrameRequest();
              req.setName(cameraName);
              const mimeType = "image/jpeg";
              req.setMimeType(mimeType);
              cameraService.renderFrame(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  return;
                }
                let blob = new Blob([resp.getData_asU8()], { type: mimeType });
                window.open(URL.createObjectURL(blob), "_blank");
              });
            },
            viewCameraFrame: function (time) {
                clearInterval(this.intervalId);
                let cameraName = this.streamNames[0];
                if (time === 'manual' ) {
                    this.viewManualFrame(cameraName);
                } else if (time === 'live') {
                    this.viewCamera(cameraName)
                } else {
                    this.viewIntervalFrame(cameraName, time);
                }
            },
            viewManualFrame: function (cameraName) {
              req = new cameraApi.RenderFrameRequest();
              req.setName(cameraName);
              const mimeType = "image/jpeg";
              req.setMimeType(mimeType);
              cameraService.renderFrame(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  return;
                }
                const streamContainer = document.getElementById(`stream-${cameraName}`);
                if (streamContainer && streamContainer.getElementsByTagName("video").length > 0) {
                    streamContainer.getElementsByTagName("video")[0].remove();
                }
                if (streamContainer && streamContainer.getElementsByTagName("img").length > 0) {
                    streamContainer.getElementsByTagName("img")[0].remove();
                }
                const image = new Image();
                let blob = new Blob([resp.getData_asU8()], { type: mimeType });
                image.src = URL.createObjectURL(blob);
                streamContainer.appendChild(image);
              });
            },
            viewIntervalFrame: function (cameraName, time) {
                this.intervalId = setInterval(() => {
                  req = new cameraApi.RenderFrameRequest();
                  req.setName(cameraName);
                  const mimeType = "image/jpeg";
                  req.setMimeType(mimeType);
                  cameraService.renderFrame(req, {}, (err, resp) => {
                    grpcCallback(err, resp, false);
                    if (err) {
                      return;
                    }
                    const streamContainer = document.getElementById(`stream-${cameraName}`);
                    if (streamContainer && streamContainer.getElementsByTagName("video").length > 0) {
                        streamContainer.getElementsByTagName("video")[0].remove();
                    }
                    if (streamContainer && streamContainer.getElementsByTagName("img").length > 0) {
                        streamContainer.getElementsByTagName("img")[0].remove();
                    }
                    const image = new Image();
                    let blob = new Blob([resp.getData_asU8()], { type: mimeType });
                    image.src = URL.createObjectURL(blob);
                    streamContainer.appendChild(image);
                  });
                }, +time * 1000);
            },
            renderPCD: function (cameraName) {
              this.$nextTick(function () {
                  theData.pcdClick.pcdloaded = false;
                  theData.pcdClick.foundSegments = false;
                  initPCDIfNeeded();
                  pcdGlobal.cameraName = cameraName;

                  req = new cameraApi.GetPointCloudRequest();
                  req.setName(cameraName);
                  const mimeType = "pointcloud/pcd";
                  req.setMimeType(mimeType);
                  cameraService.getPointCloud(req, {}, (err, resp) => {
                    grpcCallback(err, resp, false);
                    if (err) {
                      return;
                    }
                    console.log("loading pcd");
                    theData.fullcloud = resp.getPointCloud_asB64();
                    pcdLoad(`data:${mimeType};base64,${theData.fullcloud}`);
                  });
              });
            },
            getReadings: function (sensorNames) {
              var req = new sensorsApi.GetReadingsRequest();
              let names = sensorNames.map((name) => {
                let resourceName = new commonApi.ResourceName();
                resourceName.setNamespace(name.namespace);
                resourceName.setType(name.type);
                resourceName.setSubtype(name.subtype);
                resourceName.setName(name.name);
                return resourceName;
              });
              req.setSensorNamesList(names);
              sensorsService.getReadings(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  return;
                }
                resp.getReadingsList().forEach((r) => {
                  let readings = r.getReadingsList().map((v) => v.toJavaScript());
                  theData.sensorReadings[theApp.resourceNameToString(r.getName().toObject())] = readings;
                });
              });
            },
            processFunctionResults: function (err, resp) {
              grpcCallback(err, resp, false);
              if (err) {
                document.getElementById("function_results").value = `${err}`;
                return;
              }
              var results = resp.getResultsList();

              let resultStr = "";
              if (results.length > 0) {
                resultStr += "Results: \n";
                for (let i = 0; i < results.length && i < results.length; i++) {
                  let result = results[i];
                  resultStr += `${i}: ${JSON.stringify(result.toJavaScript())}\n`;
                }
              }
              resultStr += `StdOut: ${resp.getStdOut()}\n`;
              resultStr += `StdErr: ${resp.getStdErr()}\n`;
              document.getElementById("function_results").value = resultStr;
            },
            nonEmpty: function (d) {
              for (var k in d) {
                return true;
              }
              return false;
            },
            hasKey: function (d, key) {
              if (!d) {
                return false;
              }
              if (Array.isArray(d)) {
                for (let i = 0; i < d.length; i++) {
                  if (d[i] == key || (d[i].length && d[i].length >= 1 && d[i][0] == key)) {
                    return true;
                  }
                }
                return false;
              }
              return d.hasOwn(key);
            },
            grabClick: function (e) {
              var mouse = new THREE.Vector2();
              mouse.x = (e.offsetX / e.srcElement.offsetWidth) * 2 - 1;
              mouse.y = (e.offsetY / e.srcElement.offsetHeight) * -2 + 1;

              pcdGlobal.raycaster.setFromCamera(mouse, pcdGlobal.camera);

              var intersects = pcdGlobal.raycaster.intersectObjects(pcdGlobal.scene.children);
              var p = intersects.length > 0 ? intersects[0] : null;

              if (p !== null) {
                console.log(p.point);
                setPoint(p.point);
              } else {
                console.log("no point intersected");
              }
            },
            doPCDMove: function () {
              let gripperName = theApp.filterResources("rdk", "component", "gripper")[0];
              let cameraName = pcdGlobal.cameraName;
              let cameraPointX = theData.pcdClick.x;
              let cameraPointY = theData.pcdClick.y;
              let cameraPointZ = theData.pcdClick.z;

              let req = new motionApi.MoveRequest();
              let cameraPoint = new commonApi.Pose();
              cameraPoint.setX(cameraPointX);
              cameraPoint.setY(cameraPointY);
              cameraPoint.setZ(cameraPointZ);

              var pose = new commonApi.PoseInFrame();
              pose.setReferenceFrame(cameraName);
              pose.setPose(cameraPoint);
              req.setDestination(pose);
              let componentName = new commonApi.ResourceName();
              componentName.setNamespace(gripperName.namespace);
              componentName.setType(gripperName.type);
              componentName.setSubtype(gripperName.subtype);
              componentName.setName(gripperName.name);
              req.setComponentName(componentName);
              console.log("making move attempt using " + gripperName);

              motionService.move(req, {}, (err, resp) => {
                grpcCallback(err, resp);
                if (err) {
                  return Promise.reject(err);
                }
                return Promise.resolve(resp).then(console.log("move success: " + resp.getSuccess()));
              });
            },
            findSegments: function (segmenterName, segmenterParams) {
              console.log("parameters for segmenter below:");
              console.log(segmenterParams);
              theData.pcdClick.calculatingSegments = true;
              theData.pcdClick.foundSegments = false;
              let req = new visionApi.GetObjectPointCloudsRequest();
              req.setCameraName(pcdGlobal.cameraName);
              req.setSegmenterName(segmenterName);
              req.setParameters(proto.google.protobuf.Struct.fromJavaScript(segmenterParams));
              const mimeType = "pointcloud/pcd";
              req.setMimeType(mimeType);
              console.log("finding object segments...");
              visionService.getObjectPointClouds(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  console.log("error getting segments");
                  console.log(err);
                  theData.pcdClick.calculatingSegments = false;
                  return;
                }
                console.log("got pcd segments");
                theData.pcdClick.foundSegments = true;
                theData.objects = resp.getObjectsList();
                theData.pcdClick.calculatingSegments = false;
              });
            },
            doSegmentLoad: function (i) {
              var segment = theData.objects[i];
              var data = segment.getPointCloud_asB64();
              var center = segment.getGeometries().getGeometriesList()[0].getCenter();
              var box = segment.getGeometries().getGeometriesList()[0].getBox();
              var p = { x: center.getX() / 1000, y: center.getY() / 1000, z: center.getZ() / 1000 };
              console.log(p);
              setPoint(p);
              setBoundingBox(box, p);
              const mimeType = "pointcloud/pcd";
              pcdLoad(`data:${mimeType};base64,${data}`);
            },
            doPointLoad: function (i) {
              var segment = theData.objects[i];
              var center = segment.getGeometries().getGeometriesList()[0].getCenter();
              var p = { x: center.getX() / 1000, y: center.getY() / 1000, z: center.getZ() / 1000 };
              console.log(p);
              setPoint(p);
            },
            doBoundingBoxLoad: function (i) {
              var segment = theData.objects[i];
              var center = segment.getGeometries().getGeometriesList()[0].getCenter();
              var box = segment.getGeometries().getGeometriesList()[0].getBox();
              var centerP = { x: center.getX() / 1000, y: center.getY() / 1000, z: center.getZ() / 1000 };
              setBoundingBox(box, centerP);
            },
            doPCDLoad: function (data) {
              const mimeType = "pointcloud/pcd";
              pcdLoad(`data:${mimeType};base64,${data}`);
            },
            doSelectObject: function (selection) {
                console.log(selection);
            },
            setNavigationMode: function (mode) {
              let pbMode = navigationApi.Mode.MODE_UNSPECIFIED;
              switch (mode) {
                case "manual":
                  pbMode = navigationApi.Mode.MODE_MANUAL;
                  break;
                case "waypoint":
                  pbMode = navigationApi.Mode.MODE_WAYPOINT;
                  break;
              }
              var req = new navigationApi.SetModeRequest();
              req.setMode(pbMode);
              navigationService.setMode(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            setNavigationLocation: function (elId) {
              const posSplit = document.getElementById(elId).value.split(",");
              if (posSplit.length != 2) {
                return;
              }
              const lat = parseFloat(posSplit[0]);
              const lng = parseFloat(posSplit[1]);
              var req = new robotApi.ResourceRunCommandRequest();
              let gpsName = "";
              gpses = theApp.filterResources("rdk", "component", "gps");
              if (gpses.length > 0) {
                gpsName = gpses[0].name;
              } else {
                theData.error = "no gps device found";
                return;
              }
              req.setResourceName(gpsName);
              req.setCommandName("set_location");
              req.setArgs(
                proto.google.protobuf.Struct.fromJavaScript({
                  latitude: lat,
                  longitude: lng,
                })
              );
              robotService.resourceRunCommand(req, {}, (err, resp) => grpcCallback(err, resp));
            },
            viewCamera : function(name) {
              const streamContainer = document.getElementById(`stream-${name}`);
              const req = new streamApi.AddStreamRequest();
              req.setName(name);
              streamService.addStream(req, {}, (err, resp) => {
                grpcCallback(err, resp, false)
                if (streamContainer && streamContainer.getElementsByTagName("img").length > 0) {
                    streamContainer.getElementsByTagName("img")[0].remove();
                }
                if (err) {
                  theData.error = "no live camera device found";
                  return;
                }
              });
            },
            viewPreviewCamera : function(name) {
              const streamPreviewContainer = document.getElementById(`stream-preview-${name}`);
              const req = new streamApi.AddStreamRequest();
              req.setName(name);
              streamService.addStream(req, {}, (err, resp) => {
                grpcCallback(err, resp, false);
                if (err) {
                  theData.error = "no live camera device found";
                  return;
                }
              });
            },
            displayRadiansInDegrees: function (r) {
              var d = r * 180;
              while (d < 0) {
                d += 360;
              }
              while (d > 360) {
                d -= 360;
              }
              return d.toFixed(1);
            },
            getGPIO: function (boardName) {
              var pin = document.getElementById("get_pin_" + boardName).value;
              var req = new boardApi.GetGPIORequest();
              req.setName(boardName);
              req.setPin(pin);
              boardService.getGPIO(req, {}, (err, resp) => {
                if (err) {
                  console.log(err);
                  return;
                }
                var x = resp.toObject();
                document.getElementById("get_pin_value_" + boardName).innerHTML = "Pin: " + pin + " is " + (x.high ? "high" : "low");
              });
            },
            setGPIO: function (boardName) {
              var pin = document.getElementById("set_pin_" + boardName).value;
              var v = document.getElementById("set_pin_v_" + boardName).value;
              var req = new boardApi.SetGPIORequest();
              req.setName(boardName);
              req.setPin(pin);
              req.setHigh(v === "high");
              boardService.setGPIO(req, {}, grpcCallback);
            },
          },
          directives: {
            // TODO(RDK-41): replace with vue component after naveed work done
            mapMounted(el) {
              if (theData.mapOnce) {
                return;
              }
              theData.mapOnce = true;
              initNavigation();
            },
          },
        });

        const relevantSubtypesForStatus = ["arm", "gantry", "board", "servo", "motor", "input_controller"];

        const loadCurrentOps = async function () {
          var req = new robotApi.GetOperationsRequest();
          robotService.getOperations(req, {}, (err, resp) => {
            var lst = resp.toObject().operationsList;
            theData.currentOps = lst;
          });
          setTimeout(loadCurrentOps, 500);
        };

        // query metadata service every 0.5s
        const queryMetadata = async function () {
          let pResolve;
          let pReject;
          let p = new Promise((resolve, reject) => {
            pResolve = resolve;
            pReject = reject;
          });
          let resourcesChanged = false;
          let shouldRestartStatusStream = false;
          robotService.resourceNames(new robotApi.ResourceNamesRequest(), {}, function (err, resp) {
            grpcCallback(err, resp, false);
            if (err) {
              pReject(err);
              return;
            }
            resources = resp.toObject().resourcesList;

            // if resource list has changed, flag that
            let differences = new Set(theData.resources.map((name) => theApp.resourceNameToString(name)));
            let resourceSet = new Set(resources.map((name) => theApp.resourceNameToString(name)));
            for (let elem of resourceSet) {
              if (differences.has(elem)) {
                differences.delete(elem);
              } else {
                differences.add(elem);
              }
            }
            if (differences.size > 0) {
              resourcesChanged = true;

              // restart status stream if resource difference includes a resource we care about
              for (let elem of differences) {
                let name = theApp.stringToResourceName(elem);
                if (name.namespace == "rdk" && name.type == "component" && relevantSubtypesForStatus.includes(name.subtype)) {
                  shouldRestartStatusStream = true;
                  break;
                }
              }
            }

            theData.resources = resources;
            pResolve(null);
          });
          await p;

          if (resourcesChanged === true) {
            querySensors();

            if (shouldRestartStatusStream === true) {
              restartStatusStream();
            }
          }
          setTimeout(() => queryMetadata(), 500);
        };

        const querySensors = async function () {
          let pResolve;
          let pReject;
          p = new Promise((resolve, reject) => {
            pResolve = resolve;
            pReject = reject;
          });
          sensorsService.getSensors(new sensorsApi.GetSensorsRequest(), {}, function (err, resp) {
            grpcCallback(err, resp, false);
            if (err) {
              pReject(err);
              return;
            }
            theData.sensorNames = resp.toObject().sensorNamesList;
            pResolve(null);
          });
        };

        // query stream service every 0.5s
        const streamServiceCallback = function (err, resp) {
          grpcCallback(err, resp, false);
          if (err) {
            return;
          }
          let streamNames = resp.toObject().namesList;
          theData.streamNames = streamNames;
        };
        const queryStreams = async function () {
          let pResolve;
          let pReject;
          let p = new Promise((resolve, reject) => {
            pResolve = resolve;
            pReject = reject;
          });
          streamService.listStreams(new streamApi.ListStreamsRequest(), {}, function (err, resp) {
            grpcCallback(err, resp, false);
            if (err) {
              pReject(err);
              return;
            }
            let streamNames = resp.toObject().namesList;
            theData.streamNames = streamNames;
            pResolve(null);
          });
          await p;
          setTimeout(() => queryStreams(), 500);
        };

        let statusStream;
        let lastStatusTS = Date.now();
        const checkIntervalMillis = 3000;
        const checkLastStatus = function () {
          if (Date.now() - lastStatusTS > checkIntervalMillis) {
            restartStatusStream();
            return;
          }
          setTimeout(checkLastStatus, checkIntervalMillis);
        };

        const restartStatusStream = async function () {
          if (statusStream) {
            statusStream.cancel();
            try {
              console.log("reconnecting");
              await window.connect();
            } catch (e) {
              console.error("failed to reconnect; retrying:", e);
              setTimeout(() => restartStatusStream(), 1000);
            }
          }
          let resourceNames = [];
          // get all relevant resource names
          relevantSubtypesForStatus.forEach((subtype) => (resourceNames = resourceNames.concat(theApp.filterResources("rdk", "component", subtype))));
          let names = resourceNames.map((name) => {
            let resourceName = new commonApi.ResourceName();
            resourceName.setNamespace(name.namespace);
            resourceName.setType(name.type);
            resourceName.setSubtype(name.subtype);
            resourceName.setName(name.name);
            return resourceName;
          });
          const streamReq = new statusApi.StreamStatusRequest();
          streamReq.setResourceNamesList(names);
          streamReq.setEvery(new proto.google.protobuf.Duration().setNanos(500000000)); // 500ms
          statusStream = statusService.streamStatus(streamReq);
          let firstData = true;
          statusStream.on("data", function (response) {
            lastStatusTS = Date.now();
            updateStatus(response.getStatusList());
            if (firstData) {
              firstData = false;
              checkLastStatus();
            }
          });
          statusStream.on("status", function (status) {
            console.log("error streaming robot status");
            console.log(status);
            console.log(status.code, " ", status.details);
          });
          statusStream.on("end", function (end) {
            console.log("done streaming robot status");
            setTimeout(() => restartStatusStream(), 1000);
          });
        };
        queryMetadata();
        loadCurrentOps();
        if (window.streamService) {
          queryStreams();
        }
      }

      pcdGlobal = null;

      function initPCDIfNeeded() {
        if (pcdGlobal) {
          return;
        }
        theData.pcdClick.enable = true;
        console.log("initing pcd");

        const sphereGeometry = new THREE.SphereGeometry(0.009, 32, 32);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });

        pcdGlobal = {
          scene: new THREE.Scene(),
          camera: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000),
          renderer: new THREE.WebGLRenderer(),
          raycaster: new THREE.Raycaster(),
          sphere: new THREE.Mesh(sphereGeometry, sphereMaterial),
        };

        pcdGlobal.renderer.setSize(window.innerWidth / 2, window.innerHeight / 2);
        document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);

        pcdGlobal.controls = new orbitLib.OrbitControls(pcdGlobal.camera, pcdGlobal.renderer.domElement);
        pcdGlobal.camera.position.set(0, 0, 0);
        pcdGlobal.controls.target.set(0, 0, -1);
        pcdGlobal.controls.update();
        pcdGlobal.camera.updateMatrix();

        console.log("pcd init done");
      }

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function pcdAnimate() {
        if (resizeRendererToDisplaySize(pcdGlobal.renderer)) {
          const canvas = pcdGlobal.renderer.domElement;
          pcdGlobal.camera.aspect = canvas.clientWidth / canvas.clientHeight;
          pcdGlobal.camera.updateProjectionMatrix();
        }
        pcdGlobal.renderer.render(pcdGlobal.scene, pcdGlobal.camera);
        pcdGlobal.controls.update();
        requestAnimationFrame(pcdAnimate);
      }

      function pcdLoad(path) {
        var loader = new pcdLib.PCDLoader();
        loader.load(
          path,

          // called when the resource is loaded
          function (mesh) {
            pcdGlobal.scene.clear();
            pcdGlobal.scene.add(mesh);
            pcdGlobal.scene.add(pcdGlobal.sphere);
            if (pcdGlobal.cube) {
              pcdGlobal.scene.add(pcdGlobal.cube);
            }
            pcdAnimate();
          },
          // called when loading is in progresses
          function (xhr) {
            //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
          },
          // called when loading has errors
          function (error) {
            console.log(error);
          }
        );
        theData.pcdClick.pcdloaded = true;
      }

      function r(n) {
        return Math.round(n * 1000);
      }

      function setPoint(point) {
        theData.pcdClick.x = r(point.x);
        theData.pcdClick.y = r(point.y);
        theData.pcdClick.z = r(point.z);
        pcdGlobal.sphere.position.copy(point);
      }

      function setBoundingBox(box, centerPoint) {
        const geometry = new THREE.BoxGeometry(box.getWidthMm() / 1000, box.getLengthMm() / 1000, box.getDepthMm() / 1000);
        const edges = new THREE.EdgesGeometry(geometry);
        const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const cube = new THREE.LineSegments(edges, material);
        cube.position.copy(centerPoint);
        cube.name = "bounding-box";
        pcdGlobal.scene.remove(pcdGlobal.scene.getObjectByName("bounding-box"));
        pcdGlobal.cube = cube;
        pcdGlobal.scene.add(cube);
      }

      async function doConnect(authEntity, creds, onError) {
        console.debug("connecting");
        document.getElementById("connecting-error").innerHTML = "";
        document.getElementById("connecting").classList.add("connecting");
        try {
          await window.connect(authEntity, creds);
        } catch (e) {
          const msg = `failed to connect: ${e}`;
          console.error(msg);
          document.getElementById("connecting-error").innerHTML = msg;
          document.getElementById("connecting").classList.remove("connecting");
          if (onError) {
            setTimeout(onError, 1000);
          }
          return;
        }
        console.debug("connected");
        document.getElementById("pre-app").classList.add("connected");
        await startup();
      }

      async function waitForClientAndStart() {
        if (window.supportedAuthTypes.length == 0) {
          doConnect(window.bakedAuth.authEntity, window.bakedAuth.creds, waitForClientAndStart);
          return;
        }

        const authElems = [];
        const disableAll = () => {
          for (elem of authElems) {
            elem.disabled = true;
          }
        };
        const enableAll = () => {
          for (elem of authElems) {
            elem.disabled = false;
          }
        };
        for (authType of window.supportedAuthTypes) {
          const authDiv = document.getElementById(`auth-${authType}`);
          const input = authDiv.getElementsByTagName("input")[0];
          const button = authDiv.getElementsByTagName("button")[0];
          authElems.push(input, button);
          const doLogin = () => {
            disableAll();
            const creds = { type: authType, payload: input.value };
            doConnect("", creds, "", "", () => enableAll());
          };
          button.addEventListener("click", () => doLogin());
          input.addEventListener("keyup", (event) => {
            if (event.keyCode !== 13) {
              return;
            }
            doLogin();
          });
        }
      }

      async function initNavigation() {
        await mapReady;
        window.map = new google.maps.Map(document.getElementById("map"), { zoom: 18 });
        window.map.addListener("click", (e) => {
          var req = new navigationApi.AddWaypointRequest();
          var point = new commonApi.GeoPoint();
          point.setLatitude(e.latLng.lat());
          point.setLongitude(e.latLng.lng());
          req.setLocation(point);
          navigationService.addWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
        });

        let centered = false;
        const knownWaypoints = {};
        let localLabelCounter = 0;
        const updateWaypoints = function () {
          var req = new navigationApi.GetWaypointsRequest();
          navigationService.getWaypoints(req, {}, (err, resp) => {
            grpcCallback(err, resp, false);
            if (err) {
              console.log(err);
              setTimeout(updateWaypoints, 1000);
              return;
            }
            let waypoints = [];
            if (resp) {
              waypoints = resp.getWaypointsList();
            }
            const currentWaypoints = {};
            for (var i = 0; i < waypoints.length; i++) {
              const waypoint = waypoints[i];
              const pos = { lat: waypoint.getLocation().getLatitude(), lng: waypoint.getLocation().getLongitude() };
              const posStr = JSON.stringify(pos);
              if (knownWaypoints[posStr]) {
                currentWaypoints[posStr] = knownWaypoints[posStr];
                continue;
              }
              const marker = new google.maps.Marker({
                position: pos,
                map: window.map,
                label: `${localLabelCounter++}`,
              });
              currentWaypoints[posStr] = marker;
              knownWaypoints[posStr] = marker;
              marker.addListener("click", () => {
                console.log("clicked on marker", pos);
              });
              marker.addListener("dblclick", () => {
                var req = new navigationApi.RemoveWaypointRequest();
                req.setId(waypoint.getId());
                navigationService.removeWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
              });
            }
            const waypointsToDelete = Object.keys(knownWaypoints).filter((elem) => {
              return !(elem in currentWaypoints);
            });
            for (key of waypointsToDelete) {
              const marker = knownWaypoints[key];
              marker.setMap(null);
              delete knownWaypoints[key];
            }
            setTimeout(updateWaypoints, 1000);
          });
        };
        updateWaypoints();

        const locationMarker = new google.maps.Marker({ label: "robot" });
        const updateLocation = function () {
          var req = new navigationApi.GetLocationRequest();
          navigationService.getLocation(req, {}, (err, resp) => {
            grpcCallback(err, resp, false);
            if (err) {
              console.log(err);
              setTimeout(updateLocation, 1000);
              return;
            }
            const pos = { lat: resp.getLocation().getLatitude(), lng: resp.getLocation().getLongitude() };
            if (!centered) {
              centered = true;
              window.map.setCenter(pos);
            }
            locationMarker.setPosition(pos);
            locationMarker.setMap(window.map);
            setTimeout(updateLocation, 1000);
          });
        };
        updateLocation();
      }

      function initMap() {
        mapReadyResolve();
      }

      let mapReadyResolve;
      let mapReady = new Promise((resolve) => {
        mapReadyResolve = resolve;
      });

      function imuRefresh() {
        if (window.theApp) {
          var all = theApp.filterResources("rdk", "component", "imu");
          all.forEach(function (x) {
            var name = x.name;

            if (!theData.imuData[name]) {
              theData.imuData[name] = {};
            }

            var req = new imuApi.ReadOrientationRequest();
            req.setName(name);

            imuService.readOrientation(req, {}, (err, resp) => {
              if (err) {
                console.log(err);
                return;
              }
              theData.imuData[name].orientation = resp.toObject().orientation;
            });

            var req = new imuApi.ReadAngularVelocityRequest();
            req.setName(name);

            imuService.readAngularVelocity(req, {}, (err, resp) => {
              if (err) {
                console.log(err);
                return;
              }
              theData.imuData[name].angularVelocity = resp.toObject().angularVelocity;
            });

            var req = new imuApi.ReadAccelerationRequest();
            req.setName(name);

            imuService.readAcceleration(req, {}, (err, resp) => {
              if (err) {
                console.log(err);
                return;
              }
              theData.imuData[name].acceleration = resp.toObject().acceleration;
            });

            var req = new imuApi.ReadMagnetometerRequest();
            req.setName(name);

            imuService.readMagnetometer(req, {}, (err, resp) => {
              if (err) {
                console.log(err);
                return;
              }
              theData.imuData[name].magnetometer = resp.toObject().magnetometer;
            });
          });
        }
        setTimeout(imuRefresh, 500);
      }
      imuRefresh();
    </script>
  </head>
  <body onLoad="waitForClientAndStart()">
    <div id="pre-app">
      <div id="connecting-error"></div>
      <div id="connecting">Connecting via {{ if .WebRTCEnabled }}WebRTC{{ else }}gRPC{{ end }}...</div>
      {{range $authType := .SupportedAuthTypes }}
      <span>{{ $authType }}: </span>
      <div id="auth-{{ $authType }}">
        <viam-input type="password"/>
        <viam-button group>Login</viam-button>
      </div>
      {{ end }}
    </div>
    <div id="app" v-cloak>
      <div class="p-2">
          <div style="color: red;">${ error }</div>
          <!-- ******* BASE *******  -->
          <div class="base pb-4" v-for="base in filterResources('rdk', 'component', 'base')" :key="base.name">
                <div v-if="!streamNames.length">
                  <div class="camera">
                    <viam-base
                        :base-name="base.name"
                        :connected-camera="false"
                        :crumbs="['base', base.name]"
                        :base-status="baseRunStatus"
                        @keyboard-ctl="baseKeyboardCtl"
                        @base-run="handleBaseAction"
                        @base-stop="handleBaseActionStop(base.name)"
                    ></viam-base>
                  </div>
                </div>
                <div v-else>
                  <div class="camera" v-for="streamName in streamNames" :key="streamName">
                    <viam-base
                        :base-name="base.name"
                        :stream-name="streamName"
                        :crumbs="['base', base.name]"
                        :base-status="baseRunStatus"
                        @base-change-tab="viewPreviewCamera(streamName)"
                        @keyboard-ctl="baseKeyboardCtl"
                        @base-run="handleBaseAction"
                        @base-stop="handleBaseActionStop(base.name)"
                        @show-base-camera="viewPreviewCamera(streamName)"
                    ></viam-base>
                  </div>
                </div>
            </div>

          <!-- ******* GANTRY *******  -->
          <div class="gantry pb-4" v-for="gantry in filterResources('rdk', 'component', 'gantry')" :key="gantry.name" v-if="resourceStatusByName(gantry)">
            <h3>Gantry ${gantry.name}</h3>
            <table  class="table-auto border-collapse border border-slate-400">
                 <th class="border border-slate-300"ead>
                  <tr>
                     <th class="border border-slate-300">axis</th>
                     <th class="border border-slate-300">position</th>
                     <th class="border border-slate-300">length</th>
                  </tr>
                </thead>
                <tbody>
                  <tr v-for="pp in resourceStatusByName(gantry).parts" :key="pp.axis">
                     <th class="border border-slate-300">${pp.axis}</th>
                     <td class="border border-slate-300">
                      <viam-button group v-on:click="gantryInc( gantry, pp.axis, -10 )">--</viam-button>
                      <viam-button group v-on:click="gantryInc( gantry, pp.axis, -1 )">-</viam-button>
                      <viam-button group v-on:click="gantryInc( gantry, pp.axis, 1 )">+</viam-button>
                      <viam-button group v-on:click="gantryInc( gantry, pp.axis, 10 )">++</viam-button>
                    </td>
                     <td class="border border-slate-300">${pp.pos.toFixed(2)}</td>
                     <td class="border border-slate-300">${pp.length}</td>
                  </tr>
                </tbody>
            </table>
          </div>

          <!-- ******* IMU *******  -->
          <div class="pb-4">
            <div v-for="(imu, x) in filterResources('rdk', 'component', 'imu').entries()" :key="imu[1].name">
              <hr />
              <h2>IMU: ${imu[1].name}</h2>
              <table  class="table-auto border-collapse border border-slate-400" v-if="imuData[imu[1].name] && imuData[imu[1].name].angularVelocity">
                <tr> <th class="border border-slate-300" colspan="2">Orientation (degrees)</th></tr>
                <tr> <th class="border border-slate-300">Roll</th> <td class="border border-slate-300">${imuData[imu[1].name].orientation.rollDeg.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Pitch</th> <td class="border border-slate-300">${imuData[imu[1].name].orientation.pitchDeg.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Yaw</th> <td class="border border-slate-300">${imuData[imu[1].name].orientation.yawDeg.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300" colspan="2">Angular Velocity (degrees/second)</th></tr>
                <tr> <th class="border border-slate-300">X</th> <td class="border border-slate-300">${imuData[imu[1].name].angularVelocity.xDegsPerSec.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Y</th> <td class="border border-slate-300">${imuData[imu[1].name].angularVelocity.yDegsPerSec.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Z</th> <td class="border border-slate-300">${imuData[imu[1].name].angularVelocity.zDegsPerSec.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300" colspan="2">Acceleration (mm/second/second)</th></tr>
                <tr> <th class="border border-slate-300">X</th> <td class="border border-slate-300">${imuData[imu[1].name].acceleration.xMmPerSecPerSec.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Y</th> <td class="border border-slate-300">${imuData[imu[1].name].acceleration.yMmPerSecPerSec.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Z</th> <td class="border border-slate-300">${imuData[imu[1].name].acceleration.zMmPerSecPerSec.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300" colspan="2">Magnetometer (gauss)</th></tr>
                <tr> <th class="border border-slate-300">X</th> <td class="border border-slate-300">${imuData[imu[1].name].magnetometer.xGauss.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Y</th> <td class="border border-slate-300">${imuData[imu[1].name].magnetometer.yGauss.toFixed(2)}</td></tr>
                <tr> <th class="border border-slate-300">Z</th> <td class="border border-slate-300">${imuData[imu[1].name].magnetometer.zGauss.toFixed(2)}</td></tr>
              </table>
            </div>
            <hr />
          </div>

          <!-- ******* ARM *******  -->
          <div class="arm pb-4" v-for="arm in filterResources('rdk', 'component', 'arm')" :key="arm.name">
            <h3>Arm ${arm.name}</h3>
            <div style="display: flex; margin-bottom: 1em">
              <table v-if="armToggle[arm.name]" border="1" style="margin-right: 1em" class="border border-slate-300">
                <tr>
                  <th colspan="2" class="border border-slate-300"><h5>END POSITION (mms)</h5></th>
                </tr>
                <tr v-for="cc in armToggle[arm.name].pos_pieces" :key="cc.endPosition[0]">
                  <th class="border border-slate-300">${cc.endPosition[1]}</th>
                  <td class="border border-slate-300"><input v-model="cc.endPositionValue"></td>
                </tr>
                <tr>
                  <th class="border border-slate-300" colspan="2">
                    <viam-button v-on:click="armModifyAllDoEndPosition(arm)">Go To End Position</viam-button>
                    <viam-button v-on:click="armModifyAllCancel(arm)">Cancel</viam-button>
                  </th>
                </tr>
              </table>
              <table v-if="armToggle[arm.name]" border="1" class="border border-slate-300">
                <tr>
                  <th colspan="2" class="border border-slate-300"><h5>JOINTS (degrees)</h5></th>
                </tr>
                <tr v-for="bb in armToggle[arm.name].joint_pieces" :key="bb.joint">
                  <th class="border border-slate-300">Joint ${bb.joint}</th>
                  <td class="border border-slate-300"><input v-model="bb.jointValue"></td>
                </tr>
                <tr>
                  <th class="border border-slate-300" colspan="2">
                    <viam-button v-on:click="armModifyAllDoJoint(arm)">Go To Joints</viam-button>
                    <viam-button v-on:click="armModifyAllCancel(arm)">Cancel</viam-button>
                  </th>
                </tr>
              </table>
            </div>
    
            <div style="display: flex; margin-bottom: 1em">
              <table border="1" v-if="resourceStatusByName(arm)" style="margin-right: 1em" class="border border-slate-300">
                <tr>
                  <th colspan="3" class="border border-slate-300"><h5>END POSITION (mms)</h5></th>
                </tr>
                <tr v-for="aa in resourceStatusByName(arm).pos_pieces" :key="aa.endPosition[0]">
                  <th class="border border-slate-300">${aa.endPosition[1]}</th>
                  <td class="border border-slate-300">
                    <viam-button v-on:click="armEndPositionInc( arm, aa.endPosition[1], -10 )">--</viam-button>
                    <viam-button v-on:click="armEndPositionInc( arm, aa.endPosition[1], -1 )">-</viam-button>
                    <viam-button v-on:click="armEndPositionInc( arm, aa.endPosition[1], 1 )">+</viam-button>
                    <viam-button v-on:click="armEndPositionInc( arm, aa.endPosition[1], 10 )">++</viam-button>
                  </td>
                  <td class="border border-slate-300">${aa.endPositionValue.toFixed(2)}</td>
                </tr>
                <tr>
                  <th class="border border-slate-300" colspan="8">
                    <viam-button v-on:click="armHome(arm)">Home</viam-button>
                    <viam-button v-on:click="armModifyAll(arm)">Modify All</viam-button>
                  </th>
                </tr>
              </table> <!-- end main table -->
              <table border="1" v-if="resourceStatusByName(arm)" class="border border-slate-300">
                <tr>
                  <th colspan="3" class="border border-slate-300"><h5>JOINTS (degrees)</h5></th>
                </tr>
                <tr v-for="aa in resourceStatusByName(arm).joint_pieces" :key="aa.joint">          
                  <th class="border border-slate-300">Joint ${aa.joint}</th>
                  <td class="border border-slate-300">
                    <viam-button v-on:click="armJointInc( arm, aa.joint, -10 )">--</viam-button>
                    <viam-button v-on:click="armJointInc( arm, aa.joint, -1 )">-</viam-button>
                    <viam-button v-on:click="armJointInc( arm, aa.joint, 1 )">+</viam-button>
                    <viam-button v-on:click="armJointInc( arm, aa.joint, 10 )">++</viam-button>
                  </td>
                  <td class="border border-slate-300">${aa.jointValue.toFixed(2)}</td>
                </tr>
                <tr>
                  <th class="border border-slate-300" colspan="8">
                    <viam-button v-on:click="armHome(arm)">Home</viam-button>
                    <viam-button v-on:click="armModifyAll(arm)">Modify All</viam-button>
                  </th>
                </tr>
              </table> <!-- end main table -->
            </div>
          </div>

          <!-- ******* GRIPPER *******  -->
          <div class="gripper pb-4" v-for="gripper in filterResources('rdk', 'component', 'gripper')" :key="gripper.name">
            <h3>Gripper ${ gripper.name }</h3>
            <ul>
              <li><viam-button group v-on:click="gripperAction( gripper.name, 'open')">Open</viam-button></li>
              <li><viam-button group v-on:click="gripperAction( gripper.name, 'grab')">Grab</viam-button></li>
            </ul>
          </div>

          <!-- ******* SERVO *******  -->
          <div
            class="servo pb-4"
            v-for="servo in filterResources('rdk', 'component', 'servo')"
            :key="servo.name"
            v-if="resourceStatusByName(servo)"
            style="margin-bottom: .5em;"
          >
            <table  class="table-auto border-collapse border border-slate-400">
              <tr> <th class="border border-slate-300">Servo</th> <td class="border border-slate-300">${servo.name}</td></tr>
              <tr> <td class="border border-slate-300">Angle</td> <td class="border border-slate-300">${resourceStatusByName(servo).positionDeg}</td></tr>
              <tr>
                 <td class="border border-slate-300"></td>
                 <td class="border border-slate-300">
                  <viam-button group v-on:click="servoMove(servo, -10)">-10</viam-button>
                  <viam-button group v-on:click="servoMove(servo, -1)">-1</viam-button>
                  <viam-button group v-on:click="servoMove(servo, 1)">1</viam-button>
                  <viam-button group v-on:click="servoMove(servo, 10)">10</viam-button>
                </td>
              </tr>
            </table>
          </div>

          <!-- ******* MOTOR *******  -->
          <motor-detail
            class="pb-4"
            v-for="motor in filterResources('rdk', 'component', 'motor')"
            :key="'new-' + motor.name"
            v-if="resourceStatusByName(motor)"
            v-bind:motor-name="motor.name"
            v-bind:motor-status="resourceStatusByName(motor)"
            v-on:execute="motorCommand(motor.name, $event)"
            style="max-width: 1080px;"
          >
          </motor-detail>

          <!-- ******* INPUT VIEW *******  -->
          <input-controller
            class="pb-4"
            v-for="controller in filteredInputControllerList()"
            :key="'new-' + controller.name"
            v-if="resourceStatusByName(controller)"
            v-bind:controller-name="controller.name"
            v-bind:controller-status="resourceStatusByName(controller)"
            style="max-width: 1080px;"
          >
          </input-controller>

          <!-- ******* WEB CONTROLS *******  -->
          <web-gamepad class="pb-4" v-if="hasWebGamepad()" v-on:execute="inputInject($event)" style="max-width: 1080px;"> </web-gamepad>

                    <!-- ******* BOARD *******  -->
          <div class="board pb-4" v-for="board in filterResources('rdk', 'component', 'board')" v-if="resourceStatusByName(board)" :key="board.name">
            <h3>Board ${board.name}</h3>
            <table  class="table-auto border-collapse border border-slate-400">

              <tr> <th class="border border-slate-300" colspan="2">Analogs</th></tr>
              <tr v-for="(analog, name) in resourceStatusByName(board).analogsMap" :key="name">
                 <th class="border border-slate-300">${name}</th>
                 <td class="border border-slate-300">${analog.value || 0}</td>
              </tr>

              <tr> <th class="border border-slate-300" colspan="2">DigitalInterrupts</th></tr>
              <tr v-for="(di, name) in resourceStatusByName(board).digitalInterruptsMap" :key="name">
                 <th class="border border-slate-300">${name}</th>
                 <td class="border border-slate-300">${di.value || 0}</td>
              </tr>

              <tr> <th class="border border-slate-300" colspan="2">GPIO</th></tr>
              <tr>
                 <th class="border border-slate-300">Get</th>
                 <td class="border border-slate-300">
                  Pin: <viam-input :id="'get_pin_' + board.name"/><viam-button group v-on:click="getGPIO(board.name)">Get</viam-button><br>
                  <span :id="'get_pin_value_' + board.name"/>
                </td>
              </tr>
              <tr>
                 <th class="border border-slate-300">Set</th>
                 <td class="border border-slate-300">
                  Pin: <viam-input :id="'set_pin_' + board.name"/><br>
                  <select :id="'set_pin_v_' + board.name">
                    <option>low</option>
                    <option>high</option>
                  </select>
                  <viam-button group v-on:click="setGPIO(board.name)">Set</viam-button><br>
                </td>
              </tr>
            </table>
          </div>
          <!-- end boards -->

          <div class="pb-4">
            <table  class="table-auto border-collapse border border-slate-400" border=1 v-if="nonEmpty(sensorNames)">
              <tr>
                <th class="border border-slate-300" colspan="2">Sensors</th>
              </tr>

              <tr>
                <th class="border border-slate-300">Name</th>
                <th class="border border-slate-300">Type</th>
                <th class="border border-slate-300">Readings</th>
                <th class="border border-slate-300" colspan="2"> <viam-button group v-on:click="getReadings(sensorNames)">Get All Readings</viam-button></th>
              </tr>

              <tr v-for="name in sensorNames">
                <td class="border border-slate-300">${name.name}</td>
                <td class="border border-slate-300">${name.subtype}</td>
                <td class="border border-slate-300">${sensorReadings[resourceNameToString(name)]}</td>
                <td class="border border-slate-300"> <viam-button group v-on:click="getReadings([name])">Get Readings</viam-button></td>
              </tr>
            </table>
          </div>
          <!-- get segments -->
          <div class="pb-4" id="map-container" v-if="filterResources('rdk', 'service', 'navigation').length !== 0">
            <br />
            <br />
            <viam-button group v-on:click="setNavigationMode('manual')">Manual</viam-button>
            <viam-button group v-on:click="setNavigationMode('waypoint')">Waypoint</viam-button>
            <br />
            <viam-input type="text" id="nav-set-location" value="40.745297,-74.010916" />
            <viam-button group v-on:click="setNavigationLocation('nav-set-location')">Try Set Location</viam-button>
            <div id="map" v-map-mounted></div>
          </div>
          <div class="pb-4">
            <h3>Current Operations</h3>
            <table class="table-auto border-collapse border border-slate-400">
              <tr>
                <th class="border border-slate-300">id</th>
                <th class="border border-slate-300">method</th>
                <th class="border border-slate-300">elapsed time</th>
                <th class="border border-slate-300"></th>
              </tr>
              <tr v-for="o in currentOps" :key="o.id">
                <td class="border border-slate-300">${o.id}</td>
                <td class="border border-slate-300">${o.method}</td>
                <td class="border border-slate-300">${(new Date()).getTime() - (o.started.seconds * 1000)}ms</td>
                <td class="border border-slate-300"><button v-on:click="killOp(o.id)">Kill</button></td>
              </tr>
            </table>
          </div>

          <!-- ******* CAMERAS *******  -->
          <div class="camera pb-4" v-for="streamName in streamNames" :key="streamName">
              <camera
                      :stream-name="streamName"
                      :crumbs="[streamName]"
                      :x="pcdClick.x"
                      :y="pcdClick.y"
                      :z="pcdClick.z"
                      :pcd-click="pcdClick"
                      :segmenter-names="segmenterNames"
                      :segmenter-parameters="segmenterParameters"
                      :segmenter-parameter-names="segmenterParameterNames"
                      :parameter-type="parameterType"
                      :segment-algo="segmentAlgo"
                      :segment-objects="objects"
                      @full-image="doPCDLoad(fullcloud)"
                      @find-segments="findSegments(segmentAlgo, segmenterParameters)"
                      @change-segmenter="getSegmenterParameters"
                      @toggle-camera="viewCamera(streamName)"
                      @refresh-camera="viewCameraFrame"
                      @selected-camera-view="viewCameraFrame"
                      @toggle-pcd="renderPCD(streamName); getSegmenterNames()"
                      @pcd-click="grabClick"
                      @pcd-move="doPCDMove"
                      @point-load="doPointLoad"
                      @segment-load="doSegmentLoad"
                      @bounding-box-load="doBoundingBoxLoad"
                      @download-screenshot="renderFrame(streamName)"
                      @download-raw-data="doPCDLoad(fullcloud)"
                      @select-object="doSelectObject"
              ></camera>
          </div>
        </div>
    </div>
    <!-- end vue app -->

    <!-- TODO(RDK-70): remove api key once going into production -->
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBn72TEqFOVWoj06cvua0Dc0pz2uvq90nY&callback=initMap&libraries=&v=weekly" async></script>
  </body>
</html>
