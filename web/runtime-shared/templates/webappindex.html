<html>
  <head>
    <style type="text/css" media="screen">
      #source {
        position: relative;
        width: 50%;
        height: 50%;
      }
      #map {
        height: 400px;
        width: 100%;
      }
    </style>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
    <script>
      window.webrtcEnabled = {{ .WebRTCEnabled }}
      window.webrtcHost = {{ .WebRTCHost }}
      window.webrtcSignalingAddress = {{ .WebRTCSignalingAddress }}
      window.webrtcAdditionalICEServers = {{ .WebRTCAdditionalICEServers }}
    </script>
    {{ if .External }}
    <script src="/static/core/control.js"></script>
    <script src="/static/core/third-party/vue.js"></script>
    <script src="/static/core/third-party/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <link rel="stylesheet" href="/static/core/components/coreComponents.css">
    <script type="module">
      import "/static/core/components/coreComponents.umd.min.js";
    </script>
    {{ else }}
    <script src="/static/control.js"></script>
    <script src="/static/third-party/vue.js"></script>
    <script src="/static/third-party/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <link rel="stylesheet" href="/static/components/coreComponents.css">
    <script type="module">
      import "/static/components/coreComponents.umd.min.js";
    </script>
    {{ end }}

    <script>
      function roundTo2Decimals(num) {
          num = Math.round(num * 100);
          return num / 100;
      }

      function grpcCallback(err, resp, stringify) {
        if (err) {
          theData.error = JSON.stringify(err);
          return;
        }
        if (stringify === undefined || stringify) {
          try {
            if (resp.toJavaScript) {
              theData.res = JSON.stringify(resp.toJavaScript());
            } else {
              theData.res = JSON.stringify(resp.toObject());
            }
          } catch (e) {
            theData.error = JSON.stringify(e);
          }
        }
      }

      {{ range $view := .Views }}
        {{ jsSafe $view.JavaScript }}
      {{ end }}

      function fixArms(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              const [armName, armValue] = old[i];
              var newArm = { name : armName, pieces : [] };

              var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["theta", "Theta"], ["oX", "OX"], ["oY", "OY"], ["oZ", "OZ"]];
              for (var j=0; j<fieldSetters.length; j++ ){
                  let gridField = fieldSetters[j][0].split(".");
                  let gridValue = armValue.gridPosition[gridField[0]];
                  for (let k = 1; k < gridField.length; k++) {
                    gridValue = gridValue[gridField[k]];
                  }
                  newArm.pieces.push( { grid : fieldSetters[j],
                                        joint : j,
                                        gridValue : gridValue,
                                        jointValue : armValue.jointPositions.degreesList[j] || 0,
                                      });
              }

              n.push(newArm);
          }
          return n;
      }

      function fixGantries(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              var o = { name : old[i][0], parts : [] };

              var x = old[i][1];
              
              if (x.positionsList.length != x.lengthsList.length) {
                  throw "gantry lists different lengths";
              }
              
              for ( var i=0; i < x.positionsList.length; i++) {
                  o.parts.push( { axis : i, pos : x.positionsList[i], length : x.lengthsList[i] } );
              }

              n.push(o);
          }
          return n;
      }

      firstResult = false;

      async function updateStatus(rawStatus) {
          theData.rawStatus = rawStatus;
          window.rawStatus = rawStatus;
          // toObject gives annoying suffixes; see https://github.com/protocolbuffers/protobuf/issues/6773
          const rawStatusObj = rawStatus.toObject();

          var status = {}

          // make vue friendly
          status.armsMap = rawStatusObj.armsMap;
          status.basesMap = rawStatusObj.basesMap;
          status.gantriesMap = rawStatusObj.gantriesMap;
          status.grippersMap = rawStatusObj.grippersMap;
          status.boardsMap = rawStatusObj.boardsMap;
          status.camerasMap = rawStatusObj.camerasMap;
          status.sensorsMap = rawStatusObj.sensorsMap;
          status.servosMap = rawStatusObj.servosMap;
          status.motorsMap = rawStatusObj.motorsMap;
          status.functionsMap = rawStatusObj.functionsMap;
          status.servicesMap = rawStatusObj.servicesMap;

          status.armsMap = fixArms(status.armsMap);
          status.gantriesMap = fixGantries(status.gantriesMap);

          status.inputControllersMap = [];
          status.webGamepad = false;
          for (let i of rawStatusObj.inputControllersMap) {
            if (i[0] === "WebGamepad") {
              status.webGamepad = true;
            }else{
              status.inputControllersMap.push(i);
            }
          }

          if (!firstResult) {
            console.log(rawStatusObj);
            console.log(status);
            firstResult = true;
          }

          theData.status = status;
      }

      async function startup() {
          theData = {
              error : "",
              res : {},
              rawStatus : null,
              status : {},
              pcdClick : {},
              resources: [],
              fullcloud: null,
              segments : null,
              segCenters : null,
              minPtsPlane : 10000,
              minPtsSegment: 100,
              clusterRad: 5,
              armToggle : {},
              editor: undefined,
              mapOnce: false,
              chartStream: null,
              value: 0,

          };
          theApp = new Vue({
              el: '#app',
              delimiters: ['${', '}'],
              data: theData,
              components: {},
              methods : {
                  filterResources : function(namespace, type, subtype) {
                    return theData.resources.filter(elem => {
                      return elem.namespace == namespace && elem.type == type && elem.subtype == subtype
                    })
                  },
                  armByName : function(name) {
                    return theData.status.armsMap.find(elem => elem.name == name) || {}
                  },
                  gantryByName : function(name) {
                      return theData.status.gantriesMap.find(elem => elem.name == name) || {}
                  },
                  gantryInc : function(name, axis, amount) {
                      var g = theData.status.gantriesMap.find(elem => elem.name == name);
                      var pos = [];
                      for ( var i=0; i < g.parts.length; i++) {
                          pos[i] = g.parts[i].pos;
                      }
                      pos[axis] += amount;
                      
                      const req = new gantryApi.GantryServiceMoveToPositionRequest();
                      req.setName(name);
                      req.setPositionsList(pos);
                      gantryService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armGridInc : function(name, getterSetter, amount) {
                      if (getterSetter[0] == 'o' || getterSetter[0] == 'O') {
                          amount /= 100;
                      }
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();
                      var newPosition = Object.assign(Object.create(commonApi.Pose.prototype), old);
                      const getter = `get${getterSetter}`;
                      const setter = `set${getterSetter}`;
                      newPosition[setter](newPosition[getter]() + amount);
                      const req = new armApi.ArmServiceMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorPIDStep: function(motor,req,chart,val){
                      if (theData.chartStream){
                          theData.chartStream.cancel()
                          theData.chartStream = null
                          chart.pause();
                          if(val){
                              return
                          }
                      }
                      req.setName(motor);
                      theData.chartStream = robotService.motorPIDStep(req)
                      chart.unpause();
                      theData.chartStream.on('data', function(resp){
                          this.addData(resp)
                          //chart.update('quiet')
                      }.bind(chart))
                      theData.chartStream.on('status', function(status) {
                          console.log("error streaming PID Data");
                          console.log(status);
                          console.log(status.code, " ", status.details);
                      });
                      theData.chartStream.on('end', function(end) {
                          console.log("done streaming PID Data");
                      });
                  },
                  armJointInc : function(name, field, amount) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(armApi.ArmJointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      newList[field] += amount;
                      newPosition.setDegreesList(newList);
                      const req = new armApi.ArmServiceMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armHome : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(armApi.ArmJointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      for (var i = 0; i < newList.length; i++) {
                        newList[i] = 0;
                      }
                      newPosition.setDegreesList(newList);
                      const req = new armApi.ArmServiceMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armModifyAll : function(name) {
                      const arm = theApp.armByName(name);
                      var n = { name : name, pieces : [] };

                      for ( var i=0; i < arm.pieces.length; i++) {
                          n.pieces.push( {
                              grid : arm.pieces[i].grid,
                              gridValue : roundTo2Decimals(arm.pieces[i].gridValue),
                              joint : arm.pieces[i].joint,
                              jointValue : roundTo2Decimals(arm.pieces[i].jointValue),
                          });

                      }

                      theData.armToggle[name] = n;
                  },
                  armModifyAllCancel : function(name) {
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoGrid : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();

                      var newPosition = Object.assign(Object.create(commonApi.Pose.prototype), old);
                      var newPieces = theData.armToggle[name].pieces;

                      for (var i=0; i < newPieces.length; i++) {
                          var getterSetter = newPieces[i].grid[1];
                          const getter = `get${getterSetter}`;
                          const setter = `set${getterSetter}`;
                          newPosition[setter](newPieces[i].gridValue);
                      }

                      const req = new armApi.ArmServiceMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoJoint : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();

                      var newPosition = Object.assign(Object.create(armApi.ArmJointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();

                      var newPieces = theData.armToggle[name].pieces;
                      for (var i=0; i < newPieces.length && i < newList.length; i++) {
                          newList[newPieces[i].joint] = newPieces[i].jointValue;
                      }

                      newPosition.setDegreesList(newList);

                      const req = new armApi.ArmServiceMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },

                  gripperAction : function(name, action) {
                      let req;
                      switch (action) {
                        case 'open':
                          req = new robotApi.GripperOpenRequest();
                          req.setName(name);
                          robotService.gripperOpen(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'grab':
                          req = new robotApi.GripperGrabRequest();
                          req.setName(name);
                          robotService.gripperGrab(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  servoMove : function(name, amount) {
                      const servo = theData.rawStatus.getServosMap().get(name);
                      var old = servo.getAngle();
                      var angle = old + amount;
                      const req = new robotApi.ServoMoveRequest();
                      req.setName(name);
                      req.setAngleDeg(angle);
                      robotService.servoMove(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorCommand: function(motor, cmd) {
                    let req = cmd.request;
                    req.setName(motor);

                    switch (cmd.type) {
                      case "go":
                        robotService.motorGo(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goFor":
                        robotService.motorGoFor(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goTo":
                        robotService.motorGoTo(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                    }
                  },
                  inputInject: function(req) {
                    robotService.inputControllerInjectEvent(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  pidCommand: function(motor,cmd){
                      let req = cmd.request;
                      req.setName(motor);
                      switch (cmd.type) {
                      case "gain":
                          robotService.motorSetPIDConfig(req, {}, (err, resp) => grpcCallback(err, resp));

                          break;
                      case "step":
                        this.motorPIDStep(motor,req,cmd.chart,1)
                          break;
                      }
                  },
                  doAction : function(name) {
                      const req = new robotApi.DoActionRequest();
                      req.setName(name);
                      robotService.doAction(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  baseAction : function(name, action, amount) {
                      let req;
                      switch (action) {
                        case 'straight':
                          req = new robotApi.BaseMoveStraightRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          robotService.baseMoveStraight(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'arc':
                          req = new robotApi.BaseMoveArcRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          req.setAngleDeg(document.getElementById("angle").value);
                          robotService.baseMoveArc(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'angle':
                          req = new robotApi.BaseSpinRequest();
                          req.setName(name);
                          req.setDegsPerSec(document.getElementById("speed").value)
                          req.setAngleDeg(amount);
                          req.setAngleDeg(document.getElementById("angle").value * amount);
                          robotService.baseSpin(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  renderFrame : function(cameraName) {
                      req = new robotApi.CameraFrameRequest();
                      req.setName(cameraName);
                      const mimeType = 'image/png';
                      req.setMimeType(mimeType)
                      robotService.cameraFrame(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        let blob = new Blob([resp.getFrame_asU8()], { type: mimeType });
                        window.open(URL.createObjectURL(blob), "_blank");
                      });
                  },
                  renderPCD : function(cameraName) {
                      theData.pcdClick.pcdloaded = false;
                      theData.pcdClick.foundSegments = false;
                      initPCDIfNeeded();
                      pcdGlobal.cameraName = cameraName;

                      req = new robotApi.PointCloudRequest();
                      req.setName(cameraName);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType)
                      robotService.pointCloud(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        console.log("loading pcd");
                        theData.fullcloud = resp.getFrame_asB64();
                        pcdLoad(`data:${mimeType};base64,${theData.fullcloud}`);
                      });

                  },
                  doSensorReadings : function(name) {
                      var req = new robotApi.SensorReadingsRequest();
                      req.setName(name);
                      robotService.sensorReadings(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  processFunctionResults: function(err, resp) {
                    grpcCallback(err, resp, false)
                    if (err) {
                      document.getElementById("function_results").value = `${err}`;
                      return;
                    }
                    var results = resp.getResultsList();

                    let resultStr = '';
                    if (results.length > 0) {
                      resultStr += 'Results: \n';
                      for (let i = 0; i < results.length && i < results.length; i++) {
                        let result = results[i];
                        resultStr += `${i}: ${JSON.stringify(result.toJavaScript())}\n`;
                      }
                    }
                    resultStr += `StdOut: ${resp.getStdOut()}\n`;
                    resultStr += `StdErr: ${resp.getStdErr()}\n`;
                    document.getElementById("function_results").value = resultStr;
                  },
                  executeFunction : function(name) {
                      document.getElementById("function_results").value = "";
                      var req = new robotApi.ExecuteFunctionRequest();
                      req.setName(name);
                      robotService.executeFunction(req, {}, this.processFunctionResults);
                  },
                  evalSource : function() {
                    document.getElementById("function_results").value = "";
                    var req = new robotApi.ExecuteSourceRequest();
                    req.setSource(theData.editor.getValue());
                    req.setEngine('javascript');
                    robotService.executeSource(req, {}, this.processFunctionResults);
                  },
                  visualizeForceMatrix: function(name, type, id) {
                    document.getElementById('force-button-id-' + id).style.visibility = 'hidden';

                    // 2D animation stuff
                    let canvas2D = document.getElementById('force-2d-id-' + id);
                    var animation_stuff_2D = {
                      ctx: canvas2D.getContext('2d'),
                      squareWidth: 50,
                      maxValue: 1,
                      canvasId: 'force-2d-id-' + id
                    }

                    // 3D animation stuff
                    var width = 500;
                    var height = 500;

                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color( 0xFBE7C6 );
                    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);

                    const renderer = new THREE.WebGLRenderer();
                    renderer.setSize(width, height);
                    var div_3d = document.getElementById('force-3d-id-' + id);
                    div_3d.appendChild(renderer.domElement);
                    camera.position.z = 4;
                    camera.position.y = -4;

                    var animation_stuff_3D = {
                      cubes: [],
                      scene: scene
                    }

                    // Allows moving the 3D scene using the mouse
                    controls = new trackLib.TrackballControls( camera, renderer.domElement);
                    controls.target.set( 0, 0, 0 )
                    controls.rotateSpeed = 1.0

                    let startedForceAnimation = false;
                    const timeInterval = 10; // in milliseconds
                    // Loop through grabbing data & visualizing it
                    setTimeout(function getDataAndVisualizeIt(name, id) {
                      let req = new robotApi.ForceMatrixMatrixRequest();
                      req.setName(name);

                      let slipReq = new robotApi.ForceMatrixSlipDetectionRequest();
                      slipReq.setName(name);

                      if (type === "forcematrix") {
                        robotService.forceMatrixMatrix(req, {}, (err, resp) => animateForceMatrix(err, resp, animation_stuff_2D, animation_stuff_3D));
                        robotService.forceMatrixSlipDetection(req, {}, (err, resp) => updateSlipDetectionResult(err, resp, id));
                      } else {
                        console.log("error: unknown force matrix type");
                      }

                      // Start the 3D game engine animation if it hasn't been started yet
                      if (!startedForceAnimation) {
                        startedForceAnimation = true;
                        function animate() {
                            requestAnimationFrame( animate );
                            controls.update()
                            renderer.render( scene, camera );
                        }
                        animate();
                      }

                      setTimeout(getDataAndVisualizeIt, 10, name, id);
                    }, timeInterval, name, id);
                  },
                  nonEmpty : function(d) {
                      for ( var k in d ) {
                          return true;
                      }
                      return false;
                  },
                  hasKey : function(d, key) {
                    if (!d) {
                      return false;
                    }
                    if (Array.isArray(d)) {
                      for (let i = 0; i < d.length; i++) {
                        if (d[i] == key || (d[i].length && d[i].length >= 1 && d[i][0] == key)) {
                          return true;
                        }
                      }
                      return false;
                    }
                    return d.hasOwn(key);
                  },
                  grabClick : function(e) {
                      var mouse = new THREE.Vector2();
                      mouse.x = ((e.offsetX / e.srcElement.offsetWidth) * 2) - 1
                      mouse.y = ((e.offsetY / e.srcElement.offsetHeight) * -2) + 1

	                  pcdGlobal.raycaster.setFromCamera( mouse, pcdGlobal.camera );

	                  var intersects = pcdGlobal.raycaster.intersectObjects( pcdGlobal.scene.children );
                      var p = ( intersects.length ) > 0 ? intersects[ 0 ] : null;

                      if ( p !== null ) {
                        console.log(p.point);
                        setPoint(p.point);
                      } else {
                        console.log("no point intersected");
                      }

                  },
                  doPCDGrab : function(){
                      let gripperName = theData.status.grippersMap[0][0];
                      let armName = theData.status.armsMap[0].name;
                      let cameraName = pcdGlobal.cameraName;
                      let cameraPointX = theData.pcdClick.x;
                      let cameraPointY = theData.pcdClick.y;
                      let cameraPointZ = theData.pcdClick.z;

                      let req = new robotApi.ObjectManipulationServiceDoGrabRequest();
                      let cameraPoint = new robotApi.Vector3();
                      cameraPoint.setX(cameraPointX);
                      cameraPoint.setY(cameraPointY);
                      cameraPoint.setZ(cameraPointZ);

                      req.setArmName(armName);
                      req.setCameraName(cameraName);
                      req.setCameraPoint(cameraPoint);
                      req.setGripperName(gripperName);
                      console.log("making grab attempt");
                      console.log(gripperName);

                      robotService.objectManipulationServiceDoGrab(req, {}, 
                        (err, resp) => {
                          grpcCallback(err, resp);
                          if (err) {
                            return Promise.reject(err);
                          }
                          return Promise.resolve(resp).then(console.log);
                      })
                  },
                  findSegments : function(minPointsPlane, minPointsSegment, clusteringRadius){
                      theData.pcdClick.calculatingSegments = true;
                      req = new robotApi.ObjectPointCloudsRequest();
                      console.log("camera name: "+pcdGlobal.cameraName);
                      req.setName(pcdGlobal.cameraName);
                      req.setMinPointsInPlane(minPointsPlane);
                      req.setMinPointsInSegment(minPointsSegment);
                      req.setClusteringRadius(clusteringRadius);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType);
                      console.log("finding object segments...");
                      robotService.objectPointClouds(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          console.log("error getting segments");
                          theData.pcdClick.calculatingSegments = false;
                          return;
                        }
                        console.log("got pcd segments");
                        theData.pcdClick.foundSegments = true;
                        theData.segments = resp.getFramesList_asB64();
                        theData.segCenters = resp.getCentersList();
                        theData.segBoundingBoxes = resp.getBoundingBoxesList();
                        theData.pcdClick.calculatingSegments = false;
                      });
                  },
                  doSegmentLoad : function(data, i){
                        var center = theData.segCenters[i];
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  doPointLoad : function(i){
                        var center = theData.segCenters[i];
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                  },
                  doBoundingBoxLoad : function(i){
                        var box = theData.segBoundingBoxes[i];
                        var center = theData.segCenters[i];
                        var centerP = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        setBoundingBox(box, centerP);
                  },
                  doPCDLoad : function(data){
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  setNavigationMode : function(mode){
                    let pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_UNSPECIFIED;
                    switch (mode) {
                      case 'manual':
                        pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_MANUAL;
                        break;
                      case 'waypoint':
                        pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_WAYPOINT;
                        break;
                    }
                    var req = new robotApi.NavigationServiceSetModeRequest();
                    req.setMode(pbMode);
                    robotService.navigationServiceSetMode(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  setNavigationLocation: function(elId) {
                    const posSplit = document.getElementById(elId).value.split(",");
                    if (posSplit.length != 2) {
                      return;
                    }
                    const lat = parseFloat(posSplit[0]);
                    const lng = parseFloat(posSplit[1]);
                    var req = new robotApi.ResourceRunCommandRequest();
                    let gpsName = "";
                    for (let i = 0; i < theData.status.sensorsMap.length; i++) {
                      const s = theData.status.sensorsMap[i];
                      if (s[1].type === 'gps') {
                        gpsName = s[0];
                        break;
                      }
                    }
                    if (gpsName === "") {
                      theData.error = "no gps device found";
                      return;
                    }
                    req.setResourceName("gps1");
                    req.setCommandName("set_location");
                    req.setArgs(proto.google.protobuf.Struct.fromJavaScript({
                      latitude: lat,
                      longitude: lng,
                    }))
                    robotService.resourceRunCommand(req, {}, (err, resp) => grpcCallback(err, resp));
                  }
              },
              directives: {
                // TODO(erd): replace with vue component after naveed work done
                mapMounted (el) {
                  if (theData.mapOnce) {
                    return;
                  }
                  theData.mapOnce = true;
                  initNavigation();
                }
              },
          })

          // query metadata service every 0.5s
          const metadataCallBack = function(err, resp) {
            grpcCallback(err, resp, false)
            if (err) {
              return;
            }
            resources = resp.toObject().resourcesList
            theData.resources = resources
          }
          const queryMetadata = async function() {
            metadataService.resources(new metadataApi.ResourcesRequest(), {}, metadataCallBack);
            setTimeout(() => queryMetadata(), 500);
          }

          const streamReq = new robotApi.StatusStreamRequest();
          streamReq.setEvery((new proto.google.protobuf.Duration()).setNanos(500000000)); // 500ms

          let statusStream;
          let lastStatusTS = Date.now();
          const checkInternvalMillis = 3000;
          const checkLastStatus = function() {
            if ((Date.now() - lastStatusTS) > checkInternvalMillis) {
              restartStatusStream();
              return
            }
            setTimeout(checkLastStatus, checkInternvalMillis)
          }

          const restartStatusStream = async function() {
            if (statusStream) {
              statusStream.cancel();
              try {
                console.log("reconnecting");
                await window.reconnect();
              } catch {
                console.error("failed to reconnect; retrying");
                setTimeout(() => restartStatusStream(), 1000);
              }
            }
            statusStream = robotService.statusStream(streamReq);
            let firstData = true;
            statusStream.on('data', function(response) {
              lastStatusTS = Date.now();
              updateStatus(response.getStatus());
              if (firstData) {
                firstData = false;
                checkLastStatus();
                queryMetadata();
              }
            });
            statusStream.on('status', function(status) {
              console.log("error streaming robot status");
              console.log(status);
              console.log(status.code, " ", status.details);
            });
            statusStream.on('end', function(end) {
              console.log("done streaming robot status");
              setTimeout(() => restartStatusStream(), 1000);
            });
          }
          await restartStatusStream();

          const editor = ace.edit("source");
          editor.setTheme("ace/theme/monokai");
          editor.session.setMode("ace/mode/javascript");
          editor.resize();
          editor.setReadOnly(false);
          theData.editor = editor;
      }

      pcdGlobal = null;

      function initPCDIfNeeded() {
          if (pcdGlobal) {
              return
          }
          theData.pcdClick.enable = true;
          console.log("initing pcd");

          const sphereGeometry = new THREE.SphereGeometry( .009, 32, 32 );
          const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

          pcdGlobal = {
              scene : new THREE.Scene(),
              camera : new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 2000 ),
              renderer : new THREE.WebGLRenderer(),
              raycaster : new THREE.Raycaster(),
              sphere: new THREE.Mesh( sphereGeometry, sphereMaterial ),
          };

          pcdGlobal.renderer.setSize( window.innerWidth / 2, window.innerHeight / 2 );
          document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);

          pcdGlobal.controls = new orbitLib.OrbitControls( pcdGlobal.camera, pcdGlobal.renderer.domElement );
          pcdGlobal.camera.position.set( 0, 0, 0 );
          pcdGlobal.controls.target.set(0,0,-1);
          pcdGlobal.controls.update();
          pcdGlobal.camera.updateMatrix();

          console.log("pcd init done");
      }

      function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
                    renderer.setSize(width, height, false);
                  }
          return needResize;
        }

      function pcdAnimate() {
          if (resizeRendererToDisplaySize(pcdGlobal.renderer)) {
                    const canvas = pcdGlobal.renderer.domElement;
                    pcdGlobal.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    pcdGlobal.camera.updateProjectionMatrix();
          }
	      pcdGlobal.renderer.render( pcdGlobal.scene, pcdGlobal.camera );
          pcdGlobal.controls.update();
          requestAnimationFrame( pcdAnimate );
      }

      function pcdLoad(path) {
          var loader = new pcdLib.PCDLoader();
          loader.load(
              path,

            // called when the resource is loaded
            function ( mesh ) {
              pcdGlobal.scene.clear();
              pcdGlobal.scene.add( mesh );
              pcdGlobal.scene.add( pcdGlobal.sphere);
              if (pcdGlobal.cube) {
                pcdGlobal.scene.add(pcdGlobal.cube);
              }
              pcdAnimate();
            },
            // called when loading is in progresses
            function ( xhr ) {
              //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
              console.log(error);
            }
          );
          theData.pcdClick.pcdloaded = true;
      }

      function r(n) {
          return Math.round(n*1000);
      }

      function setPoint(point) {
          theData.pcdClick.x = r(point.x);
          theData.pcdClick.y = r(point.y);
          theData.pcdClick.z = r(point.z);
          pcdGlobal.sphere.position.copy(point);
      }

      function setBoundingBox(box, centerPoint) {
          const geometry = new THREE.BoxGeometry( box.getWidth()/1000., box.getLength()/1000., box.getDepth()/1000. );
          const edges = new THREE.EdgesGeometry( geometry );
          const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
          const cube = new THREE.LineSegments( edges, material );
          cube.position.copy(centerPoint);
          cube.name = "bounding-box";
          pcdGlobal.scene.remove(pcdGlobal.scene.getObjectByName("bounding-box"));
          pcdGlobal.cube = cube;
          pcdGlobal.scene.add(cube);
      }

      function animateForceMatrix(err, resp, anim_2D, anim_3D) {
          grpcCallback(err, resp);
          if (err) {
            console.log("error getting force sensor readings: ", err);
            return;
          }
          var [rows, cols, data] = resp.getMatrix().array;
          if (data.length !== rows * cols) {
            console.log("corrupt force sensor data");
            return;
          }

          // 3D animation stuff: If this is the first time we're receiving data,
          // let's add cubes to the 3D view
          if (anim_3D.cubes.length == 0) {
              console.log("Initializing cubes array")
              for (let i = 0; i < rows; i++) {
                  cubeRow = []
                  for (let j = 0; j < cols; j++) {
                      const geometry = new THREE.BoxGeometry(1, 1, 0.1);
                      const material = new THREE.MeshBasicMaterial( { color: 0xffaebc} );
                      const cube = new THREE.Mesh( geometry, material );
                      cube.translateX(i * 1.1 - rows / 2);
                      cube.translateY(- j * 1.1 + cols / 2);
                      cubeRow.push(cube);
                      anim_3D.scene.add(cube);
                  }
                  anim_3D.cubes.push(cubeRow)
              }
          }
          const offset = 100;
          let canvas2D = document.getElementById(anim_2D.canvasId);
          let canvasHeight = (50 * rows) + 20;
          let canvasWidth = 150 * cols + offset;
          let currentHeight = canvas2D.height;
          let currentWidth = canvas2D.width;
          if ((canvasHeight !== currentHeight) || (canvasWidth !== currentWidth)) {
            canvas2D.height = canvasHeight;
            canvas2D.width = canvasWidth;
          }


          // TODO: The placing & sizing of everything that's displayed is hardcoded
          // e.g. the canvas size, location of boxes, etc.
          // To allow for any size of sensor, and to use the space on the screen
          // more efficiently (plus make a mobile version available), changing to
          // adaptive sizing would be great.
          const gradientRate = 10;
          const gradientHeight = 20;
          const spaceBetweenTextAndGradient = 35;
          for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
              let value = data[i * cols + j];
              if (value > anim_2D.maxValue) {
                  anim_2D.maxValue = value
              }

              greenShade = 255/anim_2D.maxValue * value;
              // --- 2D animation stuff ---
              anim_2D.ctx.fillStyle = 'rgb(0, ' + greenShade + ', 0)'; // old version with just green color
              anim_2D.ctx.fillRect(offset + i * anim_2D.squareWidth, j * anim_2D.squareWidth, anim_2D.squareWidth, anim_2D.squareWidth);

              // Write out raw values
              anim_2D.ctx.fillStyle = 'white'
              anim_2D.ctx.font = '20px sans-serif';
              anim_2D.ctx.fillText(value, offset + i * anim_2D.squareWidth, (j+0.6) * anim_2D.squareWidth);

              // Add gradient to the left of 2D animation stuff
              for (let g = 0; g < gradientRate; g++) {
                // Create colored boxes
                let greenShade = 255/gradientRate * g;
                anim_2D.ctx.fillStyle = 'rgb(0, ' + greenShade + ', 0)'; // old version with just green color
                anim_2D.ctx.fillRect(spaceBetweenTextAndGradient, g * gradientHeight, 40, gradientHeight);

                // Label the boxes
                anim_2D.ctx.fillStyle = 'white';
                anim_2D.ctx.fillRect(0, g * gradientHeight, spaceBetweenTextAndGradient, gradientHeight);
                anim_2D.ctx.fillStyle = 'black'
                anim_2D.ctx.font = '15px sans-serif';
                anim_2D.ctx.fillText(Math.floor(anim_2D.maxValue/(gradientRate - 1) * g) ,0, gradientHeight * (g + 1));
              }

              // Write the out separately in black so it's easy to read
              anim_2D.ctx.fillStyle = 'white'
              anim_2D.ctx.fillRect(offset + (i + 2) * anim_2D.squareWidth + 300, j * anim_2D.squareWidth, anim_2D.squareWidth, anim_2D.squareWidth);
              anim_2D.ctx.fillStyle = 'black'
              anim_2D.ctx.font = '20px sans-serif';
              anim_2D.ctx.strokeRect(offset + (i + 2) * anim_2D.squareWidth + 300, j * anim_2D.squareWidth, anim_2D.squareWidth, anim_2D.squareWidth);
              anim_2D.ctx.fillText(value, offset + (i + 2) * anim_2D.squareWidth + 300, (j+0.6) * anim_2D.squareWidth);

              // --- 3D animation stuff ---
              anim_3D.cubes[i][j].material.color.setRGB(0, greenShade/255, 0)
              anim_3D.cubes[i][j].scale.setZ(value / anim_2D.maxValue * 14)
              anim_3D.cubes[i][j].position.setZ(0)
              anim_3D.cubes[i][j].translateZ(value/anim_2D.maxValue * 7 * 0.1)
            }
          }
      }

      function updateSlipDetectionResult (err, resp, id) {
        grpcCallback(err, resp);
        if (err) {
          console.log("error getting slip detection readings: ", err);
          return;
        }
        let isSlipping = resp.getIsSlipping()
        let dispEl = document.getElementById("force-is-slipping-" + id);
        if (isSlipping) {
          dispEl.innerText = "SLIPPING";
        } else {
          dispEl.innerText = "NOT SLIPPING";
        }
      }

      async function waitForClientAndStart() {
        console.debug("waiting for robot service to be ready");
        await window.robotServiceReady;
        console.debug("ready");
        await startup();
      }

      async function initNavigation() {
        await mapReady;
        window.map = new google.maps.Map(document.getElementById("map"), {zoom: 18});
        window.map.addListener("click", (e) => {
          var req = new robotApi.NavigationServiceAddWaypointRequest();
          var point = new robotApi.GeoPoint();
          point.setLatitude(e.latLng.lat());
          point.setLongitude(e.latLng.lng());
          req.setLocation(point);
          robotService.navigationServiceAddWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
        });

        let centered = false;
        const knownWaypoints = {};
        let localLabelCounter = 0;
        const updateWaypoints = function() {
          var req = new robotApi.NavigationServiceWaypointsRequest();
          robotService.navigationServiceWaypoints(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateWaypoints, 1000);
              return;
            }
            let waypoints = [];
            if (resp) {
              waypoints = resp.getWaypointsList();
            }
            const currentWaypoints = {};
            for (var i = 0; i < waypoints.length; i++) {
              const waypoint = waypoints[i];
              const pos = {lat: waypoint.getLocation().getLatitude(), lng: waypoint.getLocation().getLongitude()};
              const posStr = JSON.stringify(pos);
              if (knownWaypoints[posStr]) {
                currentWaypoints[posStr] = knownWaypoints[posStr];
                continue;
              }
              const marker = new google.maps.Marker({
                position: pos,
                map: window.map,
                label: `${localLabelCounter++}`,
              });
              currentWaypoints[posStr] = marker;
              knownWaypoints[posStr] = marker;
              marker.addListener("click", () => {
                console.log("clicked on marker", pos)
              });
              marker.addListener("dblclick", () => {
                var req = new robotApi.NavigationServiceRemoveWaypointRequest();
                req.setId(waypoint.getId());
                robotService.navigationServiceRemoveWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
              });
            }
            const waypointsToDelete = Object.keys(knownWaypoints).filter(elem => {
              return !(elem in currentWaypoints)
            });
            for (key of waypointsToDelete) {
              const marker = knownWaypoints[key];
              marker.setMap(null);
              delete knownWaypoints[key];
            }
            setTimeout(updateWaypoints, 1000);
          });
        }
        updateWaypoints();

        const locationMarker = new google.maps.Marker({label: "robot"});
        const updateLocation = function() {
          var req = new robotApi.NavigationServiceLocationRequest();
          robotService.navigationServiceLocation(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateLocation, 1000);
              return;
            }
            const pos = {lat: resp.getLocation().getLatitude(), lng: resp.getLocation().getLongitude()};
            if (!centered) {
              centered = true;
              window.map.setCenter(pos);
            }
            locationMarker.setPosition(pos);
            locationMarker.setMap(window.map);
            setTimeout(updateLocation, 1000);
          });
        }
        updateLocation();
      }

      function initMap() {
        mapReadyResolve();
      }

      let mapReadyResolve;
      let mapReady = new Promise(resolve => {
        mapReadyResolve = resolve;
      });
    </script>
  </head>
  <body onLoad="waitForClientAndStart()" style="background: var(--black-10);">
    <div id="app">
      <div id="actions">
        {{range $r := .Actions}}
        <button v-on:click="doAction('{{$r}}')">{{$r}}</button>
        {{end}}
      </div>

      <div style="color: red">${ error }</div>

      <!-- ******* BASE *******  -->
      <div class="base" v-for="base in status.basesMap" :key="base[0]">
        <h3>${base[0]}</h3>
        <ul>
          <li><button v-on:click="baseAction(base[0], 'straight', 1)">Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'straight', -1)">Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'arc', 1)">Arc Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'arc', -1)">Arc Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', 1)">Spin Clockwise</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', -1)">Spin Counterclockwise</button></li>
        </ul>

        Speed (mm per sec): <input id="speed" name="speed" value="300"/><br>
        Distances (mm): <input id="distance" name="distance" value="500"/><br>
        Angle (degree): <input id="angle" name="angle" value="0"/><br>
      </div>

      <!-- ******* GANTRY *******  -->
      <div class="gantry" v-for="gantry in filterResources('core', 'component', 'gantry')" :key="gantry.name">
        <h3>Gantry ${gantry.name}</h3>
        <table>
          <tr>
            <th>axis</th>
            <th>position</th>
            <th>length</th>
          </tr>
          <tr v-for="pp in gantryByName(gantry.name).parts" :key="pp.axis">
            <th>${pp.axis}</th>
            <td>
              <button v-on:click="gantryInc( gantry.name, pp.axis, -.1 )">--</button>
              <button v-on:click="gantryInc( gantry.name, pp.axis, -.01 )">-</button>
              <button v-on:click="gantryInc( gantry.name, pp.axis, .01 )">+</button>
              <button v-on:click="gantryInc( gantry.name, pp.axis, .1 )">++</button>
            </td>
            <td>${pp.pos}</td>
            <td>${pp.length}</td>
          </tr>
        </table>
      </div>
      
      <!-- ******* ARM *******  -->
      <div class="arm" v-for="arm in filterResources('core', 'component', 'arm')" :key="arm.name">
        <h3>Arm ${arm.name}</h3>
        <table v-if="armToggle[arm.name]" border="1">
          <tr>
            <th colspan="2"><h5>GRID (mms)</h5></th>
            <th colspan="2"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armToggle[arm.name].pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td><input v-model="aa.gridValue"></td>

            <th>Joint ${aa.joint}</th>
            <td><input v-model="aa.jointValue"></td>
          </tr>
          <tr>
            <th colspan="6">
              <button v-on:click="armModifyAllDoGrid(arm.name)">Go To Grid</button>
              <button v-on:click="armModifyAllDoJoint(arm.name)">Go To Joints</button>
              <button v-on:click="armModifyAllCancel(arm.name)">Cancel</button>
            </th>
          </tr>
        </table>
        <table border="1" v-else>
          <tr>
            <th colspan="3"><h5>GRID (mms)</h5></th>
            <th colspan="3"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armByName(arm.name).pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -10 )">--</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -1 )">-</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 1 )">+</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 10 )">++</button>
            </td>
            <td>${aa.gridValue.toFixed(2)}</td>

            <th>Joint ${aa.joint}</th>
            <td>
              <button v-on:click="armJointInc( arm.name, aa.joint, -10 )">--</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, -1 )">-</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 1 )">+</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 10 )">++</button>
            </td>
            <td>${aa.jointValue.toFixed(2)}</td>
          </tr>
          <tr>
            <th colspan="8">
              <button v-on:click="armHome(arm.name)">Home</button>
              <button v-on:click="armModifyAll(arm.name)">Modify All</button>
            </th>
          </tr>
        </table> <!-- end main table -->
      </div>

      <!-- ******* GRIPPER *******  -->
      <div class="gripper" v-for="gripper in status.grippersMap" :key="gripper[0]">
        <h3>Gripper ${ gripper[0] }</h3>
        <ul>
          <li><button v-on:click="gripperAction( gripper[0], 'open')">Open</button></li>
          <li><button v-on:click="gripperAction( gripper[0], 'grab')">Grab</button></li>
        </ul>
      </div>

      <!-- ******* SERVO *******  -->
      <div class="servo" v-for="servo in status.servosMap" :key="servo[0]" style="margin-bottom: 64px;">
        <h3>Servo ${ servo[0] }</h3>
        <table border="1">
          <tr><th>Angle</th><td>${servo[1].angle}</td></tr>
          <tr>
            <td></td>
            <td>
              <button v-on:click="servoMove(servo[0], -10)">-10</button>
              <button v-on:click="servoMove(servo[0], -1)">-1</button>
              <button v-on:click="servoMove(servo[0], 1)">1</button>
              <button v-on:click="servoMove(servo[0], 10)">10</button>
            </td>
          </tr>
        </table>
      </div>

      <!-- ******* MOTOR *******  -->
      <motor-detail
        v-for="motor in status.motorsMap"
        :key="'new-' + motor[0]"
        v-bind:motor-name="motor[0]"
        v-bind:motor-status="motor[1]"
        v-on:execute="motorCommand(motor[0], $event)"
        v-on:pid="pidCommand(motor[0],$event)"
        style="max-width: 1080px;">
      </motor-detail>

      <!-- ******* INPUT VIEW *******  -->
      <input-controller
        v-for="controller in status.inputControllersMap"
        :key="'new-' + controller[0]"
        v-bind:controller-name="controller[0]"
        v-bind:controller-status="controller[1]"
        style="max-width: 1080px;">
      </input-controller>

      <!-- ******* WEB CONTROLS *******  -->
      <web-gamepad
        v-if="status.webGamepad"
        v-on:execute="inputInject($event)"
        style="max-width: 1080px;">
      </web-gamepad>

      <!-- ******* CAMERAS *******  -->
      <table>
        <tr>
          <td><img id="i0" src=""/></td>
          <td><img id="i1" src=""/></td>
          {{ range $view := .Views }}
          <td>
            {{ htmlSafe $view.Body }}
          </td>
          {{ end }}
        </tr>
      </table>

      <!-- ******* BOARD *******  -->

      <div class="board" v-for="(board, boardIndex) in status.boardsMap" :key="board[0]">
        <h3>Board ${board[0]}</h3>
        <table border="1">

          <tr><th colspan="2">Analogs</th></tr>
          <tr v-for="a in board[1].analogsMap" :key="a[0]">
            <th>${a[0]}</th>
            <td>${a[1].value}</td>
          </tr>

          <tr><th colspan="2">DigitalInterrupts</th></tr>
          <tr v-for="di in board[1].digitalInterruptsMap" :key="di[0]">
            <th>${di[0]}</th>
            <td>${di[1].value}</td>
          </tr>
        </table>
      </div> <!-- end boards -->
      <!-- cameras -->
      <table border="1" v-if="nonEmpty(status.camerasMap)">
        <tr>
          <th colspan="3">
            Cameras
          </th>
        </tr>
        <tr>
          <th>Name</th>
          <th>Frame</th>
          <th>PCD</th>
        </tr>
        <tr v-for="(cam,x) in status.camerasMap">
          <td>${cam[0]}</td>
          <td><a href="#" v-on:click.prevent="renderFrame(cam[0])">frame</a></td>
          <td><button v-on:click="renderPCD(cam[0])">GO</button></td>
        </tr>
      </table>

      <table border=1 v-if="nonEmpty(status.sensorsMap)">
        <tr>
          <th colspan="2">Sensors</th>
        </tr>

        <tr>
          <th>Name</th>
          <th>Type</th>
        </tr>

        <tr v-for="(sensor, x) in status.sensorsMap">
          <td>${sensor[0]}</td>
          <td>${sensor[1].type}</td>
          <td>
            <template v-if="sensor[1].type === 'forcematrix'">
              <button :id="'force-button-id-' + x" v-on:click="visualizeForceMatrix(sensor[0], sensor[1].type, x)">Visualize Force Matrix</button>
              <!-- canvas element is resized later upon arrival of sensor data (see animateForceMatrix)  -->
              <canvas :id="'force-2d-id-' + x" width="1000" height="300" style="margin-top: 20px;"></canvas>
              <div :id="'force-3d-id-' + x"></div>
              <div :id="'force-is-slipping-' + x">NO VALUE</div>
            </template>
            <button v-else v-on:click="doSensorReadings(sensor[0])">Get Readings</button>
          </td>
        </tr>
      </table>

      <div>${res}</div>
      <div>
        <h3>Functions</h3>
        <div id="named_functions" v-if="nonEmpty(status.functionsMap)">
          <h4>Named</h4>
          <div v-for="(func, x) in status.functionsMap">
            <button v-on:click="executeFunction(func[0])">${func[0]}</button>
          </div>
        </div>
        <h4>Evaluate</h4>
        <div id="source">console.log("hello world")</div>
        <br/>
        <button v-on:click="evalSource()">Run</button>
        <br/>
        <textarea disabled id="function_results" rows="10" cols="80"></textarea>
      </div>

      <div id="pcd_wrapper">
        <table>
          <tr>
            <td><div id="pcd" v-on:click="grabClick"/></td>
            <td v-if="pcdClick.enable">
              <table>
                <tr>
                  <th colspan=2>
                    Clicked On
                  </th>
                </tr>
                <tr>
                  <th>X</th>
                  <td>${pcdClick.x}</td>
                </tr>
                <tr>
                  <th>Y</th>
                  <td>${pcdClick.y}</td>
                </tr>
                <tr>
                  <th>Z</th>
                  <td>${pcdClick.z}</td>
                </tr>
                <tr>
                  <td colspan=2>
                    <button v-on:click="doPCDGrab">Grab</button>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>
      </div> <!-- end pcd wrapper -->
      <!-- get segments -->
      <table v-if="pcdClick.pcdloaded">
        <tr>
          <td colspan=2>
              Min Pts in Plane: <input type="number" id="minPtsPlane" min="0"  v-model="minPtsPlane"><br>
              Min Pts in Segment: <input type="number" id="minPtsSegment" min="0" v-model="minPtsSegment"><br>
              Clustering Radius (mm): <input type="number" id="clusterRad" min="0" v-model="clusterRad"><br>
          </td>
        </tr>
        <tr>
            <td>
                <button v-on:click="findSegments(minPtsPlane, minPtsSegment, clusterRad)">Find Segments</button>
            </td>
            <td v-if="pcdClick.calculatingSegments">Finding...</td>
        </tr>
      </table>
      <table v-if="pcdClick.foundSegments">
        <tr>
          <th>Object</th>
          <th>PCD</th>
          <th>Point</th>
          <th>Bounding Box</th>
        </tr>
        <tr>
          <td>Full Image</td>
          <td><button v-on:click="doPCDLoad(fullcloud)">GO</button></td>
          <td>--</td>
        </tr>
        <tr v-for="(seg, i) in segments">
            <td>Object ${i}</td>
            <td><button v-on:click="doSegmentLoad(seg, i)">GO</button></td>
            <td><button v-on:click="doPointLoad(i)">GO</button></td>
            <td><button v-on:click="doBoundingBoxLoad(i)">GO</button></td>
        </tr>
      </table>
      <div id="map-container" v-if="hasKey(status.servicesMap, 'navigation')">
        <br />
        <br />
        <button v-on:click="setNavigationMode('manual')">Manual</button>
        <button v-on:click="setNavigationMode('waypoint')">Waypoint</button>
        <br />
        <input type="text" id="nav-set-location" value="40.745297,-74.010916">
        <button v-on:click="setNavigationLocation('nav-set-location')">Try Set Location</button>
        <div id="map" v-map-mounted></div>
      </div>
    </div> <!-- end vue app -->

    <!-- TODO(https://github.com/viamrobotics/core/issues/202): remove api key once going into production -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBn72TEqFOVWoj06cvua0Dc0pz2uvq90nY&callback=initMap&libraries=&v=weekly"
      async
    ></script>
  </body>
</html>
