<html>
  <head>
    <style type="text/css" media="screen">
      #source {
        position: relative;
        width: 50%;
        height: 50%;
      }
    </style>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
    <script>
      window.webrtcEnabled = {{ .WebRTCEnabled }}
      window.webrtcHost = {{ .WebRTCHost }}
      window.webrtcSignalingAddress = {{ .WebRTCSignalingAddress }}
    </script>
    {{ if .External }}
    <script src="/static/core/control.js"></script>
    <script src="/static/core/third-party/vue.js"></script>
    <script src="/static/core/third-party/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    {{ else }}
    <script src="/static/control.js"></script>
    <script src="/static/third-party/vue.js"></script>
    <script src="/static/third-party/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    {{ end }}

    <script>
      function roundTo2Decimals(num) {
          num = Math.round(num * 100);
          return num / 100;
      }
      
      function grpcCallback(err, resp, stringify) {
        if (err) {
          theData.error = JSON.stringify(err);
          return;
        }
        if (stringify === undefined || stringify) {
          try {
            theData.res = JSON.stringify(resp.toObject());
          } catch (e) {
            theData.error = JSON.stringify(e);
          }
        }
      }

      {{ range $view := .Views }}
        {{ jsSafe $view.JavaScript }}
      {{ end }}

      function fixArms(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              const [armName, armValue] = old[i];
              var newArm = { name : armName, pieces : [] };

              var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["theta", "Theta"], ["oX", "OX"], ["oY", "OY"], ["oZ", "OZ"]];
              for (var j=0; j<fieldSetters.length; j++ ){
                  let gridField = fieldSetters[j][0].split(".");
                  let gridValue = armValue.gridPosition[gridField[0]];
                  for (let k = 1; k < gridField.length; k++) {
                    gridValue = gridValue[gridField[k]];
                  }
                  newArm.pieces.push( { grid : fieldSetters[j],
                                        joint : j,
                                        gridValue : gridValue,
                                        jointValue : armValue.jointPositions.degreesList[j] || 0,
                                      });
              }
              
              n.push(newArm);
          }
          return n;
      }

      firstResult = false;
      
      async function updateStatus(rawStatus) {
          theData.rawStatus = rawStatus;
          window.rawStatus = rawStatus;
          // toObject gives annoying suffixes; see https://github.com/protocolbuffers/protobuf/issues/6773
          const rawSatusObj = rawStatus.toObject();

          var status = {}

          // make vue friendly
          status.armsMap = rawSatusObj.armsMap;
          status.basesMap = rawSatusObj.basesMap;
          status.grippersMap = rawSatusObj.grippersMap;
          status.boardsMap = rawSatusObj.boardsMap;
          status.camerasMap = rawSatusObj.camerasMap;
          status.sensorsMap = rawSatusObj.sensorsMap;
          status.servosMap = rawSatusObj.servosMap;
          status.motorsMap = rawSatusObj.motorsMap;
          status.functionsMap = rawSatusObj.functionsMap;

          status.armsMap = fixArms(status.armsMap);

          if (!firstResult) {
            console.log(rawSatusObj);
            console.log(status);
            firstResult = true;
          }

          theData.status = status;
      }
      
      async function startup() {
          theData = {
              error : "",
              res : {},
              rawStatus : null,
              status : {},
              pcdClick : {},
              fullcloud: null,
              segments : null,
              segCenters : null,
              minPtsPlane : 10000,
              minPtsSegment: 100,
              clusterRad: 5,
              armToggle : {},
              editor: undefined,
          };
          theApp = new Vue({
              el: '#app',
              delimiters: ['${', '}'],
              data: theData,
              methods : {
                  armGridInc : function(name, getterSetter, amount) {
                      if (getterSetter[0] == 'o' || getterSetter[0] == 'O') {
                          amount /= 100;
                      }
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();
                      var newPosition = Object.assign(Object.create(robotApi.ArmPosition.prototype), old);
                      const getter = `get${getterSetter}`;
                      const setter = `set${getterSetter}`;
                      newPosition[setter](newPosition[getter]() + amount);
                      const req = new robotApi.ArmMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armJointInc : function(name, field, amount) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      newList[field] += amount;
                      newPosition.setDegreesList(newList);
                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armHome : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      for (var i = 0; i < newList.length; i++) {
                        newList[i] = 0;
                      }
                      newPosition.setDegreesList(newList);
                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armModifyAll : function(name, arm) {
                      var n = { name : name, pieces : [] };

                      for ( var i=0; i < arm.pieces.length; i++) {
                          n.pieces.push( {
                              grid : arm.pieces[i].grid,
                              gridValue : roundTo2Decimals(arm.pieces[i].gridValue),
                              joint : arm.pieces[i].joint,
                              jointValue : roundTo2Decimals(arm.pieces[i].jointValue),
                          });
                              
                      }
                      
                      theData.armToggle[name] = n;
                  },
                  armModifyAllCancel : function(name, arm) {
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoGrid : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();
                      
                      var newPosition = Object.assign(Object.create(robotApi.ArmPosition.prototype), old);
                      var newPieces = theData.armToggle[name].pieces;
                      
                      for (var i=0; i < newPieces.length; i++) {
                          var getterSetter = newPieces[i].grid[1];
                          const getter = `get${getterSetter}`;
                          const setter = `set${getterSetter}`;
                          newPosition[setter](newPieces[i].gridValue);
                      }

                      const req = new robotApi.ArmMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoJoint : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();

                      var newPieces = theData.armToggle[name].pieces;
                      for (var i=0; i < newPieces.length && i < newList.length; i++) {
                          newList[newPieces[i].joint] = newPieces[i].jointValue;
                      }
                      
                      newPosition.setDegreesList(newList);

                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },
                  
                  gripperAction : function(name, action) {
                      let req;
                      switch (action) {
                        case 'open':
                          req = new robotApi.GripperOpenRequest();
                          req.setName(name);
                          robotService.gripperOpen(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'grab':
                          req = new robotApi.GripperGrabRequest();
                          req.setName(name);
                          robotService.gripperGrab(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  servoMove : function(name, amount) {
                      const servo = theData.rawStatus.getServosMap().get(name);
                      var old = servo.getAngle();
                      var angle = old + amount;
                      const req = new robotApi.ServoMoveRequest();
                      req.setName(name);
                      req.setAngleDeg(angle);
                      robotService.servoMove(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorButton: function(name, cmd) {
                      let req;
                      if (cmd.r) {
                        req = new robotApi.MotorGoForRequest();
                        req.setRevolutions(cmd.r);
                        if (cmd.s) {
                          req.setRpm(cmd.s);
                        }
                      } else {
                        req = new robotApi.MotorGoRequest();
                        if (cmd.s) {
                            req.setPowerPct(cmd.s);
                        }
                      }
                      req.setName(name);
                      switch (cmd.d) {
                        case 'backward':
                          req.setDirection(robotApi.DirectionRelative.DIRECTION_RELATIVE_BACKWARD);
                          break;
                        case 'forward':
                          req.setDirection(robotApi.DirectionRelative.DIRECTION_RELATIVE_FORWARD);
                          break;
                      }
                      if (cmd.r) {
                        robotService.motorGoFor(req, {}, (err, resp) => grpcCallback(err, resp));
                      } else {
                        robotService.motorGo(req, {}, (err, resp) => grpcCallback(err, resp));
                      }
                  },
                  doAction : function(name) {
                      const req = new robotApi.DoActionRequest();
                      req.setName(name);
                      robotService.doAction(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  baseAction : function(name, action, amount) {
                      let req;
                      switch (action) {
                        case 'straight':
                          req = new robotApi.BaseMoveStraightRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          robotService.baseMoveStraight(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'angle':
                          req = new robotApi.BaseSpinRequest();
                          req.setName(name);
                          req.setDegsPerSec(document.getElementById("speed").value)
                          req.setAngleDeg(amount);
                          robotService.baseSpin(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  renderFrame : function(cameraName) {
                      req = new robotApi.CameraFrameRequest();
                      req.setName(cameraName);
                      const mimeType = 'image/png';
                      req.setMimeType(mimeType)
                      robotService.cameraFrame(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        let blob = new Blob([resp.getFrame_asU8()], { type: mimeType });
                        window.open(URL.createObjectURL(blob), "_blank");
                      });
                  },
                  renderPCD : function(cameraName) {
                      theData.pcdClick.pcdloaded = false;
                      theData.pcdClick.foundSegments = false;
                      initPCDIfNeeded();
                      pcdGlobal.cameraName = cameraName;

                      req = new robotApi.PointCloudRequest();
                      req.setName(cameraName);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType)
                      robotService.pointCloud(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        console.log("loading pcd");
                        theData.fullcloud = resp.getFrame_asB64();
                        pcdLoad(`data:${mimeType};base64,${theData.fullcloud}`);
                      });

                  },
                  doSensorReadings : function(name) {
                      var req = new robotApi.SensorReadingsRequest();
                      req.setName(name);
                      robotService.sensorReadings(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  processFunctionResults: function(err, resp) {
                    grpcCallback(err, resp, false)
                    if (err) {
                      document.getElementById("function_results").value = `${err}`;
                      return;
                    }
                    var results = resp.getResultsList();

                    let resultStr = '';
                    if (results.length > 0) {
                      resultStr += 'Results: \n';
                      for (let i = 0; i < results.length && i < results.length; i++) {
                        let result = results[i];
                        resultStr += `${i}: ${JSON.stringify(result.toJavaScript())}\n`;
                      }
                    }
                    resultStr += `StdOut: ${resp.getStdOut()}\n`;
                    resultStr += `StdErr: ${resp.getStdErr()}\n`;
                    document.getElementById("function_results").value = resultStr;
                  },
                  executeFunction : function(name) {
                      document.getElementById("function_results").value = "";
                      var req = new robotApi.ExecuteFunctionRequest();
                      req.setName(name);
                      robotService.executeFunction(req, {}, this.processFunctionResults);
                  },
                  evalSource : function() {
                      document.getElementById("function_results").value = "";
                      var req = new robotApi.ExecuteSourceRequest();
                      req.setSource(theData.editor.getValue());
                      req.setEngine('javascript');
                      robotService.executeSource(req, {}, this.processFunctionResults);
                  },
                  nonEmpty : function(d) {
                      for ( var k in d ) {
                          return true;
                      }
                      return false;
                  },
                  grabClick : function(e) {
                      var mouse = new THREE.Vector2();
                      mouse.x = ((e.offsetX / e.srcElement.offsetWidth) * 2) - 1
                      mouse.y = ((e.offsetY / e.srcElement.offsetHeight) * -2) + 1
                      
	                  pcdGlobal.raycaster.setFromCamera( mouse, pcdGlobal.camera );
                      
	                  var intersects = pcdGlobal.raycaster.intersectObjects( pcdGlobal.scene.children );
                      var p = ( intersects.length ) > 0 ? intersects[ 0 ] : null;

                      if ( p !== null ) {
                        console.log(p.point);
                        setPoint(p.point);
                      } else {
                        console.log("no point intersected");
                      }

                  },
                  doPCDGrab : function(){
                      console.log(theData.pcdClick.path);
                      fetch(theData.pcdClick.path).then(console.log);
                  },
                  findSegments : function(minPointsPlane, minPointsSegment, clusteringRadius){
                      theData.pcdClick.calculatingSegments = true;
                      req = new robotApi.ObjectPointCloudsRequest();
                      console.log("camera name: "+pcdGlobal.cameraName);
                      req.setName(pcdGlobal.cameraName);
                      req.setMinPointsInPlane(minPointsPlane);
                      req.setMinPointsInSegment(minPointsSegment);
                      req.setClusteringRadius(clusteringRadius);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType);
                      console.log("finding object segments...");
                      robotService.objectPointClouds(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          console.log("error getting segments");
                          theData.pcdClick.calculatingSegments = false;
                          return;
                        }
                        console.log("got pcd segments");
                        theData.pcdClick.foundSegments = true;
                        theData.segments = resp.getFramesList_asB64();
                        theData.segCenters = resp.getCentersList();
                        theData.pcdClick.calculatingSegments = false;
                      });
                  },
                  doSegmentLoad : function(data, i){
                        var center = theData.segCenters[i];
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  doPointLoad : function(i){
                        var center = theData.segCenters[i];
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                  },
                  doPCDLoad : function(data){
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  }
              }
          })

          const streamReq = new robotApi.StatusStreamRequest();
          streamReq.setEvery((new proto.google.protobuf.Duration()).setNanos(500000000)); // 500ms

          let statusStream;
          let lastStatusTS = Date.now();
          const checkInternvalMillis = 3000;
          const checkLastStatus = function() {
            if ((Date.now() - lastStatusTS) > checkInternvalMillis) {
              restartStatusStream();
              return
            }
            setTimeout(checkLastStatus, checkInternvalMillis)
          }

          const restartStatusStream = async function() {
            if (statusStream) {
              statusStream.cancel();
              try {
                console.log("reconnecting");
                await window.reconnect();
              } catch {
                console.error("failed to reconnect; retrying");
                setTimeout(() => restartStatusStream(), 1000);  
              }
            }
            statusStream = robotService.statusStream(streamReq);
            let firstData = true;
            statusStream.on('data', function(response) {
              lastStatusTS = Date.now();
              updateStatus(response.getStatus());
              if (firstData) {
                firstData = false;
                checkLastStatus();
              }
            });
            statusStream.on('status', function(status) {
              console.log("error streaming robot status");
              console.log(status);
              console.log(status.code, " ", status.details);
            });
            statusStream.on('end', function(end) {
              console.log("done streaming robot status");
              setTimeout(() => restartStatusStream(), 1000);
            });
          }
          await restartStatusStream();

          const editor = ace.edit("source");
          editor.setTheme("ace/theme/monokai");
          editor.session.setMode("ace/mode/javascript");
          editor.resize();
          editor.setReadOnly(false);
          theData.editor = editor;
      }

      pcdGlobal = null;
      
      function initPCDIfNeeded() {
          if (pcdGlobal) {
              return
          }
          theData.pcdClick.enable = true;
          console.log("initing pcd");
          
          const sphereGeometry = new THREE.SphereGeometry( .009, 32, 32 );
          const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

          pcdGlobal = {
              scene : new THREE.Scene(),
              camera : new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 2000 ),
              renderer : new THREE.WebGLRenderer(),
              raycaster : new THREE.Raycaster(),
              sphere: new THREE.Mesh( sphereGeometry, sphereMaterial ),
          };

          pcdGlobal.renderer.setSize( window.innerWidth / 2, window.innerHeight / 2 );
          document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);
          
          pcdGlobal.controls = new orbitLib.OrbitControls( pcdGlobal.camera, pcdGlobal.renderer.domElement );
          pcdGlobal.camera.position.set( 0, 0, 0 );
          pcdGlobal.controls.target.set(0,0,-1);
          pcdGlobal.controls.update();
          pcdGlobal.camera.updateMatrix();

          console.log("pcd init done");
      }

      function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
                    renderer.setSize(width, height, false);
                  }
          return needResize;
        }

      function pcdAnimate() {
          if (resizeRendererToDisplaySize(pcdGlobal.renderer)) {
                    const canvas = pcdGlobal.renderer.domElement;
                    pcdGlobal.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    pcdGlobal.camera.updateProjectionMatrix();
          }
	      pcdGlobal.renderer.render( pcdGlobal.scene, pcdGlobal.camera );
          pcdGlobal.controls.update();
          requestAnimationFrame( pcdAnimate );
      }

      function pcdLoad(path) {
          var loader = new pcdLib.PCDLoader();
          loader.load(
              path,
              
            // called when the resource is loaded
            function ( mesh ) {
              pcdGlobal.scene.clear();
              pcdGlobal.scene.add( mesh );
              pcdGlobal.scene.add( pcdGlobal.sphere);
              pcdAnimate();
            },
            // called when loading is in progresses
            function ( xhr ) {
              //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
              console.log(error);
            }
          );
          theData.pcdClick.pcdloaded = true;
      }

      function r(n) {
          return Math.round(n*1000);
      }

      function setPoint(point) {
          var path = "/grab_at_camera_position/"
              + pcdGlobal.cameraName + "/"
              + r(point.x) + "/" + r(point.y) + "/" + r(point.z);

          theData.pcdClick.x = r(point.x);
          theData.pcdClick.y = r(point.y);
          theData.pcdClick.z = r(point.z);
          theData.pcdClick.path = path;
          pcdGlobal.sphere.position.copy(point);
      }

      async function waitForClientAndStart() {
        console.debug("waiting for robot service to be ready");
        await window.robotServiceReady;
        console.debug("ready");
        await startup();
      }
      
    </script>
  </head>
  <body onLoad="waitForClientAndStart()">
    <div id="app">
      <div id="actions">
        {{range $r := .Actions}}
        <button v-on:click="doAction('{{$r}}')">{{$r}}</button>
        {{end}}
      </div>   

      <div style="font-color: red">${ error }</div>

      <!-- ******* BASE *******  -->
      <div class="base" v-for="base in status.basesMap" :key="base[0]">
        <h3>${base[0]}</h3>
        <ul>
          <li><button v-on:click="baseAction(base[0], 'straight', 1)">Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'straight', -1)">Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', 15)">Spin Clockwise</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', -15)">Spin Counterclockwise</button></li>
        </ul>
        
        Speed (mm per sec): <input id="speed" name="speed" value="300"/><br>
        Distances (mm): <input id="distance" name="speed" value="500"/><br>
      </div>

      <!-- ******* ARM *******  -->
      <div class="arm" v-for="arm in status.armsMap" :key="arm.name">
        <h3>Arm ${arm.name}</h3>
        <table v-if="armToggle[arm.name]" border="1">
          <tr>
            <th colspan="2"><h5>GRID (mms)</h5></th>
            <th colspan="2"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armToggle[arm.name].pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td><input v-model="aa.gridValue"></td>

            <th>Joint ${aa.joint}</th>
            <td><input v-model="aa.jointValue"></td>
          </tr>
          <tr>
            <th colspan="6">
              <button v-on:click="armModifyAllDoGrid(arm.name, arm)">Go To Grid</button>
              <button v-on:click="armModifyAllDoJoint(arm.name, arm)">Go To Joints</button>
              <button v-on:click="armModifyAllCancel(arm.name, arm)">Cancel</button>
            </th>
          </tr>
        </table>
        <table border="1" v-else>
          <tr>
            <th colspan="3"><h5>GRID (mms)</h5></th>
            <th colspan="3"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in arm.pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -10 )">--</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -1 )">-</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 1 )">+</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 10 )">++</button>
            </td>
            <td>${aa.gridValue.toFixed(2)}</td>

            <th>Joint ${aa.joint}</th>
            <td>
              <button v-on:click="armJointInc( arm.name, aa.joint, -10 )">--</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, -1 )">-</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 1 )">+</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 10 )">++</button>
            </td>
            <td>${aa.jointValue.toFixed(2)}</td>
          </tr>
          <tr>
            <th colspan="8"> 
              <button v-on:click="armHome( arm.name)">Home</button>
              <button v-on:click="armModifyAll(arm.name, arm)">Modify All</button>
            </th>
          </tr>
        </table> <!-- end main table -->
      </div> 
      
      <!-- ******* GRIPPER *******  -->
      <div class="gripper" v-for="gripper in status.grippersMap" :key="gripper[0]">
        <h3>Gripper ${ gripper[0] }</h3>
        <ul>
          <li><button v-on:click="gripperAction( gripper[0], 'open')">Open</button></li>
          <li><button v-on:click="gripperAction( gripper[0], 'grab')">Grab</button></li>
        </ul>
      </div>

      <!-- ******* SERVO *******  -->
      <div class="servo" v-for="servo in status.servosMap" :key="servo[0]">
        <h3>Servo ${ servo[0] }</h3>
        <table border="1">
          <tr><th>Angle</th><td>${servo[1].angle}</td></tr>
          <tr>
            <td></td>
            <td>
              <button v-on:click="servoMove(servo[0], -10)">-10</button>
              <button v-on:click="servoMove(servo[0], -1)">-1</button>
              <button v-on:click="servoMove(servo[0], 1)">1</button>
              <button v-on:click="servoMove(servo[0], 10)">10</button>
            </td>
          </tr>
        </table>
      </div>

      <!-- ******* MOTOR *******  -->
      <div class="motor" v-for="motor in status.motorsMap" :key="motor[0]">
        <h3>Motor ${ motor[0] }</h3>
        <table border="1">
          <tr>
              <th>${motor[0]}</th>
              <td>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 1.0})">----</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: .75})">---</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: .50})">--</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: .25})">-</button>
                <button v-on:click="motorButton(motor[0], {d:'none', s: 0})">0</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: .25})">+</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: .50})">++</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: .75})">+++</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 1.0})">++++</button>
              </td>
            </tr>
            <tr>
              <td>50rpm</td>
              <td>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 50, r: 10})">-10</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 50, r: 1})">-1</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 50, r: .25})">-.25</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 50, r: .25})">+.25</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 50, r: 1})">+1</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 50, r: 10})">+10</button>
              </td>
            </tr>
            <tr>
              <td>10rpm</td>
              <td>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 10, r: 10})">-10</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 10, r: 1})">-1</button>
                <button v-on:click="motorButton(motor[0], {d:'backward', s: 10, r: .25})">-.25</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 10, r: .25})">+.25</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 10, r: 1})">+1</button>
                <button v-on:click="motorButton(motor[0], {d:'forward', s: 10, r: 10})">+10</button>
              </td>
            </tr>
          <tr>
            <td align="right">On</td>
            <td>${motor[1].on}</td>
          </tr>
          <tr>
            <td align="right">PositionSupported</td>
            <td>${motor[1].positionSupported}</td>
          </tr>
          <tr>
            <td align="right">Position</td>
            <td>${motor[1].position}</td>
          </tr>
        </table>
      </div>

      <table>
        <tr>
          <td><img id="i0" src=""/></td>
          <td><img id="i1" src=""/></td>
          {{ range $view := .Views }}
          <td>
            {{ htmlSafe $view.Body }}
          </td>
          {{ end }}
        </tr>
      </table>
      
      <!-- ******* BOARD *******  -->

      <div class="board" v-for="(board, boardIndex) in status.boardsMap" :key="board[0]">
        <h3>Board ${board[0]}</h3>
        <table border="1">

          <tr><th colspan="2">Analogs</th></tr>
          <tr v-for="a in board[1].analogsMap" :key="a[0]">
            <th>${a[0]}</th>
            <td>${a[1].value}</td>
          </tr>

          <tr><th colspan="2">DigitalInterrupts</th></tr>
          <tr v-for="di in board[1].digitalInterruptsMap" :key="di[0]">
            <th>${di[0]}</th>
            <td>${di[1].value}</td>
          </tr>
          
        </table>
      </div> <!-- end boards -->
      <!-- cameras -->
      <table border="1" v-if="nonEmpty(status.camerasMap)">
        <tr>
          <th colspan="3">
            Cameras
          </th>
        </tr>
        <tr>
          <th>Name</th>
          <th>Frame</th>
          <th>PCD</th>
        </tr>
        <tr v-for="(cam,x) in status.camerasMap">
          <td>${cam[0]}</td>
          <td><a href="#" v-on:click.prevent="renderFrame(cam[0])">frame</a></td>
          <td><button v-on:click="renderPCD(cam[0])">GO</button></td>
        </tr>
      </table>

      <table border=1 v-if="nonEmpty(status.sensorsMap)">
        <tr>
          <th colspan="2">Sensors</th>
        </tr>
        
        <tr>
          <th>Name</th>
          <th>Type</th>
        </tr>
        
        <tr v-for="(sensor, x) in status.sensorsMap">
          <td>${sensor[0]}</td>
          <td>${sensor[1].type}</td>
          <td><button v-on:click="doSensorReadings(sensor[0])">Get Readings</button></td>
        </tr>
      </table>
      
      <div>${res}</div>
      <div>
        <h3>Functions</h3>
        <div id="named_functions" v-if="nonEmpty(status.functionsMap)">
          <h4>Named</h4>
          <div v-for="(func, x) in status.functionsMap">
            <button v-on:click="executeFunction(func[0])">${func[0]}</button>
          </div>
        </div>
        <h4>Evaluate</h4>
        <div id="source">console.log("hello world")</div>
        <br/>
        <button v-on:click="evalSource()">Run</button>
        <br/>
        <textarea disabled id="function_results" rows="10" cols="80"></textarea>
      </div>

      <div id="pcd_wrapper">
        <table>
          <tr>
            <td><div id="pcd" v-on:click="grabClick"/></td>
            <td v-if="pcdClick.enable">
              <table>
                <tr>
                  <th colspan=2>
                    Clicked On
                  </th>
                </tr>
                <tr>
                  <th>X</th>
                  <td>${pcdClick.x}</td>
                </tr>
                <tr>
                  <th>Y</th>
                  <td>${pcdClick.y}</td>
                </tr>
                <tr>
                  <th>Z</th>
                  <td>${pcdClick.z}</td>
                </tr>
                <tr>
                  <td colspan=2>${pcdClick.path}</td>
                </tr>
                <tr>
                  <td colspan=2>
                    <button v-on:click="doPCDGrab">Grab</button>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>
      </div> <!-- end pcd wrapper -->
      <!-- get segments -->
      <table v-if="pcdClick.pcdloaded">
        <tr>
          <td colspan=2>
              Min Pts in Plane: <input type="number" id="minPtsPlane" min="0"  v-model="minPtsPlane"><br>
              Min Pts in Segment: <input type="number" id="minPtsSegment" min="0" v-model="minPtsSegment"><br>
              Clustering Radius (mm): <input type="number" id="clusterRad" min="0" v-model="clusterRad"><br>
          </td>
        </tr>
        <tr>
            <td>
                <button v-on:click="findSegments(minPtsPlane, minPtsSegment, clusterRad)">Find Segments</button>
            </td>
            <td v-if="pcdClick.calculatingSegments">Finding...</td>
        </tr>
      </table>
      <table v-if="pcdClick.foundSegments">
        <tr>
          <th>Object</th>
          <th>PCD</th>
          <th>Point</th>
        </tr>
        <tr>
          <td>Full Image</td>
          <td><button v-on:click="doPCDLoad(fullcloud)">GO</button></td>
          <td>--</td>
        </tr>
        <tr v-for="(seg, i) in segments">
            <td>Object ${i}</td>
            <td><button v-on:click="doSegmentLoad(seg, i)">GO</button></td>
            <td><button v-on:click="doPointLoad(i)">GO</button></td>
        </tr>
      </table>
    </div> <!-- end vue app -->
  </body>
</html>

