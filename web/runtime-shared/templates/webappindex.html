<html>
  <head>
    <style type="text/css" media="screen">
      #source {
        position: relative;
        width: 50%;
        height: 50%;
      }
      #map {
        height: 400px;
        width: 100%;
      }
    </style>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
    <script>
      window.webrtcEnabled = {{ .WebRTCEnabled }}
      window.webrtcHost = {{ .WebRTCHost }}
      window.webrtcSignalingAddress = {{ .WebRTCSignalingAddress }}
    </script>
    {{ if .External }}
    <script src="/static/core/control.js"></script>
    <script src="/static/core/third-party/vue.js"></script>
    <script src="/static/core/third-party/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="/static/core/components.js"></script>
    <link rel="stylesheet" href="/static/core/components/coreComponents.css">
    <script type="module">
      import "/static/core/components/coreComponents.umd.min.js";
    </script>
    {{ else }}
    <script src="/static/control.js"></script>
    <script src="/static/third-party/vue.js"></script>
    <script src="/static/third-party/ace/ace.js" type="text/javascript" charset="utf-8"></script>
    <script src="/static/components.js"></script>
    <link rel="stylesheet" href="/static/components/coreComponents.css">
    <script type="module">
      import "/static/components/coreComponents.umd.js";
    </script>
    {{ end }}

    <script>
      function roundTo2Decimals(num) {
          num = Math.round(num * 100);
          return num / 100;
      }

      function grpcCallback(err, resp, stringify) {
        if (err) {
          theData.error = JSON.stringify(err);
          return;
        }
        if (stringify === undefined || stringify) {
          try {
            if (resp.toJavaScript) {
              theData.res = JSON.stringify(resp.toJavaScript());
            } else {
              theData.res = JSON.stringify(resp.toObject());
            }
          } catch (e) {
            theData.error = JSON.stringify(e);
          }
        }
      }

      {{ range $view := .Views }}
        {{ jsSafe $view.JavaScript }}
      {{ end }}

      function fixArms(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              const [armName, armValue] = old[i];
              var newArm = { name : armName, pieces : [] };

              var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["theta", "Theta"], ["oX", "OX"], ["oY", "OY"], ["oZ", "OZ"]];
              for (var j=0; j<fieldSetters.length; j++ ){
                  let gridField = fieldSetters[j][0].split(".");
                  let gridValue = armValue.gridPosition[gridField[0]];
                  for (let k = 1; k < gridField.length; k++) {
                    gridValue = gridValue[gridField[k]];
                  }
                  newArm.pieces.push( { grid : fieldSetters[j],
                                        joint : j,
                                        gridValue : gridValue,
                                        jointValue : armValue.jointPositions.degreesList[j] || 0,
                                      });
              }

              n.push(newArm);
          }
          return n;
      }

      firstResult = false;

      async function updateStatus(rawStatus) {
          theData.rawStatus = rawStatus;
          window.rawStatus = rawStatus;
          // toObject gives annoying suffixes; see https://github.com/protocolbuffers/protobuf/issues/6773
          const rawSatusObj = rawStatus.toObject();

          var status = {}

          // make vue friendly
          status.armsMap = rawSatusObj.armsMap;
          status.basesMap = rawSatusObj.basesMap;
          status.grippersMap = rawSatusObj.grippersMap;
          status.boardsMap = rawSatusObj.boardsMap;
          status.camerasMap = rawSatusObj.camerasMap;
          status.sensorsMap = rawSatusObj.sensorsMap;
          status.servosMap = rawSatusObj.servosMap;
          status.motorsMap = rawSatusObj.motorsMap;
          status.functionsMap = rawSatusObj.functionsMap;
          status.servicesMap = rawSatusObj.servicesMap;

          status.armsMap = fixArms(status.armsMap);

          if (!firstResult) {
            console.log(rawSatusObj);
            console.log(status);
            firstResult = true;
          }

          theData.status = status;
      }

      async function startup() {
          theData = {
              error : "",
              res : {},
              rawStatus : null,
              status : {},
              pcdClick : {},
              fullcloud: null,
              segments : null,
              segCenters : null,
              minPtsPlane : 10000,
              minPtsSegment: 100,
              clusterRad: 5,
              armToggle : {},
              editor: undefined,
              mapOnce: false,
          };
          theApp = new Vue({
              el: '#app',
              delimiters: ['${', '}'],
              data: theData,
              components: {},
              methods : {
                  armGridInc : function(name, getterSetter, amount) {
                      if (getterSetter[0] == 'o' || getterSetter[0] == 'O') {
                          amount /= 100;
                      }
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();
                      var newPosition = Object.assign(Object.create(robotApi.ArmPosition.prototype), old);
                      const getter = `get${getterSetter}`;
                      const setter = `set${getterSetter}`;
                      newPosition[setter](newPosition[getter]() + amount);
                      const req = new robotApi.ArmMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armJointInc : function(name, field, amount) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      newList[field] += amount;
                      newPosition.setDegreesList(newList);
                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armHome : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      for (var i = 0; i < newList.length; i++) {
                        newList[i] = 0;
                      }
                      newPosition.setDegreesList(newList);
                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armModifyAll : function(name, arm) {
                      var n = { name : name, pieces : [] };

                      for ( var i=0; i < arm.pieces.length; i++) {
                          n.pieces.push( {
                              grid : arm.pieces[i].grid,
                              gridValue : roundTo2Decimals(arm.pieces[i].gridValue),
                              joint : arm.pieces[i].joint,
                              jointValue : roundTo2Decimals(arm.pieces[i].jointValue),
                          });

                      }

                      theData.armToggle[name] = n;
                  },
                  armModifyAllCancel : function(name, arm) {
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoGrid : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();

                      var newPosition = Object.assign(Object.create(robotApi.ArmPosition.prototype), old);
                      var newPieces = theData.armToggle[name].pieces;

                      for (var i=0; i < newPieces.length; i++) {
                          var getterSetter = newPieces[i].grid[1];
                          const getter = `get${getterSetter}`;
                          const setter = `set${getterSetter}`;
                          newPosition[setter](newPieces[i].gridValue);
                      }

                      const req = new robotApi.ArmMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoJoint : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();

                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();

                      var newPieces = theData.armToggle[name].pieces;
                      for (var i=0; i < newPieces.length && i < newList.length; i++) {
                          newList[newPieces[i].joint] = newPieces[i].jointValue;
                      }

                      newPosition.setDegreesList(newList);

                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      robotService.armMoveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },

                  gripperAction : function(name, action) {
                      let req;
                      switch (action) {
                        case 'open':
                          req = new robotApi.GripperOpenRequest();
                          req.setName(name);
                          robotService.gripperOpen(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'grab':
                          req = new robotApi.GripperGrabRequest();
                          req.setName(name);
                          robotService.gripperGrab(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  servoMove : function(name, amount) {
                      const servo = theData.rawStatus.getServosMap().get(name);
                      var old = servo.getAngle();
                      var angle = old + amount;
                      const req = new robotApi.ServoMoveRequest();
                      req.setName(name);
                      req.setAngleDeg(angle);
                      robotService.servoMove(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorCommand: function(motor, cmd) {
                    let req = cmd.request;
                    req.setName(motor);

                    switch (cmd.type) {
                      case "go":
                        robotService.motorGo(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goFor":
                        robotService.motorGoFor(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goTo":
                        robotService.motorGoTo(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                    }
                  },
                  doAction : function(name) {
                      const req = new robotApi.DoActionRequest();
                      req.setName(name);
                      robotService.doAction(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  baseAction : function(name, action, amount) {
                      let req;
                      switch (action) {
                        case 'straight':
                          req = new robotApi.BaseMoveStraightRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          robotService.baseMoveStraight(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'angle':
                          req = new robotApi.BaseSpinRequest();
                          req.setName(name);
                          req.setDegsPerSec(document.getElementById("speed").value)
                          req.setAngleDeg(amount);
                          robotService.baseSpin(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  renderFrame : function(cameraName) {
                      req = new robotApi.CameraFrameRequest();
                      req.setName(cameraName);
                      const mimeType = 'image/png';
                      req.setMimeType(mimeType)
                      robotService.cameraFrame(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        let blob = new Blob([resp.getFrame_asU8()], { type: mimeType });
                        window.open(URL.createObjectURL(blob), "_blank");
                      });
                  },
                  renderPCD : function(cameraName) {
                      theData.pcdClick.pcdloaded = false;
                      theData.pcdClick.foundSegments = false;
                      initPCDIfNeeded();
                      pcdGlobal.cameraName = cameraName;

                      req = new robotApi.PointCloudRequest();
                      req.setName(cameraName);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType)
                      robotService.pointCloud(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        console.log("loading pcd");
                        theData.fullcloud = resp.getFrame_asB64();
                        pcdLoad(`data:${mimeType};base64,${theData.fullcloud}`);
                      });

                  },
                  doSensorReadings : function(name) {
                      var req = new robotApi.SensorReadingsRequest();
                      req.setName(name);
                      robotService.sensorReadings(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  processFunctionResults: function(err, resp) {
                    grpcCallback(err, resp, false)
                    if (err) {
                      document.getElementById("function_results").value = `${err}`;
                      return;
                    }
                    var results = resp.getResultsList();

                    let resultStr = '';
                    if (results.length > 0) {
                      resultStr += 'Results: \n';
                      for (let i = 0; i < results.length && i < results.length; i++) {
                        let result = results[i];
                        resultStr += `${i}: ${JSON.stringify(result.toJavaScript())}\n`;
                      }
                    }
                    resultStr += `StdOut: ${resp.getStdOut()}\n`;
                    resultStr += `StdErr: ${resp.getStdErr()}\n`;
                    document.getElementById("function_results").value = resultStr;
                  },
                  executeFunction : function(name) {
                      document.getElementById("function_results").value = "";
                      var req = new robotApi.ExecuteFunctionRequest();
                      req.setName(name);
                      robotService.executeFunction(req, {}, this.processFunctionResults);
                  },
                  evalSource : function() {
                      document.getElementById("function_results").value = "";
                      var req = new robotApi.ExecuteSourceRequest();
                      req.setSource(theData.editor.getValue());
                      req.setEngine('javascript');
                      robotService.executeSource(req, {}, this.processFunctionResults);
                  },
                  nonEmpty : function(d) {
                      for ( var k in d ) {
                          return true;
                      }
                      return false;
                  },
                  hasKey : function(d, key) {
                    if (!d) {
                      return false;
                    }
                    if (Array.isArray(d)) {
                      for (let i = 0; i < d.length; i++) {
                        if (d[i] == key || (d[i].length && d[i].length >= 1 && d[i][0] == key)) {
                          return true;
                        }
                      }
                      return false;
                    }
                    return d.hasOwn(key);
                  },
                  grabClick : function(e) {
                      var mouse = new THREE.Vector2();
                      mouse.x = ((e.offsetX / e.srcElement.offsetWidth) * 2) - 1
                      mouse.y = ((e.offsetY / e.srcElement.offsetHeight) * -2) + 1

	                  pcdGlobal.raycaster.setFromCamera( mouse, pcdGlobal.camera );

	                  var intersects = pcdGlobal.raycaster.intersectObjects( pcdGlobal.scene.children );
                      var p = ( intersects.length ) > 0 ? intersects[ 0 ] : null;

                      if ( p !== null ) {
                        console.log(p.point);
                        setPoint(p.point);
                      } else {
                        console.log("no point intersected");
                      }

                  },
                  doPCDGrab : function(){
                      console.log(theData.pcdClick.path);
                      fetch(theData.pcdClick.path).then(console.log);
                  },
                  findSegments : function(minPointsPlane, minPointsSegment, clusteringRadius){
                      theData.pcdClick.calculatingSegments = true;
                      req = new robotApi.ObjectPointCloudsRequest();
                      console.log("camera name: "+pcdGlobal.cameraName);
                      req.setName(pcdGlobal.cameraName);
                      req.setMinPointsInPlane(minPointsPlane);
                      req.setMinPointsInSegment(minPointsSegment);
                      req.setClusteringRadius(clusteringRadius);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType);
                      console.log("finding object segments...");
                      robotService.objectPointClouds(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          console.log("error getting segments");
                          theData.pcdClick.calculatingSegments = false;
                          return;
                        }
                        console.log("got pcd segments");
                        theData.pcdClick.foundSegments = true;
                        theData.segments = resp.getFramesList_asB64();
                        theData.segCenters = resp.getCentersList();
                        theData.pcdClick.calculatingSegments = false;
                      });
                  },
                  doSegmentLoad : function(data, i){
                        var center = theData.segCenters[i];
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  doPointLoad : function(i){
                        var center = theData.segCenters[i];
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                  },
                  doPCDLoad : function(data){
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  setNavigationMode : function(mode){
                    let pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_UNSPECIFIED;
                    switch (mode) {
                      case 'manual':
                        pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_MANUAL;
                        break;
                      case 'waypoint':
                        pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_WAYPOINT;
                        break;
                    }
                    var req = new robotApi.NavigationServiceSetModeRequest();
                    req.setMode(pbMode);
                    robotService.navigationServiceSetMode(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  setNavigationLocation: function(elId) {
                    const posSplit = document.getElementById(elId).value.split(",");
                    if (posSplit.length != 2) {
                      return;
                    }
                    const lat = parseFloat(posSplit[0]);
                    const lng = parseFloat(posSplit[1]);
                    var req = new robotApi.ResourceRunCommandRequest();
                    let gpsName = "";
                    for (let i = 0; i < theData.status.sensorsMap.length; i++) {
                      const s = theData.status.sensorsMap[i];
                      if (s[1].type === 'gps') {
                        gpsName = s[0];
                        break;
                      }
                    }
                    if (gpsName === "") {
                      theData.error = "no gps device found";
                      return;
                    }
                    req.setResourceName("gps1");
                    req.setCommandName("set_location");
                    req.setArgs(proto.google.protobuf.Struct.fromJavaScript({
                      latitude: lat,
                      longitude: lng,
                    }))
                    robotService.resourceRunCommand(req, {}, (err, resp) => grpcCallback(err, resp));
                  }
              },
              directives: {
                // TODO(erd): replace with vue component after naveed work done
                mapMounted (el) {
                  if (theData.mapOnce) {
                    return;
                  }
                  theData.mapOnce = true;
                  initNavigation();
                }
              },
          })

          const streamReq = new robotApi.StatusStreamRequest();
          streamReq.setEvery((new proto.google.protobuf.Duration()).setNanos(500000000)); // 500ms

          let statusStream;
          let lastStatusTS = Date.now();
          const checkInternvalMillis = 3000;
          const checkLastStatus = function() {
            if ((Date.now() - lastStatusTS) > checkInternvalMillis) {
              restartStatusStream();
              return
            }
            setTimeout(checkLastStatus, checkInternvalMillis)
          }

          const restartStatusStream = async function() {
            if (statusStream) {
              statusStream.cancel();
              try {
                console.log("reconnecting");
                await window.reconnect();
              } catch {
                console.error("failed to reconnect; retrying");
                setTimeout(() => restartStatusStream(), 1000);
              }
            }
            statusStream = robotService.statusStream(streamReq);
            let firstData = true;
            statusStream.on('data', function(response) {
              lastStatusTS = Date.now();
              updateStatus(response.getStatus());
              if (firstData) {
                firstData = false;
                checkLastStatus();
              }
            });
            statusStream.on('status', function(status) {
              console.log("error streaming robot status");
              console.log(status);
              console.log(status.code, " ", status.details);
            });
            statusStream.on('end', function(end) {
              console.log("done streaming robot status");
              setTimeout(() => restartStatusStream(), 1000);
            });
          }
          await restartStatusStream();

          const editor = ace.edit("source");
          editor.setTheme("ace/theme/monokai");
          editor.session.setMode("ace/mode/javascript");
          editor.resize();
          editor.setReadOnly(false);
          theData.editor = editor;
      }

      pcdGlobal = null;

      function initPCDIfNeeded() {
          if (pcdGlobal) {
              return
          }
          theData.pcdClick.enable = true;
          console.log("initing pcd");

          const sphereGeometry = new THREE.SphereGeometry( .009, 32, 32 );
          const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

          pcdGlobal = {
              scene : new THREE.Scene(),
              camera : new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 2000 ),
              renderer : new THREE.WebGLRenderer(),
              raycaster : new THREE.Raycaster(),
              sphere: new THREE.Mesh( sphereGeometry, sphereMaterial ),
          };

          pcdGlobal.renderer.setSize( window.innerWidth / 2, window.innerHeight / 2 );
          document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);

          pcdGlobal.controls = new orbitLib.OrbitControls( pcdGlobal.camera, pcdGlobal.renderer.domElement );
          pcdGlobal.camera.position.set( 0, 0, 0 );
          pcdGlobal.controls.target.set(0,0,-1);
          pcdGlobal.controls.update();
          pcdGlobal.camera.updateMatrix();

          console.log("pcd init done");
      }

      function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
                    renderer.setSize(width, height, false);
                  }
          return needResize;
        }

      function pcdAnimate() {
          if (resizeRendererToDisplaySize(pcdGlobal.renderer)) {
                    const canvas = pcdGlobal.renderer.domElement;
                    pcdGlobal.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    pcdGlobal.camera.updateProjectionMatrix();
          }
	      pcdGlobal.renderer.render( pcdGlobal.scene, pcdGlobal.camera );
          pcdGlobal.controls.update();
          requestAnimationFrame( pcdAnimate );
      }

      function pcdLoad(path) {
          var loader = new pcdLib.PCDLoader();
          loader.load(
              path,

            // called when the resource is loaded
            function ( mesh ) {
              pcdGlobal.scene.clear();
              pcdGlobal.scene.add( mesh );
              pcdGlobal.scene.add( pcdGlobal.sphere);
              pcdAnimate();
            },
            // called when loading is in progresses
            function ( xhr ) {
              //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
              console.log(error);
            }
          );
          theData.pcdClick.pcdloaded = true;
      }

      function r(n) {
          return Math.round(n*1000);
      }

      function setPoint(point) {
          var path = "/grab_at_camera_position/"
              + pcdGlobal.cameraName + "/"
              + r(point.x) + "/" + r(point.y) + "/" + r(point.z);

          theData.pcdClick.x = r(point.x);
          theData.pcdClick.y = r(point.y);
          theData.pcdClick.z = r(point.z);
          theData.pcdClick.path = path;
          pcdGlobal.sphere.position.copy(point);
      }

      async function waitForClientAndStart() {
        console.debug("waiting for robot service to be ready");
        await window.robotServiceReady;
        console.debug("ready");
        await startup();
      }

      async function initNavigation() {
        await mapReady;
        window.map = new google.maps.Map(document.getElementById("map"), {zoom: 18});
        window.map.addListener("click", (e) => {
          var req = new robotApi.NavigationServiceAddWaypointRequest();
          var point = new robotApi.GeoPoint();
          point.setLatitude(e.latLng.lat());
          point.setLongitude(e.latLng.lng());
          req.setLocation(point);
          robotService.navigationServiceAddWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
        });

        let centered = false;
        const knownWaypoints = {};
        let localLabelCounter = 0;
        const updateWaypoints = function() {
          var req = new robotApi.NavigationServiceWaypointsRequest();
          robotService.navigationServiceWaypoints(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateWaypoints, 1000);
              return;
            }
            const currentWaypoints = {};
            var waypoints = resp.getWaypointsList();
            for (var i = 0; i < waypoints.length; i++) {
              const waypoint = waypoints[i];
              const pos = {lat: waypoint.getLocation().getLatitude(), lng: waypoint.getLocation().getLongitude()};
              const posStr = JSON.stringify(pos);
              if (knownWaypoints[posStr]) {
                currentWaypoints[posStr] = knownWaypoints[posStr];
                continue;
              }
              const marker = new google.maps.Marker({
                position: pos,
                map: window.map,
                label: `${localLabelCounter++}`,
              });
              currentWaypoints[posStr] = marker;
              knownWaypoints[posStr] = marker;
              marker.addListener("click", () => {
                console.log("clicked on marker", pos)
              });
              marker.addListener("dblclick", () => {
                var req = new robotApi.NavigationServiceRemoveWaypointRequest();
                req.setId(waypoint.getId());
                robotService.navigationServiceRemoveWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
              });
            }
            const waypointsToDelete = Object.keys(knownWaypoints).filter(elem => {
              return !(elem in currentWaypoints)
            });
            for (key of waypointsToDelete) {
              const marker = knownWaypoints[key];
              marker.setMap(null);
              delete knownWaypoints[key];
            }
            setTimeout(updateWaypoints, 1000);
          });
        }
        updateWaypoints();

        const locationMarker = new google.maps.Marker({label: "robot"});
        const updateLocation = function() {
          var req = new robotApi.NavigationServiceLocationRequest();
          robotService.navigationServiceLocation(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateLocation, 1000);
              return;
            }
            const pos = {lat: resp.getLocation().getLatitude(), lng: resp.getLocation().getLongitude()};
            if (!centered) {
              centered = true;
              window.map.setCenter(pos);
            }
            locationMarker.setPosition(pos);
            locationMarker.setMap(window.map);
            setTimeout(updateLocation, 1000);
          });
        }
        updateLocation();
      }

      function initMap() {
        mapReadyResolve();
      }

      let mapReadyResolve;
      let mapReady = new Promise(resolve => {
        mapReadyResolve = resolve;
      });
    </script>
  </head>
  <body onLoad="waitForClientAndStart()" style="background: var(--black-10);">
    <div id="app">
      <div id="actions">
        {{range $r := .Actions}}
        <button v-on:click="doAction('{{$r}}')">{{$r}}</button>
        {{end}}
      </div>

      <div style="color: red">${ error }</div>

      <!-- ******* BASE *******  -->
      <div class="base" v-for="base in status.basesMap" :key="base[0]">
        <h3>${base[0]}</h3>
        <ul>
          <li><button v-on:click="baseAction(base[0], 'straight', 1)">Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'straight', -1)">Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', 15)">Spin Clockwise</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', -15)">Spin Counterclockwise</button></li>
        </ul>

        Speed (mm per sec): <input id="speed" name="speed" value="300"/><br>
        Distances (mm): <input id="distance" name="speed" value="500"/><br>
      </div>

      <!-- ******* ARM *******  -->
      <div class="arm" v-for="arm in status.armsMap" :key="arm.name">
        <h3>Arm ${arm.name}</h3>
        <table v-if="armToggle[arm.name]" border="1">
          <tr>
            <th colspan="2"><h5>GRID (mms)</h5></th>
            <th colspan="2"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armToggle[arm.name].pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td><input v-model="aa.gridValue"></td>

            <th>Joint ${aa.joint}</th>
            <td><input v-model="aa.jointValue"></td>
          </tr>
          <tr>
            <th colspan="6">
              <button v-on:click="armModifyAllDoGrid(arm.name, arm)">Go To Grid</button>
              <button v-on:click="armModifyAllDoJoint(arm.name, arm)">Go To Joints</button>
              <button v-on:click="armModifyAllCancel(arm.name, arm)">Cancel</button>
            </th>
          </tr>
        </table>
        <table border="1" v-else>
          <tr>
            <th colspan="3"><h5>GRID (mms)</h5></th>
            <th colspan="3"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in arm.pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -10 )">--</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -1 )">-</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 1 )">+</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 10 )">++</button>
            </td>
            <td>${aa.gridValue.toFixed(2)}</td>

            <th>Joint ${aa.joint}</th>
            <td>
              <button v-on:click="armJointInc( arm.name, aa.joint, -10 )">--</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, -1 )">-</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 1 )">+</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 10 )">++</button>
            </td>
            <td>${aa.jointValue.toFixed(2)}</td>
          </tr>
          <tr>
            <th colspan="8">
              <button v-on:click="armHome( arm.name)">Home</button>
              <button v-on:click="armModifyAll(arm.name, arm)">Modify All</button>
            </th>
          </tr>
        </table> <!-- end main table -->
      </div>

      <!-- ******* GRIPPER *******  -->
      <div class="gripper" v-for="gripper in status.grippersMap" :key="gripper[0]">
        <h3>Gripper ${ gripper[0] }</h3>
        <ul>
          <li><button v-on:click="gripperAction( gripper[0], 'open')">Open</button></li>
          <li><button v-on:click="gripperAction( gripper[0], 'grab')">Grab</button></li>
        </ul>
      </div>

      <!-- ******* SERVO *******  -->
      <div class="servo" v-for="servo in status.servosMap" :key="servo[0]" style="margin-bottom: 64px;">
        <h3>Servo ${ servo[0] }</h3>
        <table border="1">
          <tr><th>Angle</th><td>${servo[1].angle}</td></tr>
          <tr>
            <td></td>
            <td>
              <button v-on:click="servoMove(servo[0], -10)">-10</button>
              <button v-on:click="servoMove(servo[0], -1)">-1</button>
              <button v-on:click="servoMove(servo[0], 1)">1</button>
              <button v-on:click="servoMove(servo[0], 10)">10</button>
            </td>
          </tr>
        </table>
      </div>

      <!-- ******* MOTOR *******  -->
      <motor-detail
        v-for="motor in status.motorsMap"
        :key="'new-' + motor[0]"
        v-bind:motor-name="motor[0]"
        v-bind:motor-status="motor[1]"
        v-on:execute="motorCommand(motor[0], $event)"
        style="max-width: 1080px;">
      </motor-detail>

      <table>
        <tr>
          <td><img id="i0" src=""/></td>
          <td><img id="i1" src=""/></td>
          {{ range $view := .Views }}
          <td>
            {{ htmlSafe $view.Body }}
          </td>
          {{ end }}
        </tr>
      </table>

      <!-- ******* BOARD *******  -->

      <div class="board" v-for="(board, boardIndex) in status.boardsMap" :key="board[0]">
        <h3>Board ${board[0]}</h3>
        <table border="1">

          <tr><th colspan="2">Analogs</th></tr>
          <tr v-for="a in board[1].analogsMap" :key="a[0]">
            <th>${a[0]}</th>
            <td>${a[1].value}</td>
          </tr>

          <tr><th colspan="2">DigitalInterrupts</th></tr>
          <tr v-for="di in board[1].digitalInterruptsMap" :key="di[0]">
            <th>${di[0]}</th>
            <td>${di[1].value}</td>
          </tr>
        </table>
      </div> <!-- end boards -->
      <!-- cameras -->
      <table border="1" v-if="nonEmpty(status.camerasMap)">
        <tr>
          <th colspan="3">
            Cameras
          </th>
        </tr>
        <tr>
          <th>Name</th>
          <th>Frame</th>
          <th>PCD</th>
        </tr>
        <tr v-for="(cam,x) in status.camerasMap">
          <td>${cam[0]}</td>
          <td><a href="#" v-on:click.prevent="renderFrame(cam[0])">frame</a></td>
          <td><button v-on:click="renderPCD(cam[0])">GO</button></td>
        </tr>
      </table>

      <table border=1 v-if="nonEmpty(status.sensorsMap)">
        <tr>
          <th colspan="2">Sensors</th>
        </tr>

        <tr>
          <th>Name</th>
          <th>Type</th>
        </tr>

        <tr v-for="(sensor, x) in status.sensorsMap">
          <td>${sensor[0]}</td>
          <td>${sensor[1].type}</td>
          <td><button v-on:click="doSensorReadings(sensor[0])">Get Readings</button></td>
        </tr>
      </table>

      <div>${res}</div>
      <div>
        <h3>Functions</h3>
        <div id="named_functions" v-if="nonEmpty(status.functionsMap)">
          <h4>Named</h4>
          <div v-for="(func, x) in status.functionsMap">
            <button v-on:click="executeFunction(func[0])">${func[0]}</button>
          </div>
        </div>
        <h4>Evaluate</h4>
        <div id="source">console.log("hello world")</div>
        <br/>
        <button v-on:click="evalSource()">Run</button>
        <br/>
        <textarea disabled id="function_results" rows="10" cols="80"></textarea>
      </div>

      <div id="pcd_wrapper">
        <table>
          <tr>
            <td><div id="pcd" v-on:click="grabClick"/></td>
            <td v-if="pcdClick.enable">
              <table>
                <tr>
                  <th colspan=2>
                    Clicked On
                  </th>
                </tr>
                <tr>
                  <th>X</th>
                  <td>${pcdClick.x}</td>
                </tr>
                <tr>
                  <th>Y</th>
                  <td>${pcdClick.y}</td>
                </tr>
                <tr>
                  <th>Z</th>
                  <td>${pcdClick.z}</td>
                </tr>
                <tr>
                  <td colspan=2>${pcdClick.path}</td>
                </tr>
                <tr>
                  <td colspan=2>
                    <button v-on:click="doPCDGrab">Grab</button>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>
      </div> <!-- end pcd wrapper -->
      <!-- get segments -->
      <table v-if="pcdClick.pcdloaded">
        <tr>
          <td colspan=2>
              Min Pts in Plane: <input type="number" id="minPtsPlane" min="0"  v-model="minPtsPlane"><br>
              Min Pts in Segment: <input type="number" id="minPtsSegment" min="0" v-model="minPtsSegment"><br>
              Clustering Radius (mm): <input type="number" id="clusterRad" min="0" v-model="clusterRad"><br>
          </td>
        </tr>
        <tr>
            <td>
                <button v-on:click="findSegments(minPtsPlane, minPtsSegment, clusterRad)">Find Segments</button>
            </td>
            <td v-if="pcdClick.calculatingSegments">Finding...</td>
        </tr>
      </table>
      <table v-if="pcdClick.foundSegments">
        <tr>
          <th>Object</th>
          <th>PCD</th>
          <th>Point</th>
        </tr>
        <tr>
          <td>Full Image</td>
          <td><button v-on:click="doPCDLoad(fullcloud)">GO</button></td>
          <td>--</td>
        </tr>
        <tr v-for="(seg, i) in segments">
            <td>Object ${i}</td>
            <td><button v-on:click="doSegmentLoad(seg, i)">GO</button></td>
            <td><button v-on:click="doPointLoad(i)">GO</button></td>
        </tr>
      </table>
      <div id="map-container" v-if="hasKey(status.servicesMap, 'navigation')">
        <br />
        <br />
        <button v-on:click="setNavigationMode('manual')">Manual</button>
        <button v-on:click="setNavigationMode('waypoint')">Waypoint</button>
        <br />
        <input type="text" id="nav-set-location" value="40.745297,-74.010916">
        <button v-on:click="setNavigationLocation('nav-set-location')">Try Set Location</button>
        <div id="map" v-map-mounted></div>
      </div>
    </div> <!-- end vue app -->

    <!-- TODO(https://github.com/viamrobotics/core/issues/202): remove api key once going into production -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBn72TEqFOVWoj06cvua0Dc0pz2uvq90nY&callback=initMap&libraries=&v=weekly"
      async
    ></script>
  </body>
</html>
