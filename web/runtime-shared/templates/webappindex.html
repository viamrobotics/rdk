<html>
  <head>
    <style type="text/css" media="screen">
      #source {
        position: relative;
        width: 50%;
        height: 50%;
      }
      #map {
        height: 400px;
        width: 100%;
      }
      [v-cloak] { display: none; }
      #pre-app.connected { display: none; }
      #connecting { display: none; }
      #connecting.connecting { display: block; }
      #connecting-error { color: red };
    </style>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
    <script>
      window.webrtcEnabled = {{ .WebRTCEnabled }}
      window.webrtcHost = {{ .WebRTCHost }}
      window.webrtcSignalingAddress = {{ .WebRTCSignalingAddress }}
      window.webrtcAdditionalICEServers = {{ .WebRTCAdditionalICEServers }}
      window.supportedAuthTypes = {{ .SupportedAuthTypes }} || [];
    </script>
    {{ if .External }}
    <script src="/static/rdk/control.js"></script>
    <script src="/static/rdk/third-party/vue.js"></script>
    <link rel="stylesheet" href="/static/rdk/components/coreComponents.css">
    <script type="module">
      import "/static/rdk/components/coreComponents.umd.min.js";
    </script>
    {{ else }}
    <script src="/static/control.js"></script>
    <script src="/static/third-party/vue.js"></script>
    <link rel="stylesheet" href="/static/components/coreComponents.css">
    <script type="module">
      import "/static/components/coreComponents.umd.min.js";
    </script>
    {{ end }}

    <script>
      function roundTo2Decimals(num) {
          num = Math.round(num * 100);
          return num / 100;
      }

      function grpcCallback(err, resp, stringify) {
        if (err) {
          theData.error = JSON.stringify(err);
          return;
        }
        if (stringify === undefined || stringify) {
          try {
            if (resp.toJavaScript) {
              theData.res = JSON.stringify(resp.toJavaScript());
            } else {
              theData.res = JSON.stringify(resp.toObject());
            }
          } catch (e) {
            theData.error = JSON.stringify(e);
          }
        }
      }

      function fixArms(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              const [armName, armValue] = old[i];
              var newArm = { name : armName, pieces : [] };

              var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["theta", "Theta"], ["oX", "OX"], ["oY", "OY"], ["oZ", "OZ"]];
              for (var j=0; j<fieldSetters.length; j++ ){
                  let gridField = fieldSetters[j][0].split(".");
                  let gridValue = armValue.gridPosition[gridField[0]];
                  for (let k = 1; k < gridField.length; k++) {
                    gridValue = gridValue[gridField[k]];
                  }
                  newArm.pieces.push( { grid : fieldSetters[j],
                                        joint : j,
                                        gridValue : gridValue,
                                        jointValue : armValue.jointPositions.degreesList[j] || 0,
                                      });
              }

              n.push(newArm);
          }
          return n;
      }

      function fixBoards(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              const [boardName, boardValue] = old[i];
              var newBoard = {
                  name : boardName,
                  analogsMap : boardValue.analogsMap || [],
                  digitalInterruptsMap : boardValue.digitalInterruptsMap || [],
              };
              n.push(newBoard);
          }
          return n;
      }

      function fixGantries(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              var o = { name : old[i][0], parts : [] };

              var x = old[i][1];
              
              if (x.positionsList.length != x.lengthsList.length) {
                  throw "gantry lists different lengths";
              }
              
              for ( var i=0; i < x.positionsList.length; i++) {
                  o.parts.push( { axis : i, pos : x.positionsList[i], length : x.lengthsList[i] } );
              }

              n.push(o);
          }
          return n;
      }

      firstResult = false;

      async function updateStatus(rawStatus) {
          theData.rawStatus = rawStatus;
          window.rawStatus = rawStatus;
          // toObject gives annoying suffixes; see https://github.com/protocolbuffers/protobuf/issues/6773
          const rawStatusObj = rawStatus.toObject();

          var status = {}

          // make vue friendly
          status.armsMap = rawStatusObj.armsMap;
          status.basesMap = rawStatusObj.basesMap;
          status.gantriesMap = rawStatusObj.gantriesMap;
          status.grippersMap = rawStatusObj.grippersMap;
          status.boardsMap = rawStatusObj.boardsMap;
          status.camerasMap = rawStatusObj.camerasMap;
          status.sensorsMap = rawStatusObj.sensorsMap;
          status.servosMap = rawStatusObj.servosMap;
          status.motorsMap = rawStatusObj.motorsMap;
          status.servicesMap = rawStatusObj.servicesMap;
          status.inputControllersMap = rawStatusObj.inputControllersMap;

          status.armsMap = fixArms(status.armsMap);
          status.boardsMap = fixBoards(status.boardsMap);
          status.gantriesMap = fixGantries(status.gantriesMap);

          if (!firstResult) {
            console.log(rawStatusObj);
            console.log(status);
            firstResult = true;
          }

          theData.status = status;
      }

      async function startup() {
          theData = {
              error : "",
              res : {},
              rawStatus : null,
              status : {},
              pcdClick : {},
              resources: [],
              streamNames: [],
              fullcloud: null,
              objects: null,
              minPtsPlane : 10000,
              minPtsSegment: 100,
              clusterRad: 5,
              armToggle : {},
              mapOnce: false,
              chartStream: null,
              value: 0,
          };
          theApp = new Vue({
              el: '#app',
              delimiters: ['${', '}'],
              data: theData,
              components: {},
              methods : {
                  filterResources : function(namespace, type, subtype) {
                    return theData.resources.filter(elem => {
                      return elem.namespace == namespace && elem.type == type && elem.subtype == subtype
                    })
                  },
                  armByName : function(name) {
                    return theData.status.armsMap.find(elem => elem.name == name) || {}
                  },
                  boardByName : function(name) {
                    return theData.status.boardsMap.find(elem => elem.name == name) || {}
                  },
                  gantryByName : function(name) {
                      return theData.status.gantriesMap.find(elem => elem.name == name) || {}
                  },
                  gantryInc : function(name, axis, amount) {
                      var g = theData.status.gantriesMap.find(elem => elem.name == name);
                      var pos = [];
                      for ( var i=0; i < g.parts.length; i++) {
                          pos[i] = g.parts[i].pos;
                      }
                      pos[axis] += amount;
                      
                      const req = new gantryApi.GantryServiceMoveToPositionRequest();
                      req.setName(name);
                      req.setPositionsList(pos);
                      gantryService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armGridInc : function(name, getterSetter, amount) {
                      if (getterSetter[0] == 'o' || getterSetter[0] == 'O') {
                          amount /= 100;
                      }
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();
                      var newPosition = Object.assign(Object.create(commonApi.Pose.prototype), old);
                      const getter = `get${getterSetter}`;
                      const setter = `set${getterSetter}`;
                      newPosition[setter](newPosition[getter]() + amount);
                      const req = new armApi.ArmServiceMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorPIDStep: function(motor,req,chart,val){
                      if (theData.chartStream){
                          theData.chartStream.cancel()
                          theData.chartStream = null
                          chart.pause();
                          if(val){
                              return
                          }
                      }
                      req.setName(motor);
                      theData.chartStream = motorService.pIDStep(req)
                      chart.unpause();
                      theData.chartStream.on('data', function(resp){
                          this.addData(resp)
                          //chart.update('quiet')
                      }.bind(chart))
                      theData.chartStream.on('status', function(status) {
                          console.log("error streaming PID Data");
                          console.log(status);
                          console.log(status.code, " ", status.details);
                      });
                      theData.chartStream.on('end', function(end) {
                          console.log("done streaming PID Data");
                      });
                  },
                  armJointInc : function(name, field, amount) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(armApi.ArmJointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      newList[field] += amount;
                      newPosition.setDegreesList(newList);
                      const req = new armApi.ArmServiceMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armHome : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(armApi.ArmJointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      for (var i = 0; i < newList.length; i++) {
                        newList[i] = 0;
                      }
                      newPosition.setDegreesList(newList);
                      const req = new armApi.ArmServiceMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armModifyAll : function(name) {
                      const arm = theApp.armByName(name);
                      var n = { name : name, pieces : [] };

                      for ( var i=0; i < arm.pieces.length; i++) {
                          n.pieces.push( {
                              grid : arm.pieces[i].grid,
                              gridValue : roundTo2Decimals(arm.pieces[i].gridValue),
                              joint : arm.pieces[i].joint,
                              jointValue : roundTo2Decimals(arm.pieces[i].jointValue),
                          });

                      }

                      theData.armToggle[name] = n;
                  },
                  armModifyAllCancel : function(name) {
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoGrid : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();

                      var newPosition = Object.assign(Object.create(commonApi.Pose.prototype), old);
                      var newPieces = theData.armToggle[name].pieces;

                      for (var i=0; i < newPieces.length; i++) {
                          var getterSetter = newPieces[i].grid[1];
                          const getter = `get${getterSetter}`;
                          const setter = `set${getterSetter}`;
                          newPosition[setter](newPieces[i].gridValue);
                      }

                      const req = new armApi.ArmServiceMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },
                  armModifyAllDoJoint : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();

                      var newPosition = Object.assign(Object.create(armApi.ArmJointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();

                      var newPieces = theData.armToggle[name].pieces;
                      for (var i=0; i < newPieces.length && i < newList.length; i++) {
                          newList[newPieces[i].joint] = newPieces[i].jointValue;
                      }

                      newPosition.setDegreesList(newList);

                      const req = new armApi.ArmServiceMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                      delete theData.armToggle[name];
                  },

                  gripperAction : function(name, action) {
                      let req;
                      switch (action) {
                        case 'open':
                          req = new gripperApi.GripperServiceOpenRequest();
                          req.setName(name);
                          gripperService.open(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'grab':
                          req = new gripperApi.GripperServiceGrabRequest();
                          req.setName(name);
                          gripperService.grab(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  servoMove : function(name, amount) {
                      const servo = theData.rawStatus.getServosMap().get(name);
                      var oldAngle = servo.getAngle();
                      let angle = oldAngle + amount;
                      const req = new servoApi.ServoServiceMoveRequest();
                      req.setName(name);
                      req.setAngleDeg(angle);
                      servoService.move(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorCommand: function(motor, cmd) {
                    let req = cmd.request;
                    req.setName(motor);

                    switch (cmd.type) {
                      case "go":
                        motorService.go(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goFor":
                        motorService.goFor(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goTo":
                        motorService.goTo(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                    }
                  },
                  inputControllerByName : function(name) {
                    return theData.status.inputControllersMap.find(elem => elem[0] == name) || {}
                  },
                  filteredInputControllerList : function() {
                    // filters out WebGamepad
                    return theData.resources.filter(elem => {
                      return (
                        elem.namespace == 'rdk'
                        && elem.type == 'component'
                        && elem.subtype == 'input_controller'
                        && elem.name !== 'WebGamepad'
                      )})
                  },
                  inputInject: function(req) {
                    inputControllerService.injectEvent(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  pidCommand: function(motor,cmd){
                      let req = cmd.request;
                      req.setName(motor);
                      switch (cmd.type) {
                      case "gain":
                          motorService.setPIDConfig(req, {}, (err, resp) => grpcCallback(err, resp));

                          break;
                      case "step":
                        this.motorPIDStep(motor,req,cmd.chart,1)
                          break;
                      }
                  },
                  doAction : function(name) {
                      const req = new robotApi.DoActionRequest();
                      req.setName(name);
                      robotService.doAction(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  baseAction : function(name, action, amount) {
                      let req;
                      switch (action) {
                        case 'straight':
                          req = new robotApi.BaseMoveStraightRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          robotService.baseMoveStraight(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'arc':
                          req = new robotApi.BaseMoveArcRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          req.setAngleDeg(document.getElementById("angle").value);
                          robotService.baseMoveArc(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'angle':
                          req = new robotApi.BaseSpinRequest();
                          req.setName(name);
                          req.setDegsPerSec(document.getElementById("speed").value)
                          req.setAngleDeg(amount);
                          req.setAngleDeg(document.getElementById("angle").value * amount);
                          robotService.baseSpin(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  renderFrame : function(cameraName) {
                      req = new cameraApi.CameraServiceFrameRequest();
                      req.setName(cameraName);
                      const mimeType = 'image/png';
                      req.setMimeType(mimeType)
                      cameraService.frame(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        let blob = new Blob([resp.getFrame_asU8()], { type: mimeType });
                        window.open(URL.createObjectURL(blob), "_blank");
                      });
                  },
                  renderPCD : function(cameraName) {
                      theData.pcdClick.pcdloaded = false;
                      theData.pcdClick.foundSegments = false;
                      initPCDIfNeeded();
                      pcdGlobal.cameraName = cameraName;

                      req = new cameraApi.CameraServicePointCloudRequest();
                      req.setName(cameraName);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType)
                      cameraService.pointCloud(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        console.log("loading pcd");
                        theData.fullcloud = resp.getFrame_asB64();
                        pcdLoad(`data:${mimeType};base64,${theData.fullcloud}`);
                      });

                  },
                  doSensorReadings : function(name) {
                      var req = new robotApi.SensorReadingsRequest();
                      req.setName(name);
                      robotService.sensorReadings(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  processFunctionResults: function(err, resp) {
                    grpcCallback(err, resp, false)
                    if (err) {
                      document.getElementById("function_results").value = `${err}`;
                      return;
                    }
                    var results = resp.getResultsList();

                    let resultStr = '';
                    if (results.length > 0) {
                      resultStr += 'Results: \n';
                      for (let i = 0; i < results.length && i < results.length; i++) {
                        let result = results[i];
                        resultStr += `${i}: ${JSON.stringify(result.toJavaScript())}\n`;
                      }
                    }
                    resultStr += `StdOut: ${resp.getStdOut()}\n`;
                    resultStr += `StdErr: ${resp.getStdErr()}\n`;
                    document.getElementById("function_results").value = resultStr;
                  },
                  visualizeForceMatrix: function(name, id) {
                    document.getElementById('force-button-id-' + id).style.display = 'none';

                    // 2D animation stuff
                    let canvas2D = document.getElementById('force-2d-id-' + id);
                    var animation_stuff_2D = {
                      ctx: canvas2D.getContext('2d'),
                      squareWidth: 50,
                      maxPressure: 1,
                      canvasId: 'force-2d-id-' + id
                    }

                    // 3D animation stuff
                    var canvas3DWidth = 500;
                    var canvas3DHeight = 500;

                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color( 0xFBE7C6 );
                    const camera = new THREE.PerspectiveCamera(75, canvas3DWidth / canvas3DHeight, 0.1, 1000);

                    const renderer = new THREE.WebGLRenderer();
                    renderer.setSize(canvas3DWidth, canvas3DHeight);
                    var div_3d = document.getElementById('force-3d-id-' + id);
                    div_3d.appendChild(renderer.domElement);
                    camera.position.z = 6;
                    camera.position.y = -6;

                    var animation_stuff_3D = {
                      cubes: [],
                      scene: scene,
                      canvas3DHeight: canvas3DHeight,
                      canvas3DWidth: canvas3DWidth
                    }

                    // [kat] TODO(https://github.com/viamrobotics/rdk/issues/336): slip detection works locally, but not on app.viam.com
                    // Slip detection stuff
                    let slipCanvas = document.getElementById('slip-id-' + id);
                    var slip_animation_stuff = {
                      ctx: slipCanvas.getContext('2d')
                    }

                    // Allows moving the 3D scene using the mouse
                    controls = new trackLib.TrackballControls( camera, renderer.domElement);
                    controls.target.set( 0, 0, 0 )
                    controls.rotateSpeed = 1.0

                    let startedForceAnimation = false;
                    const timeInterval = 10; // in milliseconds
                    let req = new forceMatrixApi.ForceMatrixServiceMatrixRequest();
                    req.setName(name);

                    let slipReq = new forceMatrixApi.ForceMatrixServiceSlipDetectionRequest();
                    slipReq.setName(name);
                    
                    isFirstRender = true;
                    // Loop through grabbing data & visualizing it
                    setTimeout(async function getDataAndVisualizeIt(isFirstRender) {
                      let pResolve1;
                      let pReject1;
                      let p1 = new Promise((resolve, reject) => {
                        pResolve1 = resolve;
                        pReject1 = reject;
                      });
                      let pReject2;
                      let pResolve2;
                      let p2 = new Promise((resolve, reject) => {
                        pResolve2 = resolve;
                        pReject2 = reject;
                      });
                      forceMatrixService.matrix(req, {}, (err, resp) => {
                        if (err) {
                          pReject1(err);
                        }
                        pResolve1(null);
                        animateForceMatrix(err, resp, animation_stuff_2D, animation_stuff_3D, isFirstRender)
                      });
                      forceMatrixService.slipDetection(slipReq, {}, (err, resp) => {
                        if (err) {
                          pReject2(err);
                        }
                        pResolve2(null);
                        updateSlipDetectionResult(err, resp, slip_animation_stuff)
                      });
                      await p1;
                      await p2;

                      // Start the 3D game engine animation if it hasn't been started yet
                      if (!startedForceAnimation) {
                        startedForceAnimation = true;
                        function animate() {
                            requestAnimationFrame( animate );
                            controls.update()
                            renderer.render( scene, camera );
                        }
                        animate();
                      }

                      setTimeout(getDataAndVisualizeIt, timeInterval, false);
                    }, timeInterval, isFirstRender);
                  },
                  nonEmpty : function(d) {
                      for ( var k in d ) {
                          return true;
                      }
                      return false;
                  },
                  hasKey : function(d, key) {
                    if (!d) {
                      return false;
                    }
                    if (Array.isArray(d)) {
                      for (let i = 0; i < d.length; i++) {
                        if (d[i] == key || (d[i].length && d[i].length >= 1 && d[i][0] == key)) {
                          return true;
                        }
                      }
                      return false;
                    }
                    return d.hasOwn(key);
                  },
                  grabClick : function(e) {
                      var mouse = new THREE.Vector2();
                      mouse.x = ((e.offsetX / e.srcElement.offsetWidth) * 2) - 1
                      mouse.y = ((e.offsetY / e.srcElement.offsetHeight) * -2) + 1

	                  pcdGlobal.raycaster.setFromCamera( mouse, pcdGlobal.camera );

	                  var intersects = pcdGlobal.raycaster.intersectObjects( pcdGlobal.scene.children );
                      var p = ( intersects.length ) > 0 ? intersects[ 0 ] : null;

                      if ( p !== null ) {
                        console.log(p.point);
                        setPoint(p.point);
                      } else {
                        console.log("no point intersected");
                      }

                  },
                  doPCDGrab : function(){
                      let gripperName = theData.status.grippersMap[0][0];
                      let armName = theData.status.armsMap[0].name;
                      let cameraName = pcdGlobal.cameraName;
                      let cameraPointX = theData.pcdClick.x;
                      let cameraPointY = theData.pcdClick.y;
                      let cameraPointZ = theData.pcdClick.z;

                      let req = new robotApi.ObjectManipulationServiceDoGrabRequest();
                      let cameraPoint = new robotApi.Vector3();
                      cameraPoint.setX(cameraPointX);
                      cameraPoint.setY(cameraPointY);
                      cameraPoint.setZ(cameraPointZ);

                      req.setArmName(armName);
                      req.setCameraName(cameraName);
                      req.setCameraPoint(cameraPoint);
                      req.setGripperName(gripperName);
                      console.log("making grab attempt");
                      console.log(gripperName);

                      robotService.objectManipulationServiceDoGrab(req, {}, 
                        (err, resp) => {
                          grpcCallback(err, resp);
                          if (err) {
                            return Promise.reject(err);
                          }
                          return Promise.resolve(resp).then(console.log);
                      })
                  },
                  findSegments : function(minPointsPlane, minPointsSegment, clusteringRadius){
                      theData.pcdClick.calculatingSegments = true;
                      req = new cameraApi.CameraServiceObjectPointCloudsRequest();
                      console.log("camera name: "+pcdGlobal.cameraName);
                      req.setName(pcdGlobal.cameraName);
                      req.setMinPointsInPlane(minPointsPlane);
                      req.setMinPointsInSegment(minPointsSegment);
                      req.setClusteringRadius(clusteringRadius);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType);
                      console.log("finding object segments...");
                      cameraService.objectPointClouds(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          console.log("error getting segments");
                          theData.pcdClick.calculatingSegments = false;
                          return;
                        }
                        console.log("got pcd segments");
                        theData.pcdClick.foundSegments = true;
                        theData.objects = resp.getObjectsList();
                        theData.pcdClick.calculatingSegments = false;
                      });
                  },
                  doSegmentLoad : function(i){
                        var segment = theData.objects[i];
                        var data = segment.getFrame_asB64();
                        var center = segment.getCenter();
                        var box = segment.getBoundingBox();
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                        setBoundingBox(box, p);
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  doPointLoad : function(i){
                        var segment = theData.objects[i];
                        var center = segment.getCenter();
                        var p = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        console.log(p);
                        setPoint(p);
                  },
                  doBoundingBoxLoad : function(i){
                        var segment = theData.objects[i];
                        var center = segment.getCenter();
                        var box = segment.getBoundingBox();
                        var centerP = {x: center.getX()/1000., y: -center.getY()/1000., z: -center.getZ()/1000.};
                        setBoundingBox(box, centerP);
                  },
                  doPCDLoad : function(data){
                        const mimeType = 'pointcloud/pcd';
                        pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  setNavigationMode : function(mode){
                    let pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_UNSPECIFIED;
                    switch (mode) {
                      case 'manual':
                        pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_MANUAL;
                        break;
                      case 'waypoint':
                        pbMode = robotApi.NavigationServiceMode.NAVIGATION_SERVICE_MODE_WAYPOINT;
                        break;
                    }
                    var req = new robotApi.NavigationServiceSetModeRequest();
                    req.setMode(pbMode);
                    robotService.navigationServiceSetMode(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  setNavigationLocation: function(elId) {
                    const posSplit = document.getElementById(elId).value.split(",");
                    if (posSplit.length != 2) {
                      return;
                    }
                    const lat = parseFloat(posSplit[0]);
                    const lng = parseFloat(posSplit[1]);
                    var req = new robotApi.ResourceRunCommandRequest();
                    let gpsName = "";
                    for (let i = 0; i < theData.status.sensorsMap.length; i++) {
                      const s = theData.status.sensorsMap[i];
                      if (s[1].type === 'gps') {
                        gpsName = s[0];
                        break;
                      }
                    }
                    if (gpsName === "") {
                      theData.error = "no gps device found";
                      return;
                    }
                    req.setResourceName("gps1");
                    req.setCommandName("set_location");
                    req.setArgs(proto.google.protobuf.Struct.fromJavaScript({
                      latitude: lat,
                      longitude: lng,
                    }))
                    robotService.resourceRunCommand(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  viewCamera : function(name) {
                      const streamContainer = document.getElementById(`stream-${name}`);
                      const button = streamContainer.getElementsByTagName("button")[0];
                      button.disabled = true;
                      const req = new streamApi.AddStreamRequest();
                      req.setName(name);
                      streamService.addStream(req, {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          button.disabled = false;
                          return;
                        }
                      });
                  },
              },
              directives: {
                // TODO(https://github.com/viamrobotics/rdk/issues/406): replace with vue component after naveed work done
                mapMounted (el) {
                  if (theData.mapOnce) {
                    return;
                  }
                  theData.mapOnce = true;
                  initNavigation();
                }
              },
          })

          // query metadata service every 0.5s
          const queryMetadata = async function() {
            let pResolve;
            let pReject;
            let p = new Promise((resolve, reject) => {
              pResolve = resolve;
              pReject = reject;
            });
            metadataService.resources(new metadataApi.ResourcesRequest(), {}, function(err, resp) {
              grpcCallback(err, resp, false)
              if (err) {
                pReject(err);
                return;
              }
              resources = resp.toObject().resourcesList
              theData.resources = resources
              pResolve(null);
            });
            await p;
            setTimeout(() => queryMetadata(), 500);
          }

          // query stream service every 0.5s
          const streamServiceCallback = function(err, resp) {
            grpcCallback(err, resp, false)
            if (err) {
              return;
            }
            let streamNames = resp.toObject().namesList
            theData.streamNames = streamNames
          }
          const queryStreams = async function() {
            let pResolve;
            let pReject;
            let p = new Promise((resolve, reject) => {
              pResolve = resolve;
              pReject = reject;
            });
            streamService.listStreams(new streamApi.ListStreamsRequest(), {}, function(err, resp) {
              grpcCallback(err, resp, false)
              if (err) {
                pReject(err);
                return;
              }
              let streamNames = resp.toObject().namesList
              theData.streamNames = streamNames;
              pResolve(null);
            });
            await p;
            setTimeout(() => queryStreams(), 500);
          }

          const streamReq = new robotApi.StatusStreamRequest();
          streamReq.setEvery((new proto.google.protobuf.Duration()).setNanos(500000000)); // 500ms

          let statusStream;
          let lastStatusTS = Date.now();
          const checkInternvalMillis = 3000;
          const checkLastStatus = function() {
            if ((Date.now() - lastStatusTS) > checkInternvalMillis) {
              restartStatusStream();
              return
            }
            setTimeout(checkLastStatus, checkInternvalMillis)
          }

          const restartStatusStream = async function() {
            if (statusStream) {
              statusStream.cancel();
              try {
                console.log("reconnecting");
                await window.connect();
              } catch (e) {
                console.error("failed to reconnect; retrying:", e);
                setTimeout(() => restartStatusStream(), 1000);
              }
            }
            statusStream = robotService.statusStream(streamReq);
            let firstData = true;
            statusStream.on('data', function(response) {
              lastStatusTS = Date.now();
              updateStatus(response.getStatus());
              if (firstData) {
                firstData = false;
                checkLastStatus();
                queryMetadata();
                if (window.streamService) {
                  queryStreams();
                }
              }
            });
            statusStream.on('status', function(status) {
              console.log("error streaming robot status");
              console.log(status);
              console.log(status.code, " ", status.details);
            });
            statusStream.on('end', function(end) {
              console.log("done streaming robot status");
              setTimeout(() => restartStatusStream(), 1000);
            });
          }
          await restartStatusStream();
      }

      pcdGlobal = null;

      function initPCDIfNeeded() {
          if (pcdGlobal) {
              return
          }
          theData.pcdClick.enable = true;
          console.log("initing pcd");

          const sphereGeometry = new THREE.SphereGeometry( .009, 32, 32 );
          const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

          pcdGlobal = {
              scene : new THREE.Scene(),
              camera : new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 2000 ),
              renderer : new THREE.WebGLRenderer(),
              raycaster : new THREE.Raycaster(),
              sphere: new THREE.Mesh( sphereGeometry, sphereMaterial ),
          };

          pcdGlobal.renderer.setSize( window.innerWidth / 2, window.innerHeight / 2 );
          document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);

          pcdGlobal.controls = new orbitLib.OrbitControls( pcdGlobal.camera, pcdGlobal.renderer.domElement );
          pcdGlobal.camera.position.set( 0, 0, 0 );
          pcdGlobal.controls.target.set(0,0,-1);
          pcdGlobal.controls.update();
          pcdGlobal.camera.updateMatrix();

          console.log("pcd init done");
      }

      function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
                    renderer.setSize(width, height, false);
                  }
          return needResize;
        }

      function pcdAnimate() {
          if (resizeRendererToDisplaySize(pcdGlobal.renderer)) {
                    const canvas = pcdGlobal.renderer.domElement;
                    pcdGlobal.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    pcdGlobal.camera.updateProjectionMatrix();
          }
	      pcdGlobal.renderer.render( pcdGlobal.scene, pcdGlobal.camera );
          pcdGlobal.controls.update();
          requestAnimationFrame( pcdAnimate );
      }

      function pcdLoad(path) {
          var loader = new pcdLib.PCDLoader();
          loader.load(
              path,

            // called when the resource is loaded
            function ( mesh ) {
              pcdGlobal.scene.clear();
              pcdGlobal.scene.add( mesh );
              pcdGlobal.scene.add( pcdGlobal.sphere);
              if (pcdGlobal.cube) {
                pcdGlobal.scene.add(pcdGlobal.cube);
              }
              pcdAnimate();
            },
            // called when loading is in progresses
            function ( xhr ) {
              //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
              console.log(error);
            }
          );
          theData.pcdClick.pcdloaded = true;
      }

      function r(n) {
          return Math.round(n*1000);
      }

      function setPoint(point) {
          theData.pcdClick.x = r(point.x);
          theData.pcdClick.y = r(point.y);
          theData.pcdClick.z = r(point.z);
          pcdGlobal.sphere.position.copy(point);
      }

      function setBoundingBox(box, centerPoint) {
          const geometry = new THREE.BoxGeometry( box.getWidth()/1000., box.getLength()/1000., box.getDepth()/1000. );
          const edges = new THREE.EdgesGeometry( geometry );
          const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
          const cube = new THREE.LineSegments( edges, material );
          cube.position.copy(centerPoint);
          cube.name = "bounding-box";
          pcdGlobal.scene.remove(pcdGlobal.scene.getObjectByName("bounding-box"));
          pcdGlobal.cube = cube;
          pcdGlobal.scene.add(cube);
      }


      function animateForceMatrix(err, resp, anim_2D, anim_3D, isFirstRender) {
          grpcCallback(err, resp);
          if (err) {
            console.log("error getting force sensor readings: ", err);
            return;
          }
          var [numRows, numCols, data] = resp.getMatrix().array;
          if (data.length !== numRows * numCols || numRows === 0 || numCols === 0) {
            console.log("corrupt force sensor data");
            return;
          }

          const gradientRate = 10;
          const gradientHeight = 20;
          const gradientWidth = 40;
          const spaceBetweenTextAndGradient = 35;
          const offsetToLeftMatrix = 120;
          const offsetBetweenMatrices = 30;
          const squareSize = anim_2D.squareWidth

          let canvas2D = document.getElementById(anim_2D.canvasId);
          // if this is the first render, initialize the 2D and 3D scene
          if (isFirstRender || anim_3D.cubes.length == 0) {
            // let's add cubes to the 3D view
            for (let row = 0; row < numRows; row++) {
                cubeRow = []
                for (let col = 0; col < numCols; col++) {
                    const geometry = new THREE.BoxGeometry(1, 1, 0.1);
                    const material = new THREE.MeshBasicMaterial( { color: 0xffaebc} );
                    const cube = new THREE.Mesh( geometry, material );
                    cube.translateX((col - (numCols-1)/2) * 1.1);
                    cube.translateY((- row + (numRows-1)/2) * 1.1);
                    cubeRow.push(cube);
                    anim_3D.scene.add(cube);
                }
                anim_3D.cubes.push(cubeRow)

                // [Debug] This helps for debugging & understanding the 3D space:
                // var axesHelper = new THREE.AxesHelper( 5 );
                // anim_3D.scene.add( axesHelper );

            }
            // resize the canvas to fit any size of matrix
            canvas2D.height = Math.max(squareSize * numRows + 20, gradientRate * gradientHeight + 20);
            canvas2D.width = Math.max(2 * squareSize * numCols + offsetToLeftMatrix + offsetBetweenMatrices, anim_3D.canvas3DWidth + 100);
          }

          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              let pressure = data[row * numCols + col];
              if (pressure > anim_2D.maxPressure) {
                  anim_2D.maxPressure = pressure
              }

              // --- 2D animation stuff ---
              // Visualize gradient to the left of 2D animation stuff
              for (let g = 0; g < gradientRate; g++) {
                // Create colored boxes
                let greenShadeGradient = 255/gradientRate * g;
                anim_2D.ctx.fillStyle = 'rgb(0, ' + greenShadeGradient + ', 0)'; // old version with just green color
                anim_2D.ctx.fillRect(spaceBetweenTextAndGradient, g * gradientHeight, gradientWidth, gradientHeight);

                // Label the boxes
                anim_2D.ctx.fillStyle = 'white';
                anim_2D.ctx.fillRect(0, g * gradientHeight, spaceBetweenTextAndGradient, gradientHeight);
                anim_2D.ctx.fillStyle = 'black'
                anim_2D.ctx.font = '15px sans-serif';
                anim_2D.ctx.fillText(Math.floor(anim_2D.maxPressure/(gradientRate - 1) * g) ,0, gradientHeight * (g + 1));
              }

              // greenShade is the color used to represent the pressure in both the 2D and 3D visualization
              let greenShade = 255/anim_2D.maxPressure * pressure;

              let xPos = offsetToLeftMatrix + col * squareSize;
              let yPos = row * squareSize;
              let yTextOffset = 0.6 * squareSize;
              // Visualize black box with green colors indicating the pressure
              anim_2D.ctx.fillStyle = 'rgb(0, ' + greenShade + ', 0)';
              anim_2D.ctx.fillRect(xPos, yPos, squareSize, squareSize);

              // Inscribe raw pressure values in white
              anim_2D.ctx.fillStyle = 'white'
              anim_2D.ctx.font = '20px sans-serif';
              anim_2D.ctx.fillText(pressure, xPos, yPos + yTextOffset);


              let offsetToRightMatrix = offsetBetweenMatrices + numCols * squareSize;
              // Visualize pressure values only in a separate matrix for better reading of raw values
              anim_2D.ctx.fillStyle = 'white'
              anim_2D.ctx.fillRect(xPos + offsetToRightMatrix, yPos, squareSize, squareSize);
              anim_2D.ctx.fillStyle = 'black'
              anim_2D.ctx.strokeRect(xPos + offsetToRightMatrix, yPos, squareSize, squareSize);

              // Inscribe raw pressure values in black
              anim_2D.ctx.font = '20px sans-serif';
              anim_2D.ctx.fillText(pressure, xPos + offsetToRightMatrix, yPos + yTextOffset);

              // --- 3D animation stuff ---
              anim_3D.cubes[row][col].material.color.setRGB(0, greenShade/255, 0)
              anim_3D.cubes[row][col].scale.setZ(pressure/anim_2D.maxPressure * 14)
              anim_3D.cubes[row][col].position.setZ(0)
              anim_3D.cubes[row][col].translateZ(pressure/anim_2D.maxPressure * 7 * 0.1)
            }
          }
      }

      function updateSlipDetectionResult (err, resp, slip_animation_stuff) {
        grpcCallback(err, resp);
        if (err) {
          console.log("error getting slip detection readings: ", err);
          return;
        }

        if (resp === null) {
          slip_animation_stuff.ctx.fillStyle = 'orange';
          slip_animation_stuff.ctx.fillRect(0, 0, 200, 50)

          slip_animation_stuff.ctx.fillStyle = 'black'
          slip_animation_stuff.ctx.font = '20px sans-serif';
          slip_animation_stuff.ctx.fillText("response is invalid", 0, 0);
          console.log("response is null - this is an issue when running this in the cloud, but not on a device locally")
        }

        let isSlipping = resp.getIsSlipping()
        if (isSlipping) {
          slip_animation_stuff.ctx.fillStyle = 'red';
          slip_animation_stuff.ctx.fillRect(0, 0, 150, 50)

          slip_animation_stuff.ctx.fillStyle = 'white'
          slip_animation_stuff.ctx.font = '20px sans-serif';
          slip_animation_stuff.ctx.fillText("SLIPPING", 5, 25);
        } else {
          slip_animation_stuff.ctx.fillStyle = 'green';
          slip_animation_stuff.ctx.fillRect(0, 0, 150, 50)
          slip_animation_stuff.ctx.fillStyle = 'white'
          slip_animation_stuff.ctx.font = '20px sans-serif';
          slip_animation_stuff.ctx.fillText("NOT SLIPPING", 5, 25);
        }
      }

      async function doConnect(creds, onError) {
        console.debug("connecting");
        document.getElementById("connecting-error").innerHTML = "";
        document.getElementById("connecting").classList.add("connecting");
        try {
            await window.connect(creds);
        } catch (e) {
          const msg = `failed to connect: ${e}`;
          console.error(msg);
          document.getElementById("connecting-error").innerHTML = msg;
          document.getElementById("connecting").classList.remove("connecting");
          if (onError) {
            setTimeout(onError, 1000);
          }
          return;
        }
        console.debug("connected");
        document.getElementById("pre-app").classList.add("connected");
        await startup();
      }

      async function waitForClientAndStart() {
        if (window.supportedAuthTypes.length == 0) {
          doConnect(undefined, waitForClientAndStart);
          return;
        }

        const authElems = [];
        const disableAll = () => {
          for (elem of authElems) {
            elem.disabled = true;
          }
        };
        const enableAll = () => {
          for (elem of authElems) {
            elem.disabled = false;
          }
        };
        for (authType of window.supportedAuthTypes) {
          const authDiv = document.getElementById(`auth-${authType}`);
          const input = authDiv.getElementsByTagName('input')[0];
          const button = authDiv.getElementsByTagName('button')[0];
          authElems.push(input, button);
          const doLogin = () => {
            disableAll();
            const creds = { type: authType, payload: input.value };
            doConnect(creds, () => enableAll());
          }
          button.addEventListener("click", () => doLogin());
          input.addEventListener("keyup", (event) => {
            if (event.keyCode !== 13) {
              return;
            }
            doLogin();
          });
        }
      }

      async function initNavigation() {
        await mapReady;
        window.map = new google.maps.Map(document.getElementById("map"), {zoom: 18});
        window.map.addListener("click", (e) => {
          var req = new robotApi.NavigationServiceAddWaypointRequest();
          var point = new robotApi.GeoPoint();
          point.setLatitude(e.latLng.lat());
          point.setLongitude(e.latLng.lng());
          req.setLocation(point);
          robotService.navigationServiceAddWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
        });

        let centered = false;
        const knownWaypoints = {};
        let localLabelCounter = 0;
        const updateWaypoints = function() {
          var req = new robotApi.NavigationServiceWaypointsRequest();
          robotService.navigationServiceWaypoints(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateWaypoints, 1000);
              return;
            }
            let waypoints = [];
            if (resp) {
              waypoints = resp.getWaypointsList();
            }
            const currentWaypoints = {};
            for (var i = 0; i < waypoints.length; i++) {
              const waypoint = waypoints[i];
              const pos = {lat: waypoint.getLocation().getLatitude(), lng: waypoint.getLocation().getLongitude()};
              const posStr = JSON.stringify(pos);
              if (knownWaypoints[posStr]) {
                currentWaypoints[posStr] = knownWaypoints[posStr];
                continue;
              }
              const marker = new google.maps.Marker({
                position: pos,
                map: window.map,
                label: `${localLabelCounter++}`,
              });
              currentWaypoints[posStr] = marker;
              knownWaypoints[posStr] = marker;
              marker.addListener("click", () => {
                console.log("clicked on marker", pos)
              });
              marker.addListener("dblclick", () => {
                var req = new robotApi.NavigationServiceRemoveWaypointRequest();
                req.setId(waypoint.getId());
                robotService.navigationServiceRemoveWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
              });
            }
            const waypointsToDelete = Object.keys(knownWaypoints).filter(elem => {
              return !(elem in currentWaypoints)
            });
            for (key of waypointsToDelete) {
              const marker = knownWaypoints[key];
              marker.setMap(null);
              delete knownWaypoints[key];
            }
            setTimeout(updateWaypoints, 1000);
          });
        }
        updateWaypoints();

        const locationMarker = new google.maps.Marker({label: "robot"});
        const updateLocation = function() {
          var req = new robotApi.NavigationServiceLocationRequest();
          robotService.navigationServiceLocation(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateLocation, 1000);
              return;
            }
            const pos = {lat: resp.getLocation().getLatitude(), lng: resp.getLocation().getLongitude()};
            if (!centered) {
              centered = true;
              window.map.setCenter(pos);
            }
            locationMarker.setPosition(pos);
            locationMarker.setMap(window.map);
            setTimeout(updateLocation, 1000);
          });
        }
        updateLocation();
      }

      function initMap() {
        mapReadyResolve();
      }

      let mapReadyResolve;
      let mapReady = new Promise(resolve => {
        mapReadyResolve = resolve;
      });
    </script>
  </head>
  <body onLoad="waitForClientAndStart()" style="background: var(--black-10);">
    <div id="pre-app">
      <div id="connecting-error"></div>
      <div id="connecting">Connecting via {{ if .WebRTCEnabled }}WebRTC{{ else }}gRPC{{ end }}...</div>
      {{range $authType := .SupportedAuthTypes }}    
          <span>{{ $authType }}: </span>
          <div id="auth-{{ $authType }}">
            <input type="password"/>
            <button>Login</button>
          </div>
      {{ end }}
    </div>
    <div id="app" v-cloak>
      <div id="actions">
        {{range $r := .Actions}}
        <button v-on:click="doAction('{{$r}}')">{{$r}}</button>
        {{end}}
      </div>

      <div style="color: red">${ error }</div>

      <!-- ******* BASE *******  -->
      <div class="base" v-for="base in status.basesMap" :key="base[0]">
        <h3>${base[0]}</h3>
        <ul>
          <li><button v-on:click="baseAction(base[0], 'straight', 1)">Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'straight', -1)">Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'arc', 1)">Arc Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'arc', -1)">Arc Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', 1)">Spin Clockwise</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', -1)">Spin Counterclockwise</button></li>
        </ul>

        Speed (mm per sec): <input id="speed" name="speed" value="300"/><br>
        Distances (mm): <input id="distance" name="distance" value="500"/><br>
        Angle (degree): <input id="angle" name="angle" value="0"/><br>
      </div>

      <!-- ******* GANTRY *******  -->
      <div class="gantry" v-for="gantry in filterResources('rdk', 'component', 'gantry')" :key="gantry.name">
        <h3>Gantry ${gantry.name}</h3>
        <table>
          <tr>
            <th>axis</th>
            <th>position</th>
            <th>length</th>
          </tr>
          <tr v-for="pp in gantryByName(gantry.name).parts" :key="pp.axis">
            <th>${pp.axis}</th>
            <td>
              <button v-on:click="gantryInc( gantry.name, pp.axis, -.1 )">--</button>
              <button v-on:click="gantryInc( gantry.name, pp.axis, -.01 )">-</button>
              <button v-on:click="gantryInc( gantry.name, pp.axis, .01 )">+</button>
              <button v-on:click="gantryInc( gantry.name, pp.axis, .1 )">++</button>
            </td>
            <td>${pp.pos}</td>
            <td>${pp.length}</td>
          </tr>
        </table>
      </div>

      <!-- ******* ForceMatrix *******  -->
      <div>
        <div v-for="(forcematrix, x) in filterResources('rdk', 'component', 'forcematrix').entries()" :key="forcematrix[1].name">
          <hr>
          <h2>ForceMatrix: ${forcematrix[1].name}</h2>
          <template>
            <button :id="'force-button-id-' + x" v-on:click="visualizeForceMatrix(forcematrix[1].name, x)">Visualize Force Matrix</button>
            <!-- force 2d canvas element is resized later upon arrival of sensor data (see animateForceMatrix)  -->
            <canvas :id="'force-2d-id-' + x" width="100" height="100" style="margin-top: 20px;"></canvas>
            <canvas :id="'slip-id-' + x" width="200" height="50"></canvas>
            <div :id="'force-3d-id-' + x"></div>
          </template>
        </div>
        <hr>
      </div>
      
      <!-- ******* ARM *******  -->
      <div class="arm" v-for="arm in filterResources('rdk', 'component', 'arm')" :key="arm.name">
        <h3>Arm ${arm.name}</h3>
        <table v-if="armToggle[arm.name]" border="1">
          <tr>
            <th colspan="2"><h5>GRID (mms)</h5></th>
            <th colspan="2"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armToggle[arm.name].pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td><input v-model="aa.gridValue"></td>

            <th>Joint ${aa.joint}</th>
            <td><input v-model="aa.jointValue"></td>
          </tr>
          <tr>
            <th colspan="6">
              <button v-on:click="armModifyAllDoGrid(arm.name)">Go To Grid</button>
              <button v-on:click="armModifyAllDoJoint(arm.name)">Go To Joints</button>
              <button v-on:click="armModifyAllCancel(arm.name)">Cancel</button>
            </th>
          </tr>
        </table>
        <table border="1" v-else>
          <tr>
            <th colspan="3"><h5>GRID (mms)</h5></th>
            <th colspan="3"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armByName(arm.name).pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -10 )">--</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -1 )">-</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 1 )">+</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 10 )">++</button>
            </td>
            <td>${aa.gridValue.toFixed(2)}</td>

            <th>Joint ${aa.joint}</th>
            <td>
              <button v-on:click="armJointInc( arm.name, aa.joint, -10 )">--</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, -1 )">-</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 1 )">+</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 10 )">++</button>
            </td>
            <td>${aa.jointValue.toFixed(2)}</td>
          </tr>
          <tr>
            <th colspan="8">
              <button v-on:click="armHome(arm.name)">Home</button>
              <button v-on:click="armModifyAll(arm.name)">Modify All</button>
            </th>
          </tr>
        </table> <!-- end main table -->
      </div>

      <!-- ******* GRIPPER *******  -->
      <div class="gripper" v-for="gripper in filterResources('rdk', 'component', 'gripper')" :key="gripper.name">
        <h3>Gripper ${ gripper.name }</h3>
        <ul>
          <li><button v-on:click="gripperAction( gripper.name, 'open')">Open</button></li>
          <li><button v-on:click="gripperAction( gripper.name, 'grab')">Grab</button></li>
        </ul>
      </div>

      <!-- ******* SERVO *******  -->
      <div class="servo" v-for="servo in filterResources('rdk', 'component', 'servo')" :key="servo.name" style="margin-bottom: 64px;">
        <h3>Servo ${ servo.name }</h3>
        <table border="1">
          <tr><th>Angle</th><td>${servo.angle}</td></tr>
          <tr>
            <td></td>
            <td>
              <button v-on:click="servoMove(servo.name, -10)">-10</button>
              <button v-on:click="servoMove(servo.name, -1)">-1</button>
              <button v-on:click="servoMove(servo.name, 1)">1</button>
              <button v-on:click="servoMove(servo.name, 10)">10</button>
            </td>
          </tr>
        </table>
      </div>

      <!-- ******* MOTOR *******  -->
      <motor-detail
        v-for="motor in status.motorsMap"
        :key="'new-' + motor[0]"
        v-bind:motor-name="motor[0]"
        v-bind:motor-status="motor[1]"
        v-on:execute="motorCommand(motor[0], $event)"
        v-on:pid="pidCommand(motor[0],$event)"
        style="max-width: 1080px;">
      </motor-detail>

      <!-- ******* INPUT VIEW *******  -->
      <input-controller
        v-for="controller in filteredInputControllerList()"
        :key="'new-' + controller.name"
        v-bind:controller-name="controller.name"
        v-bind:controller-status="inputControllerByName(controller.name)[1]"
        style="max-width: 1080px;">
      </input-controller>

      <!-- ******* WEB CONTROLS *******  -->
      <web-gamepad
        v-if="filterResources('rdk', 'component', 'input_controller').length !== 0 && Object.keys(inputControllerByName('WebGamepad')).length !== 0"
        v-on:execute="inputInject($event)"
        style="max-width: 1080px;">
      </web-gamepad>

      <!-- ******* CAMERAS *******  -->
      <div class="camera" v-for="streamName in streamNames" :key="streamName">
        <h3>Camera ${streamName}</h3>
        <div :id="'stream-' + streamName">
          <button v-on:click="viewCamera(streamName)">View</button>
        </div>
      </div>

      <!-- ******* BOARD *******  -->
      <div class="board" v-for="board in filterResources('rdk', 'component', 'board')" key="board.name">
        <h3>Board ${board.name}</h3>
        <table border="1">

          <tr><th colspan="2">Analogs</th></tr>
          <tr v-for="a in boardByName(board.name).analogsMap" :key="a[0]">
            <th>${a[0]}</th>
            <td>${a[1].value}</td>
          </tr>

          <tr><th colspan="2">DigitalInterrupts</th></tr>
          <tr v-for="di in boardByName(board.name).digitalInterruptsMap" :key="di[0]">
            <th>${di[0]}</th>
            <td>${di[1].value}</td>
          </tr>
        </table>
      </div>
      <!-- end boards -->

      <!-- cameras -->
      <table border="1" v-if="nonEmpty(filterResources('rdk', 'component', 'camera'))">
        <tr>
          <th colspan="3">
            Cameras
          </th>
        </tr>
        <tr>
          <th>Name</th>
          <th>Frame</th>
          <th>PCD</th>
        </tr>
        <tr v-for="camera in filterResources('rdk', 'component', 'camera')">
          <td>${camera.name}</td>
          <td><a href="#" v-on:click.prevent="renderFrame(camera.name)">frame</a></td>
          <td><button v-on:click="renderPCD(camera.name)">GO</button></td>
        </tr>
      </table>

      <table border=1 v-if="nonEmpty(status.sensorsMap)">
        <tr>
          <th colspan="2">Sensors</th>
        </tr>

        <tr>
          <th>Name</th>
          <th>Type</th>
        </tr>

        <tr v-for="(sensor, x) in status.sensorsMap">
          <td>${sensor[0]}</td>
          <td>${sensor[1].type}</td>
          <td>
            <button v-on:click="doSensorReadings(sensor[0])">Get Readings</button>
          </td>
        </tr>

      </table>

      <div id="pcd_wrapper">
        <table>
          <tr>
            <td><div id="pcd" v-on:click="grabClick"/></td>
            <td v-if="pcdClick.enable">
              <table>
                <tr>
                  <th colspan=2>
                    Clicked On
                  </th>
                </tr>
                <tr>
                  <th>X</th>
                  <td>${pcdClick.x}</td>
                </tr>
                <tr>
                  <th>Y</th>
                  <td>${pcdClick.y}</td>
                </tr>
                <tr>
                  <th>Z</th>
                  <td>${pcdClick.z}</td>
                </tr>
                <tr>
                  <td colspan=2>
                    <button v-on:click="doPCDGrab">Grab</button>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>
      </div> <!-- end pcd wrapper -->
      <!-- get segments -->
      <table v-if="pcdClick.pcdloaded">
        <tr>
          <td colspan=2>
              Min Pts in Plane: <input type="number" id="minPtsPlane" min="0"  v-model="minPtsPlane"><br>
              Min Pts in Segment: <input type="number" id="minPtsSegment" min="0" v-model="minPtsSegment"><br>
              Clustering Radius (mm): <input type="number" id="clusterRad" min="0" v-model="clusterRad"><br>
          </td>
        </tr>
        <tr>
            <td>
                <button v-on:click="findSegments(minPtsPlane, minPtsSegment, clusterRad)">Find Segments</button>
            </td>
            <td v-if="pcdClick.calculatingSegments">Finding...</td>
        </tr>
      </table>
      <table v-if="pcdClick.foundSegments">
        <tr>
          <th>Object</th>
          <th>PCD</th>
          <th>Point</th>
          <th>Bounding Box</th>
        </tr>
        <tr>
          <td>Full Image</td>
          <td><button v-on:click="doPCDLoad(fullcloud)">GO</button></td>
          <td>--</td>
        </tr>
        <tr v-for="(seg, i) in objects">
            <td>Object ${i}</td>
            <td><button v-on:click="doSegmentLoad(i)">GO</button></td>
            <td><button v-on:click="doPointLoad(i)">GO</button></td>
            <td><button v-on:click="doBoundingBoxLoad(i)">GO</button></td>
        </tr>
      </table>
      <div id="map-container" v-if="hasKey(status.servicesMap, 'navigation')">
        <br />
        <br />
        <button v-on:click="setNavigationMode('manual')">Manual</button>
        <button v-on:click="setNavigationMode('waypoint')">Waypoint</button>
        <br />
        <input type="text" id="nav-set-location" value="40.745297,-74.010916">
        <button v-on:click="setNavigationLocation('nav-set-location')">Try Set Location</button>
        <div id="map" v-map-mounted></div>
      </div>
    </div> <!-- end vue app -->

    <!-- TODO(https://github.com/viamrobotics/rdk/issues/202): remove api key once going into production -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBn72TEqFOVWoj06cvua0Dc0pz2uvq90nY&callback=initMap&libraries=&v=weekly"
      async
    ></script>
  </body>
</html>
