<html>
  <head>
    <style type="text/css" media="screen">
      #source {
        position: relative;
        width: 50%;
        height: 50%;
      }
      #map {
        height: 400px;
        width: 100%;
      }
      [v-cloak] { display: none; }
      #pre-app.connected { display: none; }
      #connecting { display: none; }
      #connecting.connecting { display: block; }
     #connecting-error { color: red };
     h3 {
       margin: 0.1em;
       margin-block-end: 0.1em;
     }
    </style>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
    <script>
      window.webrtcEnabled = {{ .WebRTCEnabled }}
      window.webrtcHost = {{ .WebRTCHost }}
      window.webrtcSignalingAddress = {{ .WebRTCSignalingAddress }}
      window.webrtcAdditionalICEServers = {{ .WebRTCAdditionalICEServers }}
      window.bakedAuth = {{ .BakedAuth }} || {};
      window.supportedAuthTypes = {{ .SupportedAuthTypes }} || [];
    </script>
    {{ if .External }}
    <script src="/static/rdk/control.js"></script>
    <script src="/static/rdk/third-party/vue.js"></script>
    <link rel="stylesheet" href="/static/rdk/dls/dls.css">
    <script type="module">
      import "/static/rdk/dls/dls.umd.min.js";
    </script>
    {{ else }}
    <script src="/static/control.js"></script>
    <script src="/static/third-party/vue.js"></script>
    <link rel="stylesheet" href="/static/dls/dls.css">
    <script type="module">
      import "/static/dls/dls.umd.min.js";
    </script>
    {{ end }}
    <script>
      function roundTo2Decimals(num) {
          num = Math.round(num * 100);
          return num / 100;
      }

      function grpcCallback(err, resp, stringify) {
        if (err) {
          theData.error = JSON.stringify(err);
          return;
        }
        if (stringify === undefined || stringify) {
          try {
            if (resp.toJavaScript) {
              theData.res = JSON.stringify(resp.toJavaScript());
            } else {
              theData.res = JSON.stringify(resp.toObject());
            }
          } catch (e) {
            theData.error = JSON.stringify(e);
          }
        }
      }

      function fixArmStatus(old) {
        var newStatus = { pieces : [] };
        var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["theta", "Theta"], ["o_x", "OX"], ["o_y", "OY"], ["o_z", "OZ"]];
        for (var j=0; j<fieldSetters.length; j++ ){
            let endPositionField = fieldSetters[j][0];
            newStatus.pieces.push(
              { 
                endPosition : fieldSetters[j],
                endPositionValue : old["end_position"][endPositionField] || 0,
                joint : j,
                jointValue : old["joint_positions"]["degrees"][j] || 0,
              }
            );
        }
        return newStatus
      }

      function fixBoardStatus(old) {
        var newStatus = {
            analogsMap : old["analogs"] || [],
            digitalInterruptsMap : old["digital_interrupts"] || [],
        };
        return newStatus
      }
 
      function fixGantryStatus(old) {
        var newStatus = { parts: [] };
        if (old["lengths_mm"].length != old["positions_mm"].length) {
            throw "gantry lists different lengths";
        }

        for ( var i=0; i < old["lengths_mm"].length; i++) {
          newStatus.parts.push({axis: i, pos: old["positions_mm"][i], length: old["lengths_mm"][i]});
        }
        return newStatus
      }

      function fixInputStatus(old) {
        let events = old["events"] || []
        let eventsList = events.map(
          e => {
            return {
              time: e["time"] || {},
              event: e["event"] || "",
              control: e["control"] || "",
              value: e["value"] || 0.0,
            }
          })
        return { eventsList: eventsList}
      }

      function fixMotorStatus(old) {
        return {
          isOn: old["is_on"] || false,
          positionReporting: old["position_reporting"] || false,
          position: old["position"] || 0,
        };
      }
     
      function fixServoStatus(old) {
        return { positionDeg: old["position_deg"] || 0 };
      }

      function fixRawStatus(name, status) {
        switch (theApp.resourceNameToSubtypeString(name)){
          // TODO (RDK-127): generate these using constants
          case "rdk:component:arm":
            status = fixArmStatus(status)
            break;
          case "rdk:component:board":
            status = fixBoardStatus(status)
            break;
          case "rdk:component:gantry":
            status = fixGantryStatus(status)
            break;
            case "rdk:component:input_controller":
            status = fixInputStatus(status)
            break;
          case "rdk:component:motor":
            status = fixMotorStatus(status)
            break;
          case "rdk:component:servo":
            status = fixServoStatus(status)
            break;
        }
        return status
      }
     
      firstResult = true;
      async function updateStatus(grpcStatus) {
        var rawStatus = {}
        var status = {}

        grpcStatus.forEach(
          s => {
            let nameObj = s.getName().toObject()
            let statusJs = s.getStatus().toJavaScript()
            let fixed = fixRawStatus(nameObj, statusJs)

            let nameStr = theApp.resourceNameToString(nameObj)
            rawStatus[nameStr] = statusJs
            status[nameStr] = fixed
          }
        )

        theData.rawStatus = rawStatus;
        theData.status = status;
      }

      async function startup() {
          theData = {
              error : "",
              res : {},
              rawStatus : {},
              status : {},
              pcdClick : {},
              sensorReadings: {},
              resources: [],
              sensorNames: [],
              streamNames: [],
	      segmenterNames: [],
	      segmenterParameterNames: [],
	      segmenterParameters: {},
	      segmentAlgo: "",
              fullcloud: null,
              objects: null,
              minPtsPlane : 10000,
              minPtsSegment: 100,
              clusterRad: 5,
              armToggle : {},
              mapOnce: false,
              value: 0,
              imuData: {}
          };
          theApp = new Vue({
              el: '#app',
              delimiters: ['${', '}'],
              data: theData,
              components: {},
              methods : {
                  parameterType : function(typeName) {
                      if (typeName == "int" || typeName == "float64") {
                          return "number";
                      } else if (typeName == "string" || typeName == "char") {
                          return "text";
                      }
                      return "";
                  },
                  getSegmenterNames :  function() {
                      let req = new objectSegmentationApi.GetSegmentersRequest();
                      objectSegmentationService.getSegmenters(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          console.log("error getting segmenter names");
                          console.log(err);
                          return;
                        }
                        theData.segmenterNames = resp.getSegmentersList();
                      });
                  },
                  getSegmenterParameters : function(name) {
                    let req = new objectSegmentationApi.GetSegmenterParametersRequest();
                    req.setSegmenterName(name);
                    objectSegmentationService.getSegmenterParameters(req,  {}, (err, resp) => {
                      grpcCallback(err, resp, false)
                      if (err) {
                        console.log("error getting segmenter parameters for "+name);
                        console.log(err);
                        return;
                      }
                      theData.segmenterParameterNames = resp.getParametersList();
                      theData.segmenterParameters = {};
                    });
                  },
                  filterResources : function(namespace, type, subtype) {
                    return theData.resources.filter(elem => {
                      return elem.namespace == namespace && elem.type == type && elem.subtype == subtype
                    })
                  },
                  resourceNameToSubtypeString : function(name) {
                    return `${name.namespace}:${name.type}:${name.subtype}`
                  },
                  resourceNameToString : function(name) {
                    strName = theApp.resourceNameToSubtypeString(name)
                    if (name.name !== "") {
                      strName += `/${name.name}`
                    }
                    return strName
                  },
                  stringToResourceName : function(nameStr) {
                    let nameParts = nameStr.split("/")
                    let name = ""
                    if (nameParts.length === 2){
                      name = nameParts[1]
                    } else if (nameParts.length === 2) {
                      throw "more than one backslash in resource name string"
                    }
                    let subtypeParts = nameParts[0].split(":")
                    if (subtypeParts.length > 3) {
                      throw "more than 2 colons in resource name string"
                    }
                    if (subtypeParts.length < 3){
                     throw "less than 2 colons in resource name string"
                    }
                    return {namespace: subtypeParts[0], type: subtypeParts[1], subtype: subtypeParts[2], name: name}
                  },
                  resourceStatusByName : function(name) {
                    return theData.status[theApp.resourceNameToString(name)]
                  },
                  rawResourceStatusByName : function(name) {
                    return theData.rawStatus[theApp.resourceNameToString(name)]
                  },
                  gantryInc : function(name, axis, amount) {
                      var g = theApp.resourceStatusByName(name)
                      var pos = [];
                      for ( var i=0; i < g.parts.length; i++) {
                          pos[i] = g.parts[i].pos;
                      }
                      pos[axis] += amount;

                      const req = new gantryApi.MoveToPositionRequest();
                      req.setName(name.name);
                      req.setPositionsMmList(pos);
                      gantryService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armEndPositionInc : function(name, getterSetter, amount) {
                    if (getterSetter[0] == 'o' || getterSetter[0] == 'O') {
                        amount /= 100;
                    }
                    const arm = theApp.rawResourceStatusByName(name);
                    let old = arm["end_position"]
                    var newPose = new commonApi.Pose()
                    var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["theta", "Theta"], ["o_x", "OX"], ["o_y", "OY"], ["o_z", "OZ"]];
                    for (var j=0; j<fieldSetters.length; j++ ){
                        let endPositionField = fieldSetters[j][0];
                        let endPositionValue = old[endPositionField] || 0
                        const setter = `set${fieldSetters[j][1]}`;
                        newPose[setter](endPositionValue);
                    }

                    const getter = `get${getterSetter}`;
                    const setter = `set${getterSetter}`;
                    newPose[setter](newPose[getter]() + amount);
                    const req = new armApi.MoveToPositionRequest();
                    req.setName(name.name);
                    req.setTo(newPose);
                    armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armJointInc : function(name, field, amount) {
                    const arm = theApp.rawResourceStatusByName(name);
                    let old = arm["joint_positions"]
                    var newPositionDegs = new armApi.JointPositions()
                    var newList = arm["joint_positions"]["degrees"]
                    newList[field] += amount;
                    newPositionDegs.setDegreesList(newList);
                    const req = new armApi.MoveToJointPositionsRequest();
                    req.setName(name.name);
                    req.setPositionDegs(newPositionDegs);
                    armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armHome : function(name) {
                    const arm = theApp.rawResourceStatusByName(name);
                    let old = arm["joint_positions"]
                    var newPositionDegs = new armApi.JointPositions()
                    var newList = arm["joint_positions"]["degrees"]
                    for (var i = 0; i < newList.length; i++) {
                      newList[i] = 0;
                    }
                    newPositionDegs.setDegreesList(newList);
                    const req = new armApi.MoveToJointPositionsRequest();
                    req.setName(name.name);
                    req.setPositionDegs(newPositionDegs);
                    armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  armModifyAll : function(name) {
                    const arm = theApp.resourceStatusByName(name);
                    var n = { pieces : [] };

                    for ( var i=0; i < arm.pieces.length; i++) {
                        n.pieces.push( {
                            endPosition : arm.pieces[i].endPosition,
                            endPositionValue : roundTo2Decimals(arm.pieces[i].endPositionValue),
                            joint : arm.pieces[i].joint,
                            jointValue : roundTo2Decimals(arm.pieces[i].jointValue),
                        });
                    }
                    theData.armToggle[name.name] = n;
                  },
                  armModifyAllCancel : function(name) {
                    delete theData.armToggle[name.name];
                  },
                  armModifyAllDoEndPosition : function(name) {
                    var newPose = new commonApi.Pose()
                    var newPieces = theData.armToggle[name.name].pieces;

                    for (var i=0; i < newPieces.length; i++) {
                        var getterSetter = newPieces[i].endPosition[1];
                        const setter = `set${getterSetter}`;
                        newPose[setter](newPieces[i].endPositionValue);
                    }

                    const req = new armApi.MoveToPositionRequest();
                    req.setName(name.name);
                    req.setTo(newPose);
                    armService.moveToPosition(req, {}, (err, resp) => grpcCallback(err, resp));
                    delete theData.armToggle[name.name];
                  },
                  armModifyAllDoJoint : function(name) {
                    const arm = theApp.rawResourceStatusByName(name);
                    var newPositionDegs = new armApi.JointPositions()
                    var newList = arm["joint_positions"]["degrees"]

                    var newPieces = theData.armToggle[name.name].pieces;
                    for (var i=0; i < newPieces.length && i < newList.length; i++) {
                        newList[newPieces[i].joint] = newPieces[i].jointValue;
                    }

                    newPositionDegs.setDegreesList(newList);
                    const req = new armApi.MoveToJointPositionsRequest();
                    req.setName(name.name);
                    req.setPositionDegs(newPositionDegs);
                    armService.moveToJointPositions(req, {}, (err, resp) => grpcCallback(err, resp));
                    delete theData.armToggle[name.name];
                  },

                  gripperAction : function(name, action) {
                      let req;
                      switch (action) {
                        case 'open':
                          req = new gripperApi.OpenRequest();
                          req.setName(name);
                          gripperService.open(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'grab':
                          req = new gripperApi.GrabRequest();
                          req.setName(name);
                          gripperService.grab(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  servoMove : function(name, amount) {
                    const servo = theApp.rawResourceStatusByName(name);
                    var oldAngle = servo["position_deg"] || 0;
                    let angle = oldAngle + amount;
                    const req = new servoApi.MoveRequest();
                    req.setName(name.name);
                    req.setAngleDeg(angle);
                    servoService.move(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  motorCommand: function(motor, cmd) {
                    let req = cmd.request;
                    req.setName(motor);

                    switch (cmd.type) {
                      case "go":
                        motorService.setPower(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goFor":
                        motorService.goFor(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                      case "goTo":
                        motorService.goTo(req, {}, (err, resp) => grpcCallback(err, resp));
                        break;
                    }
                  },
                  hasWebGamepad : function() {
                    // TODO (RDK-127): replace these with constants
                    return theData.resources.some(elem => 
                      elem.namespace == 'rdk'
                      && elem.type == 'component'
                      && elem.subtype == 'input_controller'
                      && elem.name == 'WebGamepad'
                    )
                  },
                  filteredInputControllerList : function() {
                    // TODO (RDK-127): replace these with constants
                    // filters out WebGamepad
                    return theData.resources.filter(elem => {
                      return (
                        elem.namespace == 'rdk'
                        && elem.type == 'component'
                        && elem.subtype == 'input_controller'
                        && elem.name !== 'WebGamepad'
                      )})
                  },
                  inputInject: function(req) {
                    inputControllerService.triggerEvent(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  doAction : function(name) {
                      const req = new robotApi.DoActionRequest();
                      req.setName(name);
                      robotService.doAction(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  baseAction : function(name, action, amount) {
                      let req;
                      switch (action) {
                        case 'straight':
                          req = new baseApi.MoveStraightRequest();
                          req.setName(name);
                          req.setMmPerSec(document.getElementById("speed").value)
                          req.setDistanceMm(document.getElementById("distance").value * amount);
                          baseService.moveStraight(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'arc':
                          req = new baseApi.MoveArcRequest();
                          req.setName(name);
                          req.setMmPerSec(document.getElementById("speed").value)
                          req.setDistanceMm(document.getElementById("distance").value * amount);
                          req.setAngleDeg(document.getElementById("angle").value);
                          baseService.moveArc(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                        case 'angle':
                          req = new baseApi.SpinRequest();
                          req.setName(name);
                          req.setDegsPerSec(document.getElementById("speed").value)
                          req.setAngleDeg(document.getElementById("angle").value * amount);
                          baseService.spin(req, {}, (err, resp) => grpcCallback(err, resp));
                          break;
                      }
                  },
                  renderFrame : function(cameraName) {
                      req = new cameraApi.RenderFrameRequest();
                      req.setName(cameraName);
                      const mimeType = 'image/jpeg';
                      req.setMimeType(mimeType)
                      cameraService.renderFrame(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        let blob = new Blob([resp.getData_asU8()], { type: mimeType });
                        window.open(URL.createObjectURL(blob), "_blank");
                      });
                  },
                  renderPCD : function(cameraName) {
                      theData.pcdClick.pcdloaded = false;
                      theData.pcdClick.foundSegments = false;
                      initPCDIfNeeded();
                      pcdGlobal.cameraName = cameraName;

                      req = new cameraApi.GetPointCloudRequest();
                      req.setName(cameraName);
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType)
                      cameraService.getPointCloud(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        console.log("loading pcd");
                        theData.fullcloud = resp.getPointCloud_asB64();
                        pcdLoad(`data:${mimeType};base64,${theData.fullcloud}`);
                      });

                  },
                  getReadings : function(sensorNames) {
                      var req = new sensorsApi.GetReadingsRequest();
                      let names = sensorNames.map(name => {
                        let resourceName = new commonApi.ResourceName()
                        resourceName.setUuid(name.uuid)
                        resourceName.setNamespace(name.namespace)
                        resourceName.setType(name.type)
                        resourceName.setSubtype(name.subtype)
                        resourceName.setName(name.name)
                        return resourceName
                      })
                      req.setSensorNamesList(names);
                      sensorsService.getReadings(req, {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          return;
                        }
                        resp.getReadingsList().forEach(r => {
                          let readings = r.getReadingsList().map(v => v.toJavaScript())
                          theData.sensorReadings[theApp.resourceNameToString(r.getName().toObject())] = readings;
                        });
                      });
                  },
                  processFunctionResults: function(err, resp) {
                    grpcCallback(err, resp, false)
                    if (err) {
                      document.getElementById("function_results").value = `${err}`;
                      return;
                    }
                    var results = resp.getResultsList();

                    let resultStr = '';
                    if (results.length > 0) {
                      resultStr += 'Results: \n';
                      for (let i = 0; i < results.length && i < results.length; i++) {
                        let result = results[i];
                        resultStr += `${i}: ${JSON.stringify(result.toJavaScript())}\n`;
                      }
                    }
                    resultStr += `StdOut: ${resp.getStdOut()}\n`;
                    resultStr += `StdErr: ${resp.getStdErr()}\n`;
                    document.getElementById("function_results").value = resultStr;
                  },
                  visualizeForceMatrix: function(name, id) {
                    document.getElementById('force-button-id-' + id).style.display = 'none';

                    // 2D animation stuff
                    let canvas2D = document.getElementById('force-2d-id-' + id);
                    var animation_stuff_2D = {
                      ctx: canvas2D.getContext('2d'),
                      squareWidth: 50,
                      maxPressure: 1,
                      canvasId: 'force-2d-id-' + id
                    }

                    // 3D animation stuff
                    var canvas3DWidth = 500;
                    var canvas3DHeight = 500;

                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color( 0xFBE7C6 );
                    const camera = new THREE.PerspectiveCamera(75, canvas3DWidth / canvas3DHeight, 0.1, 1000);

                    const renderer = new THREE.WebGLRenderer();
                    renderer.setSize(canvas3DWidth, canvas3DHeight);
                    var div_3d = document.getElementById('force-3d-id-' + id);
                    div_3d.appendChild(renderer.domElement);
                    camera.position.z = 6;
                    camera.position.y = -6;

                    var animation_stuff_3D = {
                      cubes: [],
                      scene: scene,
                      canvas3DHeight: canvas3DHeight,
                      canvas3DWidth: canvas3DWidth
                    }

                    // Slip detection stuff
                    let slipCanvas = document.getElementById('slip-id-' + id);
                    var slip_animation_stuff = {
                      ctx: slipCanvas.getContext('2d')
                    }

                    // Allows moving the 3D scene using the mouse
                    controls = new trackLib.TrackballControls( camera, renderer.domElement);
                    controls.target.set( 0, 0, 0 )
                    controls.rotateSpeed = 1.0

                    let startedForceAnimation = false;
                    const timeInterval = 10; // in milliseconds
                    let req = new forceMatrixApi.ReadMatrixRequest();
                    req.setName(name);

                    let slipReq = new forceMatrixApi.DetectSlipRequest();
                    slipReq.setName(name);

                    isFirstRender = true;
                    // Loop through grabbing data & visualizing it
                    setTimeout(async function getDataAndVisualizeIt(isFirstRender) {
                      let pResolve1;
                      let pReject1;
                      let p1 = new Promise((resolve, reject) => {
                        pResolve1 = resolve;
                        pReject1 = reject;
                      });
                      let pReject2;
                      let pResolve2;
                      let p2 = new Promise((resolve, reject) => {
                        pResolve2 = resolve;
                        pReject2 = reject;
                      });
                      forceMatrixService.readMatrix(req, {}, (err, resp) => {
                        if (err) {
                          pReject1(err);
                        }
                        pResolve1(null);
                        animateForceMatrix(err, resp, animation_stuff_2D, animation_stuff_3D, isFirstRender)
                      });
                      forceMatrixService.detectSlip(slipReq, {}, (err, resp) => {
                        if (err) {
                          pReject2(err);
                        }
                        pResolve2(null);
                        updateDetectSlipResult(err, resp, slip_animation_stuff)
                      });
                      await p1;
                      await p2;

                      // Start the 3D game engine animation if it hasn't been started yet
                      if (!startedForceAnimation) {
                        startedForceAnimation = true;
                        function animate() {
                            requestAnimationFrame( animate );
                            controls.update()
                            renderer.render( scene, camera );
                        }
                        animate();
                      }

                      setTimeout(getDataAndVisualizeIt, timeInterval, false);
                    }, timeInterval, isFirstRender);
                  },
                  nonEmpty : function(d) {
                      for ( var k in d ) {
                          return true;
                      }
                      return false;
                  },
                  hasKey : function(d, key) {
                    if (!d) {
                      return false;
                    }
                    if (Array.isArray(d)) {
                      for (let i = 0; i < d.length; i++) {
                        if (d[i] == key || (d[i].length && d[i].length >= 1 && d[i][0] == key)) {
                          return true;
                        }
                      }
                      return false;
                    }
                    return d.hasOwn(key);
                  },
                  grabClick : function(e) {
                      var mouse = new THREE.Vector2();
                      mouse.x = ((e.offsetX / e.srcElement.offsetWidth) * 2) - 1
                      mouse.y = ((e.offsetY / e.srcElement.offsetHeight) * -2) + 1

	                  pcdGlobal.raycaster.setFromCamera( mouse, pcdGlobal.camera );

	                  var intersects = pcdGlobal.raycaster.intersectObjects( pcdGlobal.scene.children );
                      var p = ( intersects.length ) > 0 ? intersects[ 0 ] : null;

                      if ( p !== null ) {
                        console.log(p.point);
                        setPoint(p.point);
                      } else {
                        console.log("no point intersected");
                      }

                  },
                  doPCDMove : function(){
                      let gripperName = theApp.filterResources("rdk", "component", "gripper")[0];
                      let cameraName = pcdGlobal.cameraName;
                      let cameraPointX = theData.pcdClick.x;
                      let cameraPointY = theData.pcdClick.y;
                      let cameraPointZ = theData.pcdClick.z;

                      let req = new motionApi.MoveRequest();
                      let cameraPoint = new commonApi.Pose();
                      cameraPoint.setX(cameraPointX);
                      cameraPoint.setY(cameraPointY);
                      cameraPoint.setZ(cameraPointZ);

                      var pose = new commonApi.PoseInFrame()
                      pose.setReferenceFrame(cameraName)
                      pose.setPose(cameraPoint)
                      req.setDestination(pose)
                      let componentName = new commonApi.ResourceName();
                      componentName.setNamespace(gripperName.namespace);
                      componentName.setType(gripperName.type);
                      componentName.setSubtype(gripperName.subtype);
                      componentName.setName(gripperName.name);
                      req.setComponentName(componentName);
                      console.log("making move attempt using " + gripperName);

                      motionService.move(req, {},
                        (err, resp) => {
                          grpcCallback(err, resp);
                          if (err) {
                            return Promise.reject(err);
                          }
                          return Promise.resolve(resp).then(console.log("move success: "+resp.getSuccess()));
                      })
                  },
                  findSegments : function(segmenterName, segmenterParams){
	                  console.log("parameters for segmenter below:")
		              console.log(segmenterParams)
                      theData.pcdClick.calculatingSegments = true;
                      theData.pcdClick.foundSegments = false;
                      let req = new objectSegmentationApi.GetObjectPointCloudsRequest();
                      req.setCameraName(pcdGlobal.cameraName);
                      req.setSegmenterName(segmenterName);
                      req.setParameters(proto.google.protobuf.Struct.fromJavaScript(segmenterParams));
                      const mimeType = 'pointcloud/pcd';
                      req.setMimeType(mimeType);
                      console.log("finding object segments...");
                      objectSegmentationService.getObjectPointClouds(req,  {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          console.log("error getting segments");
                          console.log(err);
                          theData.pcdClick.calculatingSegments = false;
                          return;
                        }
                        console.log("got pcd segments");
                        theData.pcdClick.foundSegments = true;
                        theData.objects = resp.getObjectsList();
                        theData.pcdClick.calculatingSegments = false;
                      });
                  },
                  doSegmentLoad : function(i){
                      var segment = theData.objects[i];
                      var data = segment.getPointCloud_asB64();
                      var center = segment.getGeometries().getGeometriesList()[0].getCenter();
                      var box = segment.getGeometries().getGeometriesList()[0].getBox();
                      var p = {x: center.getX()/1000., y: center.getY()/1000., z: center.getZ()/1000.};
                      console.log(p);
                      setPoint(p);
                      setBoundingBox(box, p);
                      const mimeType = 'pointcloud/pcd';
                      pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  doPointLoad : function(i){
                      var segment = theData.objects[i];
                      var center = segment.getGeometries().getGeometriesList()[0].getCenter();
                      var p = {x: center.getX()/1000., y: center.getY()/1000., z: center.getZ()/1000.};
                      console.log(p);
                      setPoint(p);
                  },
                  doBoundingBoxLoad : function(i){
                      var segment = theData.objects[i];
                      var center = segment.getGeometries().getGeometriesList()[0].getCenter();
                      var box = segment.getGeometries().getGeometriesList()[0].getBox();
                      var centerP = {x: center.getX()/1000., y: center.getY()/1000., z: center.getZ()/1000.};
                      setBoundingBox(box, centerP);
                  },
                  doPCDLoad : function(data){
                      const mimeType = 'pointcloud/pcd';
                      pcdLoad(`data:${mimeType};base64,${data}`);
                  },
                  setNavigationMode : function(mode){
                    let pbMode = navigationApi.Mode.MODE_UNSPECIFIED;
                    switch (mode) {
                      case 'manual':
                        pbMode = navigationApi.Mode.MODE_MANUAL;
                        break;
                      case 'waypoint':
                        pbMode = navigationApi.Mode.MODE_WAYPOINT;
                        break;
                    }
                    var req = new navigationApi.SetModeRequest();
                    req.setMode(pbMode);
                    navigationService.setMode(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  setNavigationLocation: function(elId) {
                    const posSplit = document.getElementById(elId).value.split(",");
                    if (posSplit.length != 2) {
                      return;
                    }
                    const lat = parseFloat(posSplit[0]);
                    const lng = parseFloat(posSplit[1]);
                    var req = new robotApi.ResourceRunCommandRequest();
                    let gpsName = "";
                    gpses = theApp.filterResources("rdk", "component", "gps")
                    if (gpses.length > 0){
                      gpsName = gpses[0].name
                    } else {
                      theData.error = "no gps device found";
                      return;
                    }
                    req.setResourceName(gpsName);
                    req.setCommandName("set_location");
                    req.setArgs(proto.google.protobuf.Struct.fromJavaScript({
                      latitude: lat,
                      longitude: lng,
                    }))
                    robotService.resourceRunCommand(req, {}, (err, resp) => grpcCallback(err, resp));
                  },
                  viewCamera : function(name) {
                      const streamContainer = document.getElementById(`stream-${name}`);
                      const button = streamContainer.getElementsByTagName("button")[0];
                      button.disabled = true;
                      const req = new streamApi.AddStreamRequest();
                      req.setName(name);
                      streamService.addStream(req, {}, (err, resp) => {
                        grpcCallback(err, resp, false)
                        if (err) {
                          button.disabled = false;
                          return;
                        }
                      });
                  },
                  displayRadiansInDegrees :function(r) {
                      var d = r * 180;
                      while (d < 0) {
                          d += 360;
                      }
                      while (d > 360) {
                          d -= 360;
                      }
                      return d.toFixed(1);
                  },
                  getGPIO: function(boardName) {
                    var pin = document.getElementById("get_pin_" + boardName).value;
                    var req = new boardApi.GetGPIORequest();
                    req.setName(boardName);
                    req.setPin(pin);
                    boardService.getGPIO(req, {}, (err, resp) => {
                      if (err) {
                        console.log(err);
                        return;
                      }
                      var x = resp.toObject();
                      document.getElementById("get_pin_value_" + boardName).innerHTML = "Pin: " + pin + " is " + (x.high ? "high" : "low");
                    });
                  },
                  setGPIO: function(boardName) {
                    var pin = document.getElementById("set_pin_" + boardName).value;
                    var v = document.getElementById("set_pin_v_" + boardName).value;
                    var req = new boardApi.SetGPIORequest();
                    req.setName(boardName);
                    req.setPin(pin);
                    req.setHigh(v === "high");
                    boardService.setGPIO(req, {}, grpcCallback);
                  },
              },
            directives: {
              // TODO(RDK-41): replace with vue component after naveed work done
              mapMounted (el) {
                  if (theData.mapOnce) {
                    return;
                  }
                  theData.mapOnce = true;
                  initNavigation();
                }
              },
          })

          const relevantSubtypesForStatus = ["arm", "gantry", "board", "servo", "motor", "input_controller"]

          // query metadata service every 0.5s
          const queryMetadata = async function() {
            let pResolve;
            let pReject;
            let p = new Promise((resolve, reject) => {
              pResolve = resolve;
              pReject = reject;
            });
            let resourcesChanged = false
            let shouldRestartStatusStream = false
            metadataService.resources(new metadataApi.ResourcesRequest(), {}, function(err, resp) {
              grpcCallback(err, resp, false)
              if (err) {
                pReject(err);
                return;
              }
              resources = resp.toObject().resourcesList

              // if resource list has changed, flag that
              let differences = new Set(theData.resources.map(name => theApp.resourceNameToString(name)))
              let resourceSet = new Set(resources.map(name => theApp.resourceNameToString(name)))
              for (let elem of resourceSet) {
                  if (differences.has(elem)) {
                    differences.delete(elem)
                  } else {
                    differences.add(elem)
                  }
              }
              if (differences.size > 0) {
                resourcesChanged = true

                // restart status stream if resource difference includes a resource we care about
                for (let elem of differences) {
                  let name = theApp.stringToResourceName(elem)
                  if (name.namespace == "rdk" && name.type == "component" && relevantSubtypesForStatus.includes(name.subtype)){
                    shouldRestartStatusStream = true
                    break
                  }
                }
              }

              theData.resources = resources
              pResolve(null);
            });
            await p;

            if (resourcesChanged === true) {
              querySensors()

              if (shouldRestartStatusStream === true){
                restartStatusStream()
              }
            }
            setTimeout(() => queryMetadata(), 500);
          }

          const querySensors = async function() {
            let pResolve;
            let pReject;
            p = new Promise((resolve, reject) => {
              pResolve = resolve;
              pReject = reject;
            });
            sensorsService.getSensors(new sensorsApi.GetSensorsRequest(), {}, function(err, resp) {
              grpcCallback(err, resp, false)
              if (err) {
                pReject(err);
                return;
              }
              theData.sensorNames = resp.toObject().sensorNamesList
              pResolve(null);
            });
          }

          // query stream service every 0.5s
          const streamServiceCallback = function(err, resp) {
            grpcCallback(err, resp, false)
            if (err) {
              return;
            }
            let streamNames = resp.toObject().namesList
            theData.streamNames = streamNames
          }
          const queryStreams = async function() {
            let pResolve;
            let pReject;
            let p = new Promise((resolve, reject) => {
              pResolve = resolve;
              pReject = reject;
            });
            streamService.listStreams(new streamApi.ListStreamsRequest(), {}, function(err, resp) {
              grpcCallback(err, resp, false)
              if (err) {
                pReject(err);
                return;
              }
              let streamNames = resp.toObject().namesList
              theData.streamNames = streamNames;
              pResolve(null);
            });
            await p;
            setTimeout(() => queryStreams(), 500);
          }

          let statusStream;
          let lastStatusTS = Date.now();
          const checkIntervalMillis = 3000;
          const checkLastStatus = function() {
            if ((Date.now() - lastStatusTS) > checkIntervalMillis) {
              restartStatusStream();
              return
            }
            setTimeout(checkLastStatus, checkIntervalMillis)
          }

          const restartStatusStream = async function() {
            if (statusStream) {
              statusStream.cancel();
              try {
                console.log("reconnecting");
                await window.connect();
              } catch (e) {
                console.error("failed to reconnect; retrying:", e);
                setTimeout(() => restartStatusStream(), 1000);
              }
            }
            let resourceNames = [];
            // get all relevant resource names
            relevantSubtypesForStatus.forEach(
              subtype => resourceNames = resourceNames.concat(theApp.filterResources('rdk', 'component', subtype))
            );
            let names = resourceNames.map(name => {
              let resourceName = new commonApi.ResourceName();
              resourceName.setUuid(name.uuid);
              resourceName.setNamespace(name.namespace);
              resourceName.setType(name.type);
              resourceName.setSubtype(name.subtype);
              resourceName.setName(name.name);
              return resourceName;
            });
            const streamReq = new statusApi.StreamStatusRequest();
            streamReq.setResourceNamesList(names);
            streamReq.setEvery((new proto.google.protobuf.Duration()).setNanos(500000000)); // 500ms
            statusStream = statusService.streamStatus(streamReq);
            let firstData = true;
            statusStream.on('data', function(response) {
              lastStatusTS = Date.now();
              updateStatus(response.getStatusList());
              if (firstData) {
                firstData = false;
                checkLastStatus();
              }
            });
            statusStream.on('status', function(status) {
              console.log("error streaming robot status");
              console.log(status);
              console.log(status.code, " ", status.details);
            });
            statusStream.on('end', function(end) {
              console.log("done streaming robot status");
              setTimeout(() => restartStatusStream(), 1000);
            });
          }
          queryMetadata();
          if (window.streamService) {
            queryStreams();
          }
      }

      pcdGlobal = null;

      function initPCDIfNeeded() {
          if (pcdGlobal) {
              return
          }
          theData.pcdClick.enable = true;
          console.log("initing pcd");

          const sphereGeometry = new THREE.SphereGeometry( .009, 32, 32 );
          const sphereMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );

          pcdGlobal = {
              scene : new THREE.Scene(),
              camera : new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 2000 ),
              renderer : new THREE.WebGLRenderer(),
              raycaster : new THREE.Raycaster(),
              sphere: new THREE.Mesh( sphereGeometry, sphereMaterial ),
          };

          pcdGlobal.renderer.setSize( window.innerWidth / 2, window.innerHeight / 2 );
          document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);

          pcdGlobal.controls = new orbitLib.OrbitControls( pcdGlobal.camera, pcdGlobal.renderer.domElement );
          pcdGlobal.camera.position.set( 0, 0, 0 );
          pcdGlobal.controls.target.set(0,0,-1);
          pcdGlobal.controls.update();
          pcdGlobal.camera.updateMatrix();

          console.log("pcd init done");
      }

      function resizeRendererToDisplaySize(renderer) {
          const canvas = renderer.domElement;
          const width = canvas.clientWidth;
          const height = canvas.clientHeight;
          const needResize = canvas.width !== width || canvas.height !== height;
          if (needResize) {
                    renderer.setSize(width, height, false);
                  }
          return needResize;
        }

      function pcdAnimate() {
          if (resizeRendererToDisplaySize(pcdGlobal.renderer)) {
                    const canvas = pcdGlobal.renderer.domElement;
                    pcdGlobal.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    pcdGlobal.camera.updateProjectionMatrix();
          }
	      pcdGlobal.renderer.render( pcdGlobal.scene, pcdGlobal.camera );
          pcdGlobal.controls.update();
          requestAnimationFrame( pcdAnimate );
      }

      function pcdLoad(path) {
          var loader = new pcdLib.PCDLoader();
          loader.load(
              path,

            // called when the resource is loaded
            function ( mesh ) {
              pcdGlobal.scene.clear();
              pcdGlobal.scene.add( mesh );
              pcdGlobal.scene.add( pcdGlobal.sphere);
              if (pcdGlobal.cube) {
                pcdGlobal.scene.add(pcdGlobal.cube);
              }
              pcdAnimate();
            },
            // called when loading is in progresses
            function ( xhr ) {
              //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },
            // called when loading has errors
            function ( error ) {
              console.log(error);
            }
          );
          theData.pcdClick.pcdloaded = true;
      }

      function r(n) {
          return Math.round(n*1000);
      }

      function setPoint(point) {
          theData.pcdClick.x = r(point.x);
          theData.pcdClick.y = r(point.y);
          theData.pcdClick.z = r(point.z);
          pcdGlobal.sphere.position.copy(point);
      }

      function setBoundingBox(box, centerPoint) {
          const geometry = new THREE.BoxGeometry( box.getWidthMm()/1000., box.getLengthMm()/1000., box.getDepthMm()/1000. );
          const edges = new THREE.EdgesGeometry( geometry );
          const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );
          const cube = new THREE.LineSegments( edges, material );
          cube.position.copy(centerPoint);
          cube.name = "bounding-box";
          pcdGlobal.scene.remove(pcdGlobal.scene.getObjectByName("bounding-box"));
          pcdGlobal.cube = cube;
          pcdGlobal.scene.add(cube);
      }


      function animateForceMatrix(err, resp, anim_2D, anim_3D, isFirstRender) {
          grpcCallback(err, resp);
          if (err) {
            console.log("error getting force sensor readings: ", err);
            return;
          }
          var [numRows, numCols, data] = resp.getMatrix().array;
          if (data.length !== numRows * numCols || numRows === 0 || numCols === 0) {
            console.log("corrupt force sensor data");
            return;
          }

          const gradientRate = 10;
          const gradientHeight = 20;
          const gradientWidth = 40;
          const spaceBetweenTextAndGradient = 35;
          const offsetToLeftMatrix = 120;
          const offsetBetweenMatrices = 30;
          const squareSize = anim_2D.squareWidth

          let canvas2D = document.getElementById(anim_2D.canvasId);
          // if this is the first render, initialize the 2D and 3D scene
          if (isFirstRender || anim_3D.cubes.length == 0) {
            // let's add cubes to the 3D view
            for (let row = 0; row < numRows; row++) {
                cubeRow = []
                for (let col = 0; col < numCols; col++) {
                    const geometry = new THREE.BoxGeometry(1, 1, 0.1);
                    const material = new THREE.MeshBasicMaterial( { color: 0xffaebc} );
                    const cube = new THREE.Mesh( geometry, material );
                    cube.translateX((col - (numCols-1)/2) * 1.1);
                    cube.translateY((- row + (numRows-1)/2) * 1.1);
                    cubeRow.push(cube);
                    anim_3D.scene.add(cube);
                }
                anim_3D.cubes.push(cubeRow)

                // [Debug] This helps for debugging & understanding the 3D space:
                // var axesHelper = new THREE.AxesHelper( 5 );
                // anim_3D.scene.add( axesHelper );

            }
            // resize the canvas to fit any size of matrix
            canvas2D.height = Math.max(squareSize * numRows + 20, gradientRate * gradientHeight + 20);
            canvas2D.width = Math.max(2 * squareSize * numCols + offsetToLeftMatrix + offsetBetweenMatrices, anim_3D.canvas3DWidth + 100);
          }

          for (let row = 0; row < numRows; row++) {
            for (let col = 0; col < numCols; col++) {
              let pressure = data[row * numCols + col];
              if (pressure > anim_2D.maxPressure) {
                  anim_2D.maxPressure = pressure
              }

              // --- 2D animation stuff ---
              // Visualize gradient to the left of 2D animation stuff
              for (let g = 0; g < gradientRate; g++) {
                // Create colored boxes
                let greenShadeGradient = 255/gradientRate * g;
                anim_2D.ctx.fillStyle = 'rgb(0, ' + greenShadeGradient + ', 0)'; // old version with just green color
                anim_2D.ctx.fillRect(spaceBetweenTextAndGradient, g * gradientHeight, gradientWidth, gradientHeight);

                // Label the boxes
                anim_2D.ctx.fillStyle = 'white';
                anim_2D.ctx.fillRect(0, g * gradientHeight, spaceBetweenTextAndGradient, gradientHeight);
                anim_2D.ctx.fillStyle = 'black'
                anim_2D.ctx.font = '15px sans-serif';
                anim_2D.ctx.fillText(Math.floor(anim_2D.maxPressure/(gradientRate - 1) * g) ,0, gradientHeight * (g + 1));
              }

              // greenShade is the color used to represent the pressure in both the 2D and 3D visualization
              let greenShade = 255/anim_2D.maxPressure * pressure;

              let xPos = offsetToLeftMatrix + col * squareSize;
              let yPos = row * squareSize;
              let yTextOffset = 0.6 * squareSize;
              // Visualize black box with green colors indicating the pressure
              anim_2D.ctx.fillStyle = 'rgb(0, ' + greenShade + ', 0)';
              anim_2D.ctx.fillRect(xPos, yPos, squareSize, squareSize);

              // Inscribe raw pressure values in white
              anim_2D.ctx.fillStyle = 'white'
              anim_2D.ctx.font = '20px sans-serif';
              anim_2D.ctx.fillText(pressure, xPos, yPos + yTextOffset);


              let offsetToRightMatrix = offsetBetweenMatrices + numCols * squareSize;
              // Visualize pressure values only in a separate matrix for better reading of raw values
              anim_2D.ctx.fillStyle = 'white'
              anim_2D.ctx.fillRect(xPos + offsetToRightMatrix, yPos, squareSize, squareSize);
              anim_2D.ctx.fillStyle = 'black'
              anim_2D.ctx.strokeRect(xPos + offsetToRightMatrix, yPos, squareSize, squareSize);

              // Inscribe raw pressure values in black
              anim_2D.ctx.font = '20px sans-serif';
              anim_2D.ctx.fillText(pressure, xPos + offsetToRightMatrix, yPos + yTextOffset);

              // --- 3D animation stuff ---
              anim_3D.cubes[row][col].material.color.setRGB(0, greenShade/255, 0)
              anim_3D.cubes[row][col].scale.setZ(pressure/anim_2D.maxPressure * 14)
              anim_3D.cubes[row][col].position.setZ(0)
              anim_3D.cubes[row][col].translateZ(pressure/anim_2D.maxPressure * 7 * 0.1)
            }
          }
      }

      function updateDetectSlipResult (err, resp, slip_animation_stuff) {
        grpcCallback(err, resp);
        if (err) {
          console.log("error getting slip detection readings: ", err);
          return;
        }

        if (resp === null) {
          slip_animation_stuff.ctx.fillStyle = 'orange';
          slip_animation_stuff.ctx.fillRect(0, 0, 200, 50)

          slip_animation_stuff.ctx.fillStyle = 'black'
          slip_animation_stuff.ctx.font = '20px sans-serif';
          slip_animation_stuff.ctx.fillText("response is invalid", 0, 0);
          console.log("response is null - this is an issue when running this in the cloud, but not on a device locally")
        }

        let isSlipping = resp.getSlipDetected()
        if (isSlipping) {
          slip_animation_stuff.ctx.fillStyle = 'red';
          slip_animation_stuff.ctx.fillRect(0, 0, 150, 50)

          slip_animation_stuff.ctx.fillStyle = 'white'
          slip_animation_stuff.ctx.font = '20px sans-serif';
          slip_animation_stuff.ctx.fillText("SLIPPING", 5, 25);
        } else {
          slip_animation_stuff.ctx.fillStyle = 'green';
          slip_animation_stuff.ctx.fillRect(0, 0, 150, 50)
          slip_animation_stuff.ctx.fillStyle = 'white'
          slip_animation_stuff.ctx.font = '20px sans-serif';
          slip_animation_stuff.ctx.fillText("NOT SLIPPING", 5, 25);
        }
      }

      async function doConnect(authEntity, creds, onError) {
        console.debug("connecting");
        document.getElementById("connecting-error").innerHTML = "";
        document.getElementById("connecting").classList.add("connecting");
        try {
            await window.connect(authEntity, creds);
        } catch (e) {
          const msg = `failed to connect: ${e}`;
          console.error(msg);
          document.getElementById("connecting-error").innerHTML = msg;
          document.getElementById("connecting").classList.remove("connecting");
          if (onError) {
            setTimeout(onError, 1000);
          }
          return;
        }
        console.debug("connected");
        document.getElementById("pre-app").classList.add("connected");
        await startup();
      }

      async function waitForClientAndStart() {
        if (window.supportedAuthTypes.length == 0) {
          doConnect(
            window.bakedAuth.authEntity,
            window.bakedAuth.creds,
            waitForClientAndStart);
          return;
        }

        const authElems = [];
        const disableAll = () => {
          for (elem of authElems) {
            elem.disabled = true;
          }
        };
        const enableAll = () => {
          for (elem of authElems) {
            elem.disabled = false;
          }
        };
        for (authType of window.supportedAuthTypes) {
          const authDiv = document.getElementById(`auth-${authType}`);
          const input = authDiv.getElementsByTagName('input')[0];
          const button = authDiv.getElementsByTagName('button')[0];
          authElems.push(input, button);
          const doLogin = () => {
            disableAll();
            const creds = { type: authType, payload: input.value };
            doConnect("", creds, "", "", () => enableAll());
          }
          button.addEventListener("click", () => doLogin());
          input.addEventListener("keyup", (event) => {
            if (event.keyCode !== 13) {
              return;
            }
            doLogin();
          });
        }
      }

      async function initNavigation() {
        await mapReady;
        window.map = new google.maps.Map(document.getElementById("map"), {zoom: 18});
        window.map.addListener("click", (e) => {
          var req = new navigationApi.AddWaypointRequest();
          var point = new commonApi.GeoPoint();
          point.setLatitude(e.latLng.lat());
          point.setLongitude(e.latLng.lng());
          req.setLocation(point);
          navigationService.addWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
        });

        let centered = false;
        const knownWaypoints = {};
        let localLabelCounter = 0;
        const updateWaypoints = function() {
          var req = new navigationApi.GetWaypointsRequest();
          navigationService.getWaypoints(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateWaypoints, 1000);
              return;
            }
            let waypoints = [];
            if (resp) {
              waypoints = resp.getWaypointsList();
            }
            const currentWaypoints = {};
            for (var i = 0; i < waypoints.length; i++) {
              const waypoint = waypoints[i];
              const pos = {lat: waypoint.getLocation().getLatitude(), lng: waypoint.getLocation().getLongitude()};
              const posStr = JSON.stringify(pos);
              if (knownWaypoints[posStr]) {
                currentWaypoints[posStr] = knownWaypoints[posStr];
                continue;
              }
              const marker = new google.maps.Marker({
                position: pos,
                map: window.map,
                label: `${localLabelCounter++}`,
              });
              currentWaypoints[posStr] = marker;
              knownWaypoints[posStr] = marker;
              marker.addListener("click", () => {
                console.log("clicked on marker", pos)
              });
              marker.addListener("dblclick", () => {
                var req = new navigationApi.RemoveWaypointRequest();
                req.setId(waypoint.getId());
                navigationService.removeWaypoint(req, {}, (err, resp) => grpcCallback(err, resp));
              });
            }
            const waypointsToDelete = Object.keys(knownWaypoints).filter(elem => {
              return !(elem in currentWaypoints)
            });
            for (key of waypointsToDelete) {
              const marker = knownWaypoints[key];
              marker.setMap(null);
              delete knownWaypoints[key];
            }
            setTimeout(updateWaypoints, 1000);
          });
        }
        updateWaypoints();

        const locationMarker = new google.maps.Marker({label: "robot"});
        const updateLocation = function() {
          var req = new navigationApi.GetLocationRequest();
          navigationService.getLocation(req, {}, (err, resp) => {
            grpcCallback(err, resp, false)
            if (err) {
              console.log(err);
              setTimeout(updateLocation, 1000);
              return;
            }
            const pos = {lat: resp.getLocation().getLatitude(), lng: resp.getLocation().getLongitude()};
            if (!centered) {
              centered = true;
              window.map.setCenter(pos);
            }
            locationMarker.setPosition(pos);
            locationMarker.setMap(window.map);
            setTimeout(updateLocation, 1000);
          });
        }
        updateLocation();
      }

      function initMap() {
        mapReadyResolve();
      }

      let mapReadyResolve;
      let mapReady = new Promise(resolve => {
        mapReadyResolve = resolve;
      });

      function imuRefresh() {
          if (window.theApp) {
              var all = theApp.filterResources("rdk", "component", "imu");
              all.forEach(function(x) {
                  var name = x.name;

                  if (!theData.imuData[name]) {
                      theData.imuData[name] = {};
                  }

                  var req = new imuApi.ReadOrientationRequest();
                  req.setName(name);

                  imuService.readOrientation(req, {}, (err, resp) => {
                      if (err) {
                          console.log(err);
                          return;
                      }
                      theData.imuData[name].orientation = resp.toObject().orientation;
                  });

                  var req = new imuApi.ReadAngularVelocityRequest();
                  req.setName(name);

                  imuService.readAngularVelocity(req, {}, (err, resp) => {
                      if (err) {
                          console.log(err);
                          return;
                      }
                      theData.imuData[name].angularVelocity = resp.toObject().angularVelocity;
                  });

                var req = new imuApi.ReadAccelerationRequest();
                req.setName(name);

                imuService.readAcceleration(req, {}, (err, resp) => {
                  if (err) {
                    console.log(err);
                    return;
                  }
                  theData.imuData[name].acceleration = resp.toObject().acceleration;
                });

                var req = new imuApi.ReadMagnetometerRequest();
                req.setName(name);

                imuService.readMagnetometer(req, {}, (err, resp) => {
                  if (err) {
                    console.log(err);
                    return;
                  }
                  theData.imuData[name].magnetometer = resp.toObject().magnetometer;
                });
              });
          }
          setTimeout(imuRefresh, 500);
      }
      imuRefresh();
    </script>
  </head>
  <body onLoad="waitForClientAndStart()" style="background: var(--black-10);">
    <div id="pre-app">
      <div id="connecting-error"></div>
      <div id="connecting">Connecting via {{ if .WebRTCEnabled }}WebRTC{{ else }}gRPC{{ end }}...</div>
      {{range $authType := .SupportedAuthTypes }}
          <span>{{ $authType }}: </span>
          <div id="auth-{{ $authType }}">
            <input type="password"/>
            <button>Login</button>
          </div>
      {{ end }}
    </div>
    <div id="app" v-cloak>
      <div id="actions">
        {{range $r := .Actions}}
        <button v-on:click="doAction('{{$r}}')">{{$r}}</button>
        {{end}}
      </div>

      <div style="color: red">${ error }</div>

      <!-- ******* BASE *******  -->
      <div class="base" v-for="base in filterResources('rdk', 'component', 'base')" :key="base.name">
        <h3>Base ${base.name}</h3>
        <ul>
          <li><button v-on:click="baseAction(base.name, 'straight', 1)">Forward</button></li>
          <li><button v-on:click="baseAction(base.name, 'straight', -1)">Backward</button></li>
          <li><button v-on:click="baseAction(base.name, 'arc', 1)">Arc Forward</button></li>
          <li><button v-on:click="baseAction(base.name, 'arc', -1)">Arc Backward</button></li>
          <li><button v-on:click="baseAction(base.name, 'angle', -1)">Spin Clockwise</button></li>
          <li><button v-on:click="baseAction(base.name, 'angle', 1)">Spin Counterclockwise</button></li>
        </ul>

        Speed (mm per sec): <input id="speed" name="speed" value="300"/><br>
        Distances (mm): <input id="distance" name="distance" value="500"/><br>
        Angle (degree): <input id="angle" name="angle" value="0"/><br>
      </div>

      <!-- ******* GANTRY *******  -->
      <div
        class="gantry"
        v-for="gantry in filterResources('rdk', 'component', 'gantry')"
        :key="gantry.name"
        v-if="resourceStatusByName(gantry)"
      >
        <h3>Gantry ${gantry.name}</h3>
        <table>
          <tr>
            <th>axis</th>
            <th>position</th>
            <th>length</th>
          </tr>
          <tr v-for="pp in resourceStatusByName(gantry).parts" :key="pp.axis">
            <th>${pp.axis}</th>
            <td>
              <button v-on:click="gantryInc( gantry, pp.axis, -10 )">--</button>
              <button v-on:click="gantryInc( gantry, pp.axis, -1 )">-</button>
              <button v-on:click="gantryInc( gantry, pp.axis, 1 )">+</button>
              <button v-on:click="gantryInc( gantry, pp.axis, 10 )">++</button>
            </td>
            <td>${pp.pos.toFixed(2)}</td>
            <td>${pp.length}</td>
          </tr>
        </table>
      </div>

      <!-- ******* ForceMatrix *******  -->
      <div>
        <div v-for="(forceMatrix, x) in filterResources('rdk', 'component', 'force_matrix').entries()" :key="forceMatrix[1].name">
          <hr>
          <h2>ForceMatrix: ${forceMatrix[1].name}</h2>
          <template>
            <button :id="'force-button-id-' + x" v-on:click="visualizeForceMatrix(forceMatrix[1].name, x)">Visualize Force Matrix</button>
            <!-- force 2d canvas element is resized later upon arrival of sensor data (see animateForceMatrix)  -->
            <canvas :id="'force-2d-id-' + x" width="100" height="100" style="margin-top: 20px;"></canvas>
            <canvas :id="'slip-id-' + x" width="200" height="50"></canvas>
            <div :id="'force-3d-id-' + x"></div>
          </template>
        </div>
        <hr>
      </div>

      <!-- ******* IMU *******  -->
      <div>
        <div v-for="(imu, x) in filterResources('rdk', 'component', 'imu').entries()" :key="imu[1].name">
          <hr>
          <h2>IMU: ${imu[1].name}</h2>
          <table v-if="imuData[imu[1].name] && imuData[imu[1].name].angularVelocity">
            <tr><th colspan="2">Orientation (degrees)</th></tr>
            <tr><th>Roll</th><td>${imuData[imu[1].name].orientation.rollDeg.toFixed(2)}</td></tr>
            <tr><th>Pitch</th><td>${imuData[imu[1].name].orientation.pitchDeg.toFixed(2)}</td></tr>
            <tr><th>Yaw</th><td>${imuData[imu[1].name].orientation.yawDeg.toFixed(2)}</td></tr>
            <tr><th colspan="2">Angular Velocity (degrees/second)</th></tr>
            <tr><th>X</th><td>${imuData[imu[1].name].angularVelocity.xDegsPerSec.toFixed(2)}</td></tr>
            <tr><th>Y</th><td>${imuData[imu[1].name].angularVelocity.yDegsPerSec.toFixed(2)}</td></tr>
            <tr><th>Z</th><td>${imuData[imu[1].name].angularVelocity.zDegsPerSec.toFixed(2)}</td></tr>
            <tr><th colspan="2">Acceleration (mm/second/second)</th></tr>
            <tr><th>X</th><td>${imuData[imu[1].name].acceleration.xMmPerSecPerSec.toFixed(2)}</td></tr>
            <tr><th>Y</th><td>${imuData[imu[1].name].acceleration.yMmPerSecPerSec.toFixed(2)}</td></tr>
            <tr><th>Z</th><td>${imuData[imu[1].name].acceleration.zMmPerSecPerSec.toFixed(2)}</td></tr>
            <tr><th colspan="2">Magnetometer (gauss)</th></tr>
            <tr><th>X</th><td>${imuData[imu[1].name].magnetometer.xGauss.toFixed(2)}</td></tr>
            <tr><th>Y</th><td>${imuData[imu[1].name].magnetometer.yGauss.toFixed(2)}</td></tr>
            <tr><th>Z</th><td>${imuData[imu[1].name].magnetometer.zGauss.toFixed(2)}</td></tr>            
          </table>
        </div>
        <hr>
      </div>


      <!-- ******* ARM *******  -->
      <div class="arm" v-for="arm in filterResources('rdk', 'component', 'arm')" :key="arm.name">
        <h3>Arm ${arm.name}</h3>
        <table v-if="armToggle[arm.name]" border="1">
          <tr>
            <th colspan="2"><h5>END POSITION (mms)</h5></th>
            <th colspan="2"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in armToggle[arm.name].pieces" :key="aa.joint">
            <th>${aa.endPosition[0]}</th>
            <td><input v-model="aa.endPositionValue"></td>

            <th>Joint ${aa.joint}</th>
            <td><input v-model="aa.jointValue"></td>
          </tr>
          <tr>
            <th colspan="6">
              <button v-on:click="armModifyAllDoEndPosition(arm)">Go To End Position</button>
              <button v-on:click="armModifyAllDoJoint(arm)">Go To Joints</button>
              <button v-on:click="armModifyAllCancel(arm)">Cancel</button>
            </th>
          </tr>
        </table>
        <table border="1" v-if="resourceStatusByName(arm)">
          <tr>
            <th colspan="3"><h5>END POSITION (mms)</h5></th>
            <th colspan="3"><h5>JOINTS (degrees)</h5></th>
          </tr>
          <tr v-for="aa in resourceStatusByName(arm).pieces" :key="aa.joint">
            <th>${aa.endPosition[1]}</th>
            <td>
              <button v-on:click="armEndPositionInc( arm, aa.endPosition[1], -10 )">--</button>
              <button v-on:click="armEndPositionInc( arm, aa.endPosition[1], -1 )">-</button>
              <button v-on:click="armEndPositionInc( arm, aa.endPosition[1], 1 )">+</button>
              <button v-on:click="armEndPositionInc( arm, aa.endPosition[1], 10 )">++</button>
            </td>
            <td>${aa.endPositionValue.toFixed(2)}</td>

            <th>Joint ${aa.joint}</th>
            <td>
              <button v-on:click="armJointInc( arm, aa.joint, -10 )">--</button>
              <button v-on:click="armJointInc( arm, aa.joint, -1 )">-</button>
              <button v-on:click="armJointInc( arm, aa.joint, 1 )">+</button>
              <button v-on:click="armJointInc( arm, aa.joint, 10 )">++</button>
            </td>
            <td>${aa.jointValue.toFixed(2)}</td>
          </tr>
          <tr>
            <th colspan="8">
              <button v-on:click="armHome(arm)">Home</button>
              <button v-on:click="armModifyAll(arm)">Modify All</button>
            </th>
          </tr>
        </table> <!-- end main table -->
      </div>

      <!-- ******* GRIPPER *******  -->
      <div class="gripper" v-for="gripper in filterResources('rdk', 'component', 'gripper')" :key="gripper.name">
        <h3>Gripper ${ gripper.name }</h3>
        <ul>
          <li><button v-on:click="gripperAction( gripper.name, 'open')">Open</button></li>
          <li><button v-on:click="gripperAction( gripper.name, 'grab')">Grab</button></li>
        </ul>
      </div>

      <!-- ******* SERVO *******  -->
      <div
        class="servo"
        v-for="servo in filterResources('rdk', 'component', 'servo')"
        :key="servo.name"
        v-if="resourceStatusByName(servo)"
        style="margin-bottom: .5em;"
      >
        <table border="1">
          <tr><th>Servo</th><td>${servo.name}</td></tr>
          <tr><td>Angle</td><td>${resourceStatusByName(servo).positionDeg}</td></tr>
          <tr>
            <td></td>
            <td>
              <button v-on:click="servoMove(servo, -10)">-10</button>
              <button v-on:click="servoMove(servo, -1)">-1</button>
              <button v-on:click="servoMove(servo, 1)">1</button>
              <button v-on:click="servoMove(servo, 10)">10</button>
            </td>
          </tr>
        </table>
      </div>

      <!-- ******* MOTOR *******  -->
      <motor-detail
        v-for="motor in filterResources('rdk', 'component', 'motor')"
        :key="'new-' + motor.name"
        v-if="resourceStatusByName(motor)"
        v-bind:motor-name="motor.name"
        v-bind:motor-status="resourceStatusByName(motor)"
        v-on:execute="motorCommand(motor.name, $event)"
        style="max-width: 1080px;">
      </motor-detail>

      <!-- ******* INPUT VIEW *******  -->
      <input-controller
        v-for="controller in filteredInputControllerList()"
        :key="'new-' + controller.name"
        v-if="resourceStatusByName(controller)"
        v-bind:controller-name="controller.name"
        v-bind:controller-status="resourceStatusByName(controller)"
        style="max-width: 1080px;">
      </input-controller>

      <!-- ******* WEB CONTROLS *******  -->
      <web-gamepad
        v-if="hasWebGamepad()"
        v-on:execute="inputInject($event)"
        style="max-width: 1080px;">
      </web-gamepad>

      <!-- ******* CAMERAS *******  -->
      <div class="camera" v-for="streamName in streamNames" :key="streamName">
        <h3>Camera Stream ${streamName}</h3>
        <div :id="'stream-' + streamName">
          <button v-on:click="viewCamera(streamName)">View</button>
        </div>
      </div>

      <!-- ******* BOARD *******  -->
      <div class="board" v-for="board in filterResources('rdk', 'component', 'board')" v-if="resourceStatusByName(board)" :key="board.name">
        <h3>Board ${board.name}</h3>
        <table border="1">

          <tr><th colspan="2">Analogs</th></tr>
          <tr v-for="(analog, name) in resourceStatusByName(board).analogsMap" :key="name">
            <th>${name}</th>
            <td>${analog.value || 0}</td>
          </tr>

          <tr><th colspan="2">DigitalInterrupts</th></tr>
          <tr v-for="(di, name) in resourceStatusByName(board).digitalInterruptsMap" :key="name">
            <th>${name}</th>
            <td>${di.value || 0}</td>
          </tr>

          <tr><th colspan="2">GPIO</th></tr>
          <tr>
            <th>Get</th>
            <td>
              Pin: <input :id="'get_pin_' + board.name"/><button v-on:click="getGPIO(board.name)">Get</button><br>
              <span :id="'get_pin_value_' + board.name"/>
            </td>
          </tr>
          <tr>
            <th>Set</th>
            <td>
              Pin: <input :id="'set_pin_' + board.name"/><br>
              <select :id="'set_pin_v_' + board.name">
                <option>low</option>
                <option>high</option>
              </select>
              <button v-on:click="setGPIO(board.name)">Set</button><br>
            </td>
          </tr>
          
        </table>
      </div>
      <!-- end boards -->

      <!-- cameras -->
      <table border="1" v-if="nonEmpty(filterResources('rdk', 'component', 'camera'))">
        <tr>
          <th colspan="3">
            Camera frames
          </th>
        </tr>
        <tr>
          <th>Name</th>
          <th>2D img</th>
          <th>3D img</th>
        </tr>
        <tr v-for="camera in filterResources('rdk', 'component', 'camera')">
          <td>${camera.name}</td>
          <td><a href="#" v-on:click.prevent="renderFrame(camera.name)">GO</a></td>
          <td><button v-on:click="renderPCD(camera.name); getSegmenterNames()">GO</button></td>
        </tr>
      </table>

      <table border=1 v-if="nonEmpty(sensorNames)">
        <tr>
          <th colspan="2">Sensors</th>
        </tr>

        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Readings</th>
          <th colspan="2"> <button v-on:click="getReadings(sensorNames)">Get All Readings</button></th>
        </tr>

        <tr v-for="name in sensorNames">
          <td>${name.name}</td>
          <td>${name.subtype}</td>
          <td>${sensorReadings[resourceNameToString(name)]}</td>
          <td> <button v-on:click="getReadings([name])">Get Readings</button></td>
        </tr>

      </table>

      <div id="pcd_wrapper">
        <table>
          <tr>
            <td><div id="pcd" v-on:click="grabClick"/></td>
            <td v-if="pcdClick.enable">
              <table>
                <tr>
                  <th colspan=2>
                    Clicked On
                  </th>
                </tr>
                <tr>
                  <th>X</th>
                  <td>${pcdClick.x}</td>
                </tr>
                <tr>
                  <th>Y</th>
                  <td>${pcdClick.y}</td>
                </tr>
                <tr>
                  <th>Z</th>
                  <td>${pcdClick.z}</td>
                </tr>
                <tr>
                  <td colspan=2>
                    <button v-on:click="doPCDMove">Move</button>
                  </td>
                </tr>
              </table>
            </td>
          </tr>
        </table>
      </div> <!-- end pcd wrapper -->
      <!-- get segments -->
      <table v-if="pcdClick.pcdloaded">
          <tr>
        <th colspan=3>Object Segmentation</th>
        </tr>
        <tr>
                <td>
                        Select Segmenter
                </td>
                <td>
                        <select v-model="segmentAlgo" @change="getSegmenterParameters(segmentAlgo)">
                        <option value="" selected disabled>Choose</option>
                        <option v-for="segmenter in segmenterNames" :value="segmenter">${ segmenter }</option>
                        </select>
                </td>
		<td> ${ segmentAlgo } </td>
        </tr>
        <tr v-for="param in segmenterParameterNames">
          <td>${param.getName()}</td>
	  <td><input :type="parameterType(param.getType())" id="param.getName()" v-model.number="segmenterParameters[param.getName()]"></td>
        </tr>
        <tr>
            <td v-if="!pcdClick.calculatingSegments">
                <button v-on:click="findSegments(segmentAlgo, segmenterParameters)">Find Segments</button>
            </td>
            <td v-else>Finding Objects In Scene...</td>
        </tr>
      </table>
      <table v-if="pcdClick.foundSegments">
        <tr>
          <th>Object</th>
          <th>PCD</th>
          <th>Point</th>
          <th>Bounding Box</th>
        </tr>
        <tr>
          <td>Full Image</td>
          <td><button v-on:click="doPCDLoad(fullcloud)">GO</button></td>
          <td>--</td>
        </tr>
        <tr v-for="(seg, i) in objects">
            <td>Object ${i}</td>
            <td><button v-on:click="doSegmentLoad(i)">GO</button></td>
            <td><button v-on:click="doPointLoad(i)">GO</button></td>
            <td><button v-on:click="doBoundingBoxLoad(i)">GO</button></td>
        </tr>
      </table>
      <div id="map-container" v-if="filterResources('rdk', 'service', 'navigation').length !== 0">
        <br />
        <br />
        <button v-on:click="setNavigationMode('manual')">Manual</button>
        <button v-on:click="setNavigationMode('waypoint')">Waypoint</button>
        <br />
        <input type="text" id="nav-set-location" value="40.745297,-74.010916">
        <button v-on:click="setNavigationLocation('nav-set-location')">Try Set Location</button>
        <div id="map" v-map-mounted></div>
      </div>
    </div> <!-- end vue app -->

    <!-- TODO(RDK-70): remove api key once going into production -->
    <script
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBn72TEqFOVWoj06cvua0Dc0pz2uvq90nY&callback=initMap&libraries=&v=weekly"
      async
    ></script>
  </body>
</html>
