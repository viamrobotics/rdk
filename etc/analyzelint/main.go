// Package main is a program to get metrics on linter runs.
package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"time"

	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.uber.org/multierr"
	"go.viam.com/utils"

	"go.viam.com/rdk/logging"
)

func main() {
	utils.ContextualMain(mainWithArgs, logging.NewLogger("analyzelint"))
}

// E.g:
//
// INFO [runner] processing took 152.318763ms with stages: nolint: 123.132481ms, identifier_marker:
// 16.878909ms, autogenerated_exclude: 7.98025ms, path_prettifier: 3.056596ms, fixer: 426.155µs,
// exclude-rules: 257.866µs, cgo: 222.861µs, invalid_issue: 200.211µs, filename_unadjuster:
// 137.314µs, source_code: 21.875µs, path_shortener: 1.054µs, uniq_by_line: 715ns, skip_dirs: 428ns,
// sort_results: 337ns, max_same_issues: 331ns, skip_files: 301ns, max_per_file_from_linter: 246ns,
// exclude: 241ns, max_from_linter: 238ns, diff: 185ns, severity-rules: 85ns, path_prefixer: 84ns
var timingRe = regexp.MustCompile("processing took ([^ ]+) with stages")

//nolint
type LintError struct {
	Location string `bson:"location"` // filename:line:column:
	Message  string `bson:"message"`
	Linter   string `bson:"linter"`  // e.g: errcheck
	Subcode  string `bson:"subcode"` // optional, known to exist for staticcheck and gosimple
}

//nolint
type LinterTiming struct {
	Name      string `bson:"name"`
	DurMillis int64  `bson:"dur_millis"`
}

//nolint
type LintProfile struct {
	Timing      []LinterTiming `bson:"timing"`
	ParseErrors []error        `bson:"parse_errors"`
}

//nolint
type LintResultDoc struct {
	CreatedAt           time.Time `bson:"created_at"`
	GitSHA              string    `bson:"git_sha,omitempty"`
	GitBranch           string    `bson:"git_branch"`
	GitHubRepository    string    `bson:"github_repository"`
	GitHubRunID         int64     `bson:"github_run_id,omitempty"`
	GitHubRunNumber     int64     `bson:"github_run_number,omitempty"`
	GitHubRunAttempt    int64     `bson:"github_run_attempt,omitempty"`
	GitHubIsPullRequest bool      `bson:"github_is_pull_request"`

	LinterResult any `bson:"result"`
}

func parseProcessingTook(line string) *LintProfile {
	match := timingRe.FindStringSubmatch(line)
	if len(match) == 0 {
		return nil
	}

	// E.g:
	//
	// INFO [runner] processing took 161.876231ms with stages: nolint: 123.779309ms,
	// identifier_marker: 25.437767ms, autogenerated_exclude: 6.638199ms, path_prettifier:
	// 5.165312ms, exclude-rules: 302.27µs, invalid_issue: 207.608µs, cgo: 188.95µs,
	// filename_unadjuster: 86.527µs, source_code: 34.243µs, fixer: 26.275µs, max_from_linter:
	// 2.674µs, uniq_by_line: 2.445µs, path_shortener: 1.466µs, max_same_issues: 852ns,
	// max_per_file_from_linter: 646ns, skip_dirs: 421ns, skip_files: 333ns, exclude: 300ns, diff:
	// 280ns, sort_results: 196ns, path_prefixer: 86ns, severity-rules: 72ns
	indivTiming := regexp.MustCompile(`(?: with stages:|,) ((\w+): ([^,]+))`)
	indivMatches := indivTiming.FindAllStringSubmatch(line, -1)

	ret := LintProfile{}
	for _, match := range indivMatches {
		duration, err := time.ParseDuration(match[3])
		if err != nil {
			ret.ParseErrors = append(ret.ParseErrors, err)
			continue
		}

		ret.Timing = append(ret.Timing, LinterTiming{
			Name:      match[2],
			DurMillis: duration.Milliseconds(),
		})
	}

	return &ret
}

func upload(ctx context.Context, mongoURI string, lintProfile *LintProfile, lintErrors []LintError) error {
	if mongoURI == "" {
		//nolint
		fmt.Println("Timing:")
		for _, timing := range lintProfile.Timing {
			//nolint
			fmt.Printf("  %v -> %vms\n", timing.Name, timing.DurMillis)
		}

		for _, lintError := range lintErrors {
			//nolint
			fmt.Printf("%+v\n", lintError)
		}

		return nil
	}

	gitSHA, _ := os.LookupEnv("GITHUB_X_HEAD_SHA")
	repository, _ := os.LookupEnv("GITHUB_REPOSITORY")
	var gitHubRunID, gitHubRunNumber, gitHubRunAttempt int64
	gitHubRunIDStr, ok := os.LookupEnv("GITHUB_RUN_ID")
	if ok {
		var err error
		gitHubRunID, err = strconv.ParseInt(gitHubRunIDStr, 10, 64)
		if err != nil {
			return err
		}
	}

	gitHubRunNumberStr, ok := os.LookupEnv("GITHUB_RUN_NUMBER")
	if ok {
		var err error
		gitHubRunNumber, err = strconv.ParseInt(gitHubRunNumberStr, 10, 64)
		if err != nil {
			return err
		}
	}

	gitHubRunAttemptStr, ok := os.LookupEnv("GITHUB_RUN_ATTEMPT")
	if ok {
		var err error
		gitHubRunAttempt, err = strconv.ParseInt(gitHubRunAttemptStr, 10, 64)
		if err != nil {
			return err
		}
	}

	baseRef, ok := os.LookupEnv("GITHUB_X_PR_BASE_REF")
	isPullRequest := ok && baseRef != ""
	branchName, _ := os.LookupEnv("GITHUB_X_HEAD_REF")
	createdAt := time.Now()

	client, err := mongo.Connect(ctx, options.Client().ApplyURI(mongoURI))
	if err != nil {
		return err
	}
	//nolint:errcheck
	defer client.Disconnect(ctx)

	profileColl := client.Database("tests").Collection("linter_profiling")
	_, err = profileColl.InsertOne(ctx, LintResultDoc{
		CreatedAt:           createdAt,
		GitSHA:              gitSHA,
		GitBranch:           branchName,
		GitHubRepository:    repository,
		GitHubRunID:         gitHubRunID,
		GitHubRunNumber:     gitHubRunNumber,
		GitHubRunAttempt:    gitHubRunAttempt,
		GitHubIsPullRequest: isPullRequest,

		LinterResult: *lintProfile,
	}, nil)

	lintErrColl := client.Database("tests").Collection("linter_errors")
	_, lintInsertErr := lintErrColl.InsertOne(ctx, LintResultDoc{
		CreatedAt:           createdAt,
		GitSHA:              gitSHA,
		GitBranch:           branchName,
		GitHubRepository:    repository,
		GitHubRunID:         gitHubRunID,
		GitHubRunNumber:     gitHubRunNumber,
		GitHubRunAttempt:    gitHubRunAttempt,
		GitHubIsPullRequest: isPullRequest,

		LinterResult: lintErrors,
	}, nil)

	return multierr.Combine(err, lintInsertErr)
}

func mainWithArgs(ctx context.Context, args []string, logger logging.Logger) error {
	devPtr := flag.Bool("dev", false, "Dev mode. Will run even in the absence of the"+
		"`MONGODB_TEST_OUTPUT_URI` environment variable being set.")
	flag.Parse()

	var mongoURI string
	//nolint
	if *devPtr == false {
		var ok bool
		mongoURI, ok = os.LookupEnv("MONGODB_TEST_OUTPUT_URI")
		if !ok || mongoURI == "" {
			logger.Warn("no MongoDB URI found; skipping")
			return nil
		}
	}

	var profile *LintProfile
	var lintErrors []LintError

	// E.g:
	//
	// Error: services/motion/builtin/builtin.go:273:22: Error return value of `protojson.Unmarshal`
	// is not checked (errcheck)
	lintLineRe := regexp.MustCompile(`([^ ]+.go:\d+:\d+): (.+)? \((.+)\)`)

	// E.g:
	//
	// Error: robot/client/client_test.go:1019:15: SA1019: client.client.StreamStatus is deprecated:
	// Do not use. StreamStatus periodically sends the status of all statuses requested. An empty
	// request signifies all resources. (staticcheck)
	subcodeRe := regexp.MustCompile(`.go:\d+:\d+: ([A-Z]+\d+):`)
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		line := scanner.Text()
		// This is run in a Makefile that pipes lint output over standard input. Let's tee the
		// output while we parse it.
		//nolint
		fmt.Println(line)

		if profileMatch := parseProcessingTook(line); profileMatch != nil {
			profile = profileMatch
			continue
		}

		if found := lintLineRe.FindStringSubmatch(line); len(found) > 0 {
			if subcode := subcodeRe.FindStringSubmatch(line); len(subcode) > 1 {
				lintErrors = append(lintErrors, LintError{
					Location: found[1],
					Message:  found[2],
					Linter:   found[3],
					Subcode:  subcode[1],
				})
			} else {
				lintErrors = append(lintErrors, LintError{
					Location: found[1],
					Message:  found[2],
					Linter:   found[3],
				})
			}
		}
	}

	// Always return nil such that the makefile run of the linter step does not treat an analyze
	// failure as a linter failure. Holding up a PR.
	if scanner.Err() != nil {
		//nolint
		fmt.Println("Error reading linter output:", scanner.Err())

		//nolint:nilerr
		return nil
	}

	if err := upload(ctx, mongoURI, profile, lintErrors); err != nil {
		//nolint
		fmt.Println("Error uploading to mongo:", err)
	}

	return nil
}
