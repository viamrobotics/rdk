// common.proto should hold messages that are used across multiple resource subtypes
syntax = "proto3";
option go_package = "go.viam.com/rdk/proto/api/common/v1";
option java_package = "com.viam.rdk.proto.api.common.v1";

package proto.api.common.v1;

message ResourceName {
  string uuid = 1;
  string namespace = 2;
  string type = 3;
  string subtype = 4;
  string name = 5;
}

message BoardStatus {
  map<string, AnalogStatus> analogs = 1;
  map<string, DigitalInterruptStatus> digital_interrupts = 2;
}

message AnalogStatus {
  int32 value = 1;
}

message DigitalInterruptStatus {
  int64 value = 1;
}

message Pose {
  // millimeters of the end effector from the base
  double x = 1;
  double y = 2;
  double z = 3;

  // ox, oy, oz, theta represents an orientation vector
  // Structured similarly to an angle axis, an orientation vector works differently. Rather than representing an orientation
  // with an arbitrary axis and a rotation around it from an origin, an orientation vector represents orientation
  // such that the ox/oy/oz components represent the point on the cartesian unit sphere at which your end effector is pointing
  // from the origin, and that unit vector forms an axis around which theta rotates. This means that incrementing/decrementing
  // theta will perform an in-line rotation of the end effector.
  // Theta is defined as rotation between two planes: the plane defined by the origin, the point (0,0,1), and the rx,ry,rz
  // point, and the plane defined by the origin, the rx,ry,rz point, and the new local Z axis. So if theta is kept at
  // zero as the north/south pole is circled, the Roll will correct itself to remain in-line.
  // Theta in pb.Pose should be degrees. It will be converted to radians in the internal OrientationVec.
  double o_x = 4;
  double o_y = 5;
  double o_z = 6;
  double theta = 7;
}

message PoseInFrame {
  string reference_frame = 1;
  Pose pose = 2;
}

message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

message Sphere {
  double radius_mm = 1;
}

message RectangularPrism {
  double width_mm = 1;
  double length_mm = 2;
  double depth_mm = 3;
}

message Geometry {
  common.v1.Pose center = 1;
  oneof geometry_type {
    Sphere sphere = 2;
    RectangularPrism box = 3;
  }
}

message GeometriesInFrame {
  string reference_frame = 1;
  repeated Geometry geometries = 2;
}

message PointCloudObject {
  // image frame expressed in bytes
  bytes point_cloud = 1;
  // volume of a given geometry
  common.v1.GeometriesInFrame geometries = 2;
}

message GeoPoint {
  double latitude = 1;
  double longitude = 2;
}

message WorldState {
  repeated GeometriesInFrame obstacles = 1;
}
