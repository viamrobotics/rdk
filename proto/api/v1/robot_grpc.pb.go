// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RobotServiceClient is the client API for RobotService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RobotServiceClient interface {
	// Status returns the robot's underlying status.
	Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error)
	// StatusStream periodically sends the robot's status.
	StatusStream(ctx context.Context, in *StatusStreamRequest, opts ...grpc.CallOption) (RobotService_StatusStreamClient, error)
	// Config gets the config from a server
	// It is only partial a config, including the pieces relevant to remote robots,
	// And not the pieces relevant to local configuration (pins, security keys, etc...)
	Config(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ConfigResponse, error)
	// DoAction runs an action on the underlying robot.
	DoAction(ctx context.Context, in *DoActionRequest, opts ...grpc.CallOption) (*DoActionResponse, error)
	// BaseMoveStraight moves a robot's base in a straight line by a given distance, expressed in millimeters
	// and a given speed, expressed in millimeters per second
	BaseMoveStraight(ctx context.Context, in *BaseMoveStraightRequest, opts ...grpc.CallOption) (*BaseMoveStraightResponse, error)
	// MoveArc moves the robot's base in an arc by a given distance, expressed in millimeters,
	// a given speed, expressed in millimeters per second of movement, and a given angle exoressed in degrees
	BaseMoveArc(ctx context.Context, in *BaseMoveArcRequest, opts ...grpc.CallOption) (*BaseMoveArcResponse, error)
	// BaseSpin spins a robot's base by an given angle, expressed in degrees, and a given
	// angular speed, expressed in degrees per second
	BaseSpin(ctx context.Context, in *BaseSpinRequest, opts ...grpc.CallOption) (*BaseSpinResponse, error)
	// BaseStop stops a robot's base
	BaseStop(ctx context.Context, in *BaseStopRequest, opts ...grpc.CallOption) (*BaseStopResponse, error)
	// BaseWidthMillis returns the width of a robot's base expressed in millimeters
	BaseWidthMillis(ctx context.Context, in *BaseWidthMillisRequest, opts ...grpc.CallOption) (*BaseWidthMillisResponse, error)
	// LidarInfo returns the info of a lidar of the underlying robot.
	LidarInfo(ctx context.Context, in *LidarInfoRequest, opts ...grpc.CallOption) (*LidarInfoResponse, error)
	// LidarStart starts a lidar of the underlying robot.
	LidarStart(ctx context.Context, in *LidarStartRequest, opts ...grpc.CallOption) (*LidarStartResponse, error)
	// LidarStop stops a lidar of the underlying robot.
	LidarStop(ctx context.Context, in *LidarStopRequest, opts ...grpc.CallOption) (*LidarStopResponse, error)
	// LidarScan returns a scan from a lidar of the underlying robot.
	LidarScan(ctx context.Context, in *LidarScanRequest, opts ...grpc.CallOption) (*LidarScanResponse, error)
	// LidarRange returns the range of a lidar of the underlying robot.
	LidarRange(ctx context.Context, in *LidarRangeRequest, opts ...grpc.CallOption) (*LidarRangeResponse, error)
	// LidarBounds returns the scan bounds of a lidar of the underlying robot.
	LidarBounds(ctx context.Context, in *LidarBoundsRequest, opts ...grpc.CallOption) (*LidarBoundsResponse, error)
	// LidarAngularResolution returns the scan angular resolution of a lidar of the underlying robot.
	LidarAngularResolution(ctx context.Context, in *LidarAngularResolutionRequest, opts ...grpc.CallOption) (*LidarAngularResolutionResponse, error)
	// BoardStatus returns the status of a board of the underlying robot.
	BoardStatus(ctx context.Context, in *BoardStatusRequest, opts ...grpc.CallOption) (*BoardStatusResponse, error)
	// BoardGPIOSet sets the given pin of a board of the underlying robot to either low or high.
	BoardGPIOSet(ctx context.Context, in *BoardGPIOSetRequest, opts ...grpc.CallOption) (*BoardGPIOSetResponse, error)
	// BoardGPIOGet gets the high/low state of the given pin of a board of the underlying robot.
	BoardGPIOGet(ctx context.Context, in *BoardGPIOGetRequest, opts ...grpc.CallOption) (*BoardGPIOGetResponse, error)
	// BoardPWMSet sets the given pin of a board of the underlying robot to the given duty cycle.
	BoardPWMSet(ctx context.Context, in *BoardPWMSetRequest, opts ...grpc.CallOption) (*BoardPWMSetResponse, error)
	// BoardPWMSetFrequency sets the given pin of a board of the underlying robot to the given PWM frequency. 0 will use the board's default PWM frequency.
	BoardPWMSetFrequency(ctx context.Context, in *BoardPWMSetFrequencyRequest, opts ...grpc.CallOption) (*BoardPWMSetFrequencyResponse, error)
	// BoardAnalogReaderRead reads off the current value of an analog reader of a board of the underlying robot.
	BoardAnalogReaderRead(ctx context.Context, in *BoardAnalogReaderReadRequest, opts ...grpc.CallOption) (*BoardAnalogReaderReadResponse, error)
	// BoardDigitalInterruptConfig returns the config the interrupt was created with.
	BoardDigitalInterruptConfig(ctx context.Context, in *BoardDigitalInterruptConfigRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptConfigResponse, error)
	// BoardDigitalInterruptValue returns the current value of the interrupt which is based on the type of interrupt.
	BoardDigitalInterruptValue(ctx context.Context, in *BoardDigitalInterruptValueRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptValueResponse, error)
	// BoardDigitalInterruptTick is to be called either manually if the interrupt is a proxy to some real hardware interrupt or for tests.
	BoardDigitalInterruptTick(ctx context.Context, in *BoardDigitalInterruptTickRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptTickResponse, error)
	// SensorReadings returns the readings of a sensor of the underlying robot.
	SensorReadings(ctx context.Context, in *SensorReadingsRequest, opts ...grpc.CallOption) (*SensorReadingsResponse, error)
	// CompassHeading returns the heading of a compass of the underlying robot.
	CompassHeading(ctx context.Context, in *CompassHeadingRequest, opts ...grpc.CallOption) (*CompassHeadingResponse, error)
	// CompassStartCalibration requests the compass of the underlying robot to start calibration.
	CompassStartCalibration(ctx context.Context, in *CompassStartCalibrationRequest, opts ...grpc.CallOption) (*CompassStartCalibrationResponse, error)
	// CompassStopCalibration requests the compass of the underlying robot to stop calibration.
	CompassStopCalibration(ctx context.Context, in *CompassStopCalibrationRequest, opts ...grpc.CallOption) (*CompassStopCalibrationResponse, error)
	// CompassMark requests the relative compass of the underlying robot to mark its position.
	CompassMark(ctx context.Context, in *CompassMarkRequest, opts ...grpc.CallOption) (*CompassMarkResponse, error)
	// ForceMatrixMatrix returns the matrix of force readings from the force matrix sensor
	ForceMatrixMatrix(ctx context.Context, in *ForceMatrixMatrixRequest, opts ...grpc.CallOption) (*ForceMatrixMatrixResponse, error)
	ForceMatrixSlipDetection(ctx context.Context, in *ForceMatrixSlipDetectionRequest, opts ...grpc.CallOption) (*ForceMatrixSlipDetectionResponse, error)
	// TODO(erd): refactor to functions service
	ExecuteFunction(ctx context.Context, in *ExecuteFunctionRequest, opts ...grpc.CallOption) (*ExecuteFunctionResponse, error)
	ExecuteSource(ctx context.Context, in *ExecuteSourceRequest, opts ...grpc.CallOption) (*ExecuteSourceResponse, error)
	//Motor
	// TODO(FA): This will be removed in lieu of controls package
	// Return the PID configuration for a Motor
	MotorGetPIDConfig(ctx context.Context, in *MotorGetPIDConfigRequest, opts ...grpc.CallOption) (*MotorGetPIDConfigResponse, error)
	// TODO(FA): This will be removed in lieu of controls package
	// Set the PID configuration for a Motor
	MotorSetPIDConfig(ctx context.Context, in *MotorSetPIDConfigRequest, opts ...grpc.CallOption) (*MotorSetPIDConfigResponse, error)
	// TODO(): This will be removed in lieu of controls package
	// Perform a step response on a motor
	MotorPIDStep(ctx context.Context, in *MotorPIDStepRequest, opts ...grpc.CallOption) (RobotService_MotorPIDStepClient, error)
	// MotorPower sets the percentage of the motor's total power that should be employed
	// expressed a value between -1 and 1 where negative values indiciate a backwards
	// direction and positive values a forward direction
	MotorPower(ctx context.Context, in *MotorPowerRequest, opts ...grpc.CallOption) (*MotorPowerResponse, error)
	// MotorGo instructs the motor to turn using a specified percentage of its total power,
	// expressed as a value between -1 and 1 where negative values indiciate a backwards
	// direction and positive values a forward direction
	MotorGo(ctx context.Context, in *MotorGoRequest, opts ...grpc.CallOption) (*MotorGoResponse, error)
	// MotorGoFor instructs the motor to turn at a specified speed, which is expressed in RPM,
	// for a specified number of rotations relative to its starting position
	// This method will return an error if MotorPositionSupported is false
	MotorGoFor(ctx context.Context, in *MotorGoForRequest, opts ...grpc.CallOption) (*MotorGoForResponse, error)
	// MotorGoTo requests the robot's motor to move to a specific position that
	// is relative to its home position at a specified speed which is expressed in RPM
	// This method will return an error if MotorPositionSupported is false
	MotorGoTo(ctx context.Context, in *MotorGoToRequest, opts ...grpc.CallOption) (*MotorGoToResponse, error)
	// To Do (FA): This will be deprecated in favor of a  MotorStop method
	// MotorGoTillStop moves a motor until it is stopped
	// The logic to trigger the "stop" mechanism is up to the underlying motor implementation
	MotorGoTillStop(ctx context.Context, in *MotorGoTillStopRequest, opts ...grpc.CallOption) (*MotorGoTillStopResponse, error)
	// MotorZero sets the current position of the motor as the new zero position
	// This method will return an error if MotorPositionSupported is false
	MotorZero(ctx context.Context, in *MotorZeroRequest, opts ...grpc.CallOption) (*MotorZeroResponse, error)
	// MotorPosition reports the position of the robot's motor relative to its zero position
	// This method will return an error if MotorPositionSupported is false
	MotorPosition(ctx context.Context, in *MotorPositionRequest, opts ...grpc.CallOption) (*MotorPositionResponse, error)
	// MotorPositionSupported returns whether or not the robot's motor supports reporting of its position
	MotorPositionSupported(ctx context.Context, in *MotorPositionSupportedRequest, opts ...grpc.CallOption) (*MotorPositionSupportedResponse, error)
	// MotorOff turns the robot's motor off
	// To Do (FA): This will be deprecated
	MotorOff(ctx context.Context, in *MotorOffRequest, opts ...grpc.CallOption) (*MotorOffResponse, error)
	// MotorisOn returns true if the robot's motor off
	// To Do (FA): This will be deprecated
	MotorIsOn(ctx context.Context, in *MotorIsOnRequest, opts ...grpc.CallOption) (*MotorIsOnResponse, error)
	InputControllerControls(ctx context.Context, in *InputControllerControlsRequest, opts ...grpc.CallOption) (*InputControllerControlsResponse, error)
	InputControllerLastEvents(ctx context.Context, in *InputControllerLastEventsRequest, opts ...grpc.CallOption) (*InputControllerLastEventsResponse, error)
	InputControllerEventStream(ctx context.Context, in *InputControllerEventStreamRequest, opts ...grpc.CallOption) (RobotService_InputControllerEventStreamClient, error)
	InputControllerInjectEvent(ctx context.Context, in *InputControllerInjectEventRequest, opts ...grpc.CallOption) (*InputControllerInjectEventResponse, error)
	// ResourceRunCommand runs an arbitrary command on a resource if it supports it.
	ResourceRunCommand(ctx context.Context, in *ResourceRunCommandRequest, opts ...grpc.CallOption) (*ResourceRunCommandResponse, error)
	// Frame System Service
	FrameServiceConfig(ctx context.Context, in *FrameServiceConfigRequest, opts ...grpc.CallOption) (*FrameServiceConfigResponse, error)
	// Navigation Service
	NavigationServiceMode(ctx context.Context, in *NavigationServiceModeRequest, opts ...grpc.CallOption) (*NavigationServiceModeResponse, error)
	NavigationServiceSetMode(ctx context.Context, in *NavigationServiceSetModeRequest, opts ...grpc.CallOption) (*NavigationServiceSetModeResponse, error)
	NavigationServiceLocation(ctx context.Context, in *NavigationServiceLocationRequest, opts ...grpc.CallOption) (*NavigationServiceLocationResponse, error)
	NavigationServiceWaypoints(ctx context.Context, in *NavigationServiceWaypointsRequest, opts ...grpc.CallOption) (*NavigationServiceWaypointsResponse, error)
	NavigationServiceAddWaypoint(ctx context.Context, in *NavigationServiceAddWaypointRequest, opts ...grpc.CallOption) (*NavigationServiceAddWaypointResponse, error)
	NavigationServiceRemoveWaypoint(ctx context.Context, in *NavigationServiceRemoveWaypointRequest, opts ...grpc.CallOption) (*NavigationServiceRemoveWaypointResponse, error)
	ObjectManipulationServiceDoGrab(ctx context.Context, in *ObjectManipulationServiceDoGrabRequest, opts ...grpc.CallOption) (*ObjectManipulationServiceDoGrabResponse, error)
	// IMUAngularVelocity returns the most recent angular velocity reading from the given IMU.
	IMUAngularVelocity(ctx context.Context, in *IMUAngularVelocityRequest, opts ...grpc.CallOption) (*IMUAngularVelocityResponse, error)
	// IMUOrientation returns the most recent orientation reading from the given IMU.
	IMUOrientation(ctx context.Context, in *IMUOrientationRequest, opts ...grpc.CallOption) (*IMUOrientationResponse, error)
	// GPSLocation returns the most recent location from the given GPS.
	GPSLocation(ctx context.Context, in *GPSLocationRequest, opts ...grpc.CallOption) (*GPSLocationResponse, error)
	// GPSAltitude returns the most recent altitude from the given GPS.
	GPSAltitude(ctx context.Context, in *GPSAltitudeRequest, opts ...grpc.CallOption) (*GPSAltitudeResponse, error)
	// GPSSpeed returns the most recent speed from the given GPS.
	GPSSpeed(ctx context.Context, in *GPSSpeedRequest, opts ...grpc.CallOption) (*GPSSpeedResponse, error)
	// GPSAccuracy returns the most recent location accuracy from the given GPS.
	GPSAccuracy(ctx context.Context, in *GPSAccuracyRequest, opts ...grpc.CallOption) (*GPSAccuracyResponse, error)
}

type robotServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRobotServiceClient(cc grpc.ClientConnInterface) RobotServiceClient {
	return &robotServiceClient{cc}
}

func (c *robotServiceClient) Status(ctx context.Context, in *StatusRequest, opts ...grpc.CallOption) (*StatusResponse, error) {
	out := new(StatusResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/Status", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) StatusStream(ctx context.Context, in *StatusStreamRequest, opts ...grpc.CallOption) (RobotService_StatusStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &RobotService_ServiceDesc.Streams[0], "/proto.api.v1.RobotService/StatusStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &robotServiceStatusStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RobotService_StatusStreamClient interface {
	Recv() (*StatusStreamResponse, error)
	grpc.ClientStream
}

type robotServiceStatusStreamClient struct {
	grpc.ClientStream
}

func (x *robotServiceStatusStreamClient) Recv() (*StatusStreamResponse, error) {
	m := new(StatusStreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *robotServiceClient) Config(ctx context.Context, in *ConfigRequest, opts ...grpc.CallOption) (*ConfigResponse, error) {
	out := new(ConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/Config", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) DoAction(ctx context.Context, in *DoActionRequest, opts ...grpc.CallOption) (*DoActionResponse, error) {
	out := new(DoActionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/DoAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseMoveStraight(ctx context.Context, in *BaseMoveStraightRequest, opts ...grpc.CallOption) (*BaseMoveStraightResponse, error) {
	out := new(BaseMoveStraightResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseMoveStraight", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseMoveArc(ctx context.Context, in *BaseMoveArcRequest, opts ...grpc.CallOption) (*BaseMoveArcResponse, error) {
	out := new(BaseMoveArcResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseMoveArc", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseSpin(ctx context.Context, in *BaseSpinRequest, opts ...grpc.CallOption) (*BaseSpinResponse, error) {
	out := new(BaseSpinResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseSpin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseStop(ctx context.Context, in *BaseStopRequest, opts ...grpc.CallOption) (*BaseStopResponse, error) {
	out := new(BaseStopResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BaseWidthMillis(ctx context.Context, in *BaseWidthMillisRequest, opts ...grpc.CallOption) (*BaseWidthMillisResponse, error) {
	out := new(BaseWidthMillisResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BaseWidthMillis", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarInfo(ctx context.Context, in *LidarInfoRequest, opts ...grpc.CallOption) (*LidarInfoResponse, error) {
	out := new(LidarInfoResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarStart(ctx context.Context, in *LidarStartRequest, opts ...grpc.CallOption) (*LidarStartResponse, error) {
	out := new(LidarStartResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarStop(ctx context.Context, in *LidarStopRequest, opts ...grpc.CallOption) (*LidarStopResponse, error) {
	out := new(LidarStopResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarScan(ctx context.Context, in *LidarScanRequest, opts ...grpc.CallOption) (*LidarScanResponse, error) {
	out := new(LidarScanResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarScan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarRange(ctx context.Context, in *LidarRangeRequest, opts ...grpc.CallOption) (*LidarRangeResponse, error) {
	out := new(LidarRangeResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarBounds(ctx context.Context, in *LidarBoundsRequest, opts ...grpc.CallOption) (*LidarBoundsResponse, error) {
	out := new(LidarBoundsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarBounds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) LidarAngularResolution(ctx context.Context, in *LidarAngularResolutionRequest, opts ...grpc.CallOption) (*LidarAngularResolutionResponse, error) {
	out := new(LidarAngularResolutionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/LidarAngularResolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardStatus(ctx context.Context, in *BoardStatusRequest, opts ...grpc.CallOption) (*BoardStatusResponse, error) {
	out := new(BoardStatusResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardGPIOSet(ctx context.Context, in *BoardGPIOSetRequest, opts ...grpc.CallOption) (*BoardGPIOSetResponse, error) {
	out := new(BoardGPIOSetResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardGPIOSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardGPIOGet(ctx context.Context, in *BoardGPIOGetRequest, opts ...grpc.CallOption) (*BoardGPIOGetResponse, error) {
	out := new(BoardGPIOGetResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardGPIOGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardPWMSet(ctx context.Context, in *BoardPWMSetRequest, opts ...grpc.CallOption) (*BoardPWMSetResponse, error) {
	out := new(BoardPWMSetResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardPWMSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardPWMSetFrequency(ctx context.Context, in *BoardPWMSetFrequencyRequest, opts ...grpc.CallOption) (*BoardPWMSetFrequencyResponse, error) {
	out := new(BoardPWMSetFrequencyResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardPWMSetFrequency", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardAnalogReaderRead(ctx context.Context, in *BoardAnalogReaderReadRequest, opts ...grpc.CallOption) (*BoardAnalogReaderReadResponse, error) {
	out := new(BoardAnalogReaderReadResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardAnalogReaderRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardDigitalInterruptConfig(ctx context.Context, in *BoardDigitalInterruptConfigRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptConfigResponse, error) {
	out := new(BoardDigitalInterruptConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardDigitalInterruptConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardDigitalInterruptValue(ctx context.Context, in *BoardDigitalInterruptValueRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptValueResponse, error) {
	out := new(BoardDigitalInterruptValueResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardDigitalInterruptValue", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) BoardDigitalInterruptTick(ctx context.Context, in *BoardDigitalInterruptTickRequest, opts ...grpc.CallOption) (*BoardDigitalInterruptTickResponse, error) {
	out := new(BoardDigitalInterruptTickResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/BoardDigitalInterruptTick", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) SensorReadings(ctx context.Context, in *SensorReadingsRequest, opts ...grpc.CallOption) (*SensorReadingsResponse, error) {
	out := new(SensorReadingsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/SensorReadings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassHeading(ctx context.Context, in *CompassHeadingRequest, opts ...grpc.CallOption) (*CompassHeadingResponse, error) {
	out := new(CompassHeadingResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassHeading", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassStartCalibration(ctx context.Context, in *CompassStartCalibrationRequest, opts ...grpc.CallOption) (*CompassStartCalibrationResponse, error) {
	out := new(CompassStartCalibrationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassStartCalibration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassStopCalibration(ctx context.Context, in *CompassStopCalibrationRequest, opts ...grpc.CallOption) (*CompassStopCalibrationResponse, error) {
	out := new(CompassStopCalibrationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassStopCalibration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) CompassMark(ctx context.Context, in *CompassMarkRequest, opts ...grpc.CallOption) (*CompassMarkResponse, error) {
	out := new(CompassMarkResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/CompassMark", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ForceMatrixMatrix(ctx context.Context, in *ForceMatrixMatrixRequest, opts ...grpc.CallOption) (*ForceMatrixMatrixResponse, error) {
	out := new(ForceMatrixMatrixResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ForceMatrixMatrix", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ForceMatrixSlipDetection(ctx context.Context, in *ForceMatrixSlipDetectionRequest, opts ...grpc.CallOption) (*ForceMatrixSlipDetectionResponse, error) {
	out := new(ForceMatrixSlipDetectionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ForceMatrixSlipDetection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ExecuteFunction(ctx context.Context, in *ExecuteFunctionRequest, opts ...grpc.CallOption) (*ExecuteFunctionResponse, error) {
	out := new(ExecuteFunctionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ExecuteFunction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ExecuteSource(ctx context.Context, in *ExecuteSourceRequest, opts ...grpc.CallOption) (*ExecuteSourceResponse, error) {
	out := new(ExecuteSourceResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ExecuteSource", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorGetPIDConfig(ctx context.Context, in *MotorGetPIDConfigRequest, opts ...grpc.CallOption) (*MotorGetPIDConfigResponse, error) {
	out := new(MotorGetPIDConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorGetPIDConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorSetPIDConfig(ctx context.Context, in *MotorSetPIDConfigRequest, opts ...grpc.CallOption) (*MotorSetPIDConfigResponse, error) {
	out := new(MotorSetPIDConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorSetPIDConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorPIDStep(ctx context.Context, in *MotorPIDStepRequest, opts ...grpc.CallOption) (RobotService_MotorPIDStepClient, error) {
	stream, err := c.cc.NewStream(ctx, &RobotService_ServiceDesc.Streams[1], "/proto.api.v1.RobotService/MotorPIDStep", opts...)
	if err != nil {
		return nil, err
	}
	x := &robotServiceMotorPIDStepClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RobotService_MotorPIDStepClient interface {
	Recv() (*MotorPIDStepResponse, error)
	grpc.ClientStream
}

type robotServiceMotorPIDStepClient struct {
	grpc.ClientStream
}

func (x *robotServiceMotorPIDStepClient) Recv() (*MotorPIDStepResponse, error) {
	m := new(MotorPIDStepResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *robotServiceClient) MotorPower(ctx context.Context, in *MotorPowerRequest, opts ...grpc.CallOption) (*MotorPowerResponse, error) {
	out := new(MotorPowerResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorPower", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorGo(ctx context.Context, in *MotorGoRequest, opts ...grpc.CallOption) (*MotorGoResponse, error) {
	out := new(MotorGoResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorGo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorGoFor(ctx context.Context, in *MotorGoForRequest, opts ...grpc.CallOption) (*MotorGoForResponse, error) {
	out := new(MotorGoForResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorGoFor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorGoTo(ctx context.Context, in *MotorGoToRequest, opts ...grpc.CallOption) (*MotorGoToResponse, error) {
	out := new(MotorGoToResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorGoTo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorGoTillStop(ctx context.Context, in *MotorGoTillStopRequest, opts ...grpc.CallOption) (*MotorGoTillStopResponse, error) {
	out := new(MotorGoTillStopResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorGoTillStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorZero(ctx context.Context, in *MotorZeroRequest, opts ...grpc.CallOption) (*MotorZeroResponse, error) {
	out := new(MotorZeroResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorZero", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorPosition(ctx context.Context, in *MotorPositionRequest, opts ...grpc.CallOption) (*MotorPositionResponse, error) {
	out := new(MotorPositionResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorPosition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorPositionSupported(ctx context.Context, in *MotorPositionSupportedRequest, opts ...grpc.CallOption) (*MotorPositionSupportedResponse, error) {
	out := new(MotorPositionSupportedResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorPositionSupported", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorOff(ctx context.Context, in *MotorOffRequest, opts ...grpc.CallOption) (*MotorOffResponse, error) {
	out := new(MotorOffResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorOff", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) MotorIsOn(ctx context.Context, in *MotorIsOnRequest, opts ...grpc.CallOption) (*MotorIsOnResponse, error) {
	out := new(MotorIsOnResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/MotorIsOn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) InputControllerControls(ctx context.Context, in *InputControllerControlsRequest, opts ...grpc.CallOption) (*InputControllerControlsResponse, error) {
	out := new(InputControllerControlsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/InputControllerControls", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) InputControllerLastEvents(ctx context.Context, in *InputControllerLastEventsRequest, opts ...grpc.CallOption) (*InputControllerLastEventsResponse, error) {
	out := new(InputControllerLastEventsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/InputControllerLastEvents", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) InputControllerEventStream(ctx context.Context, in *InputControllerEventStreamRequest, opts ...grpc.CallOption) (RobotService_InputControllerEventStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &RobotService_ServiceDesc.Streams[2], "/proto.api.v1.RobotService/InputControllerEventStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &robotServiceInputControllerEventStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RobotService_InputControllerEventStreamClient interface {
	Recv() (*InputControllerEvent, error)
	grpc.ClientStream
}

type robotServiceInputControllerEventStreamClient struct {
	grpc.ClientStream
}

func (x *robotServiceInputControllerEventStreamClient) Recv() (*InputControllerEvent, error) {
	m := new(InputControllerEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *robotServiceClient) InputControllerInjectEvent(ctx context.Context, in *InputControllerInjectEventRequest, opts ...grpc.CallOption) (*InputControllerInjectEventResponse, error) {
	out := new(InputControllerInjectEventResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/InputControllerInjectEvent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ResourceRunCommand(ctx context.Context, in *ResourceRunCommandRequest, opts ...grpc.CallOption) (*ResourceRunCommandResponse, error) {
	out := new(ResourceRunCommandResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ResourceRunCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) FrameServiceConfig(ctx context.Context, in *FrameServiceConfigRequest, opts ...grpc.CallOption) (*FrameServiceConfigResponse, error) {
	out := new(FrameServiceConfigResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/FrameServiceConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) NavigationServiceMode(ctx context.Context, in *NavigationServiceModeRequest, opts ...grpc.CallOption) (*NavigationServiceModeResponse, error) {
	out := new(NavigationServiceModeResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/NavigationServiceMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) NavigationServiceSetMode(ctx context.Context, in *NavigationServiceSetModeRequest, opts ...grpc.CallOption) (*NavigationServiceSetModeResponse, error) {
	out := new(NavigationServiceSetModeResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/NavigationServiceSetMode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) NavigationServiceLocation(ctx context.Context, in *NavigationServiceLocationRequest, opts ...grpc.CallOption) (*NavigationServiceLocationResponse, error) {
	out := new(NavigationServiceLocationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/NavigationServiceLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) NavigationServiceWaypoints(ctx context.Context, in *NavigationServiceWaypointsRequest, opts ...grpc.CallOption) (*NavigationServiceWaypointsResponse, error) {
	out := new(NavigationServiceWaypointsResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/NavigationServiceWaypoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) NavigationServiceAddWaypoint(ctx context.Context, in *NavigationServiceAddWaypointRequest, opts ...grpc.CallOption) (*NavigationServiceAddWaypointResponse, error) {
	out := new(NavigationServiceAddWaypointResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/NavigationServiceAddWaypoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) NavigationServiceRemoveWaypoint(ctx context.Context, in *NavigationServiceRemoveWaypointRequest, opts ...grpc.CallOption) (*NavigationServiceRemoveWaypointResponse, error) {
	out := new(NavigationServiceRemoveWaypointResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/NavigationServiceRemoveWaypoint", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) ObjectManipulationServiceDoGrab(ctx context.Context, in *ObjectManipulationServiceDoGrabRequest, opts ...grpc.CallOption) (*ObjectManipulationServiceDoGrabResponse, error) {
	out := new(ObjectManipulationServiceDoGrabResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/ObjectManipulationServiceDoGrab", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) IMUAngularVelocity(ctx context.Context, in *IMUAngularVelocityRequest, opts ...grpc.CallOption) (*IMUAngularVelocityResponse, error) {
	out := new(IMUAngularVelocityResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/IMUAngularVelocity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) IMUOrientation(ctx context.Context, in *IMUOrientationRequest, opts ...grpc.CallOption) (*IMUOrientationResponse, error) {
	out := new(IMUOrientationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/IMUOrientation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) GPSLocation(ctx context.Context, in *GPSLocationRequest, opts ...grpc.CallOption) (*GPSLocationResponse, error) {
	out := new(GPSLocationResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/GPSLocation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) GPSAltitude(ctx context.Context, in *GPSAltitudeRequest, opts ...grpc.CallOption) (*GPSAltitudeResponse, error) {
	out := new(GPSAltitudeResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/GPSAltitude", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) GPSSpeed(ctx context.Context, in *GPSSpeedRequest, opts ...grpc.CallOption) (*GPSSpeedResponse, error) {
	out := new(GPSSpeedResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/GPSSpeed", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *robotServiceClient) GPSAccuracy(ctx context.Context, in *GPSAccuracyRequest, opts ...grpc.CallOption) (*GPSAccuracyResponse, error) {
	out := new(GPSAccuracyResponse)
	err := c.cc.Invoke(ctx, "/proto.api.v1.RobotService/GPSAccuracy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RobotServiceServer is the server API for RobotService service.
// All implementations must embed UnimplementedRobotServiceServer
// for forward compatibility
type RobotServiceServer interface {
	// Status returns the robot's underlying status.
	Status(context.Context, *StatusRequest) (*StatusResponse, error)
	// StatusStream periodically sends the robot's status.
	StatusStream(*StatusStreamRequest, RobotService_StatusStreamServer) error
	// Config gets the config from a server
	// It is only partial a config, including the pieces relevant to remote robots,
	// And not the pieces relevant to local configuration (pins, security keys, etc...)
	Config(context.Context, *ConfigRequest) (*ConfigResponse, error)
	// DoAction runs an action on the underlying robot.
	DoAction(context.Context, *DoActionRequest) (*DoActionResponse, error)
	// BaseMoveStraight moves a robot's base in a straight line by a given distance, expressed in millimeters
	// and a given speed, expressed in millimeters per second
	BaseMoveStraight(context.Context, *BaseMoveStraightRequest) (*BaseMoveStraightResponse, error)
	// MoveArc moves the robot's base in an arc by a given distance, expressed in millimeters,
	// a given speed, expressed in millimeters per second of movement, and a given angle exoressed in degrees
	BaseMoveArc(context.Context, *BaseMoveArcRequest) (*BaseMoveArcResponse, error)
	// BaseSpin spins a robot's base by an given angle, expressed in degrees, and a given
	// angular speed, expressed in degrees per second
	BaseSpin(context.Context, *BaseSpinRequest) (*BaseSpinResponse, error)
	// BaseStop stops a robot's base
	BaseStop(context.Context, *BaseStopRequest) (*BaseStopResponse, error)
	// BaseWidthMillis returns the width of a robot's base expressed in millimeters
	BaseWidthMillis(context.Context, *BaseWidthMillisRequest) (*BaseWidthMillisResponse, error)
	// LidarInfo returns the info of a lidar of the underlying robot.
	LidarInfo(context.Context, *LidarInfoRequest) (*LidarInfoResponse, error)
	// LidarStart starts a lidar of the underlying robot.
	LidarStart(context.Context, *LidarStartRequest) (*LidarStartResponse, error)
	// LidarStop stops a lidar of the underlying robot.
	LidarStop(context.Context, *LidarStopRequest) (*LidarStopResponse, error)
	// LidarScan returns a scan from a lidar of the underlying robot.
	LidarScan(context.Context, *LidarScanRequest) (*LidarScanResponse, error)
	// LidarRange returns the range of a lidar of the underlying robot.
	LidarRange(context.Context, *LidarRangeRequest) (*LidarRangeResponse, error)
	// LidarBounds returns the scan bounds of a lidar of the underlying robot.
	LidarBounds(context.Context, *LidarBoundsRequest) (*LidarBoundsResponse, error)
	// LidarAngularResolution returns the scan angular resolution of a lidar of the underlying robot.
	LidarAngularResolution(context.Context, *LidarAngularResolutionRequest) (*LidarAngularResolutionResponse, error)
	// BoardStatus returns the status of a board of the underlying robot.
	BoardStatus(context.Context, *BoardStatusRequest) (*BoardStatusResponse, error)
	// BoardGPIOSet sets the given pin of a board of the underlying robot to either low or high.
	BoardGPIOSet(context.Context, *BoardGPIOSetRequest) (*BoardGPIOSetResponse, error)
	// BoardGPIOGet gets the high/low state of the given pin of a board of the underlying robot.
	BoardGPIOGet(context.Context, *BoardGPIOGetRequest) (*BoardGPIOGetResponse, error)
	// BoardPWMSet sets the given pin of a board of the underlying robot to the given duty cycle.
	BoardPWMSet(context.Context, *BoardPWMSetRequest) (*BoardPWMSetResponse, error)
	// BoardPWMSetFrequency sets the given pin of a board of the underlying robot to the given PWM frequency. 0 will use the board's default PWM frequency.
	BoardPWMSetFrequency(context.Context, *BoardPWMSetFrequencyRequest) (*BoardPWMSetFrequencyResponse, error)
	// BoardAnalogReaderRead reads off the current value of an analog reader of a board of the underlying robot.
	BoardAnalogReaderRead(context.Context, *BoardAnalogReaderReadRequest) (*BoardAnalogReaderReadResponse, error)
	// BoardDigitalInterruptConfig returns the config the interrupt was created with.
	BoardDigitalInterruptConfig(context.Context, *BoardDigitalInterruptConfigRequest) (*BoardDigitalInterruptConfigResponse, error)
	// BoardDigitalInterruptValue returns the current value of the interrupt which is based on the type of interrupt.
	BoardDigitalInterruptValue(context.Context, *BoardDigitalInterruptValueRequest) (*BoardDigitalInterruptValueResponse, error)
	// BoardDigitalInterruptTick is to be called either manually if the interrupt is a proxy to some real hardware interrupt or for tests.
	BoardDigitalInterruptTick(context.Context, *BoardDigitalInterruptTickRequest) (*BoardDigitalInterruptTickResponse, error)
	// SensorReadings returns the readings of a sensor of the underlying robot.
	SensorReadings(context.Context, *SensorReadingsRequest) (*SensorReadingsResponse, error)
	// CompassHeading returns the heading of a compass of the underlying robot.
	CompassHeading(context.Context, *CompassHeadingRequest) (*CompassHeadingResponse, error)
	// CompassStartCalibration requests the compass of the underlying robot to start calibration.
	CompassStartCalibration(context.Context, *CompassStartCalibrationRequest) (*CompassStartCalibrationResponse, error)
	// CompassStopCalibration requests the compass of the underlying robot to stop calibration.
	CompassStopCalibration(context.Context, *CompassStopCalibrationRequest) (*CompassStopCalibrationResponse, error)
	// CompassMark requests the relative compass of the underlying robot to mark its position.
	CompassMark(context.Context, *CompassMarkRequest) (*CompassMarkResponse, error)
	// ForceMatrixMatrix returns the matrix of force readings from the force matrix sensor
	ForceMatrixMatrix(context.Context, *ForceMatrixMatrixRequest) (*ForceMatrixMatrixResponse, error)
	ForceMatrixSlipDetection(context.Context, *ForceMatrixSlipDetectionRequest) (*ForceMatrixSlipDetectionResponse, error)
	// TODO(erd): refactor to functions service
	ExecuteFunction(context.Context, *ExecuteFunctionRequest) (*ExecuteFunctionResponse, error)
	ExecuteSource(context.Context, *ExecuteSourceRequest) (*ExecuteSourceResponse, error)
	//Motor
	// TODO(FA): This will be removed in lieu of controls package
	// Return the PID configuration for a Motor
	MotorGetPIDConfig(context.Context, *MotorGetPIDConfigRequest) (*MotorGetPIDConfigResponse, error)
	// TODO(FA): This will be removed in lieu of controls package
	// Set the PID configuration for a Motor
	MotorSetPIDConfig(context.Context, *MotorSetPIDConfigRequest) (*MotorSetPIDConfigResponse, error)
	// TODO(): This will be removed in lieu of controls package
	// Perform a step response on a motor
	MotorPIDStep(*MotorPIDStepRequest, RobotService_MotorPIDStepServer) error
	// MotorPower sets the percentage of the motor's total power that should be employed
	// expressed a value between -1 and 1 where negative values indiciate a backwards
	// direction and positive values a forward direction
	MotorPower(context.Context, *MotorPowerRequest) (*MotorPowerResponse, error)
	// MotorGo instructs the motor to turn using a specified percentage of its total power,
	// expressed as a value between -1 and 1 where negative values indiciate a backwards
	// direction and positive values a forward direction
	MotorGo(context.Context, *MotorGoRequest) (*MotorGoResponse, error)
	// MotorGoFor instructs the motor to turn at a specified speed, which is expressed in RPM,
	// for a specified number of rotations relative to its starting position
	// This method will return an error if MotorPositionSupported is false
	MotorGoFor(context.Context, *MotorGoForRequest) (*MotorGoForResponse, error)
	// MotorGoTo requests the robot's motor to move to a specific position that
	// is relative to its home position at a specified speed which is expressed in RPM
	// This method will return an error if MotorPositionSupported is false
	MotorGoTo(context.Context, *MotorGoToRequest) (*MotorGoToResponse, error)
	// To Do (FA): This will be deprecated in favor of a  MotorStop method
	// MotorGoTillStop moves a motor until it is stopped
	// The logic to trigger the "stop" mechanism is up to the underlying motor implementation
	MotorGoTillStop(context.Context, *MotorGoTillStopRequest) (*MotorGoTillStopResponse, error)
	// MotorZero sets the current position of the motor as the new zero position
	// This method will return an error if MotorPositionSupported is false
	MotorZero(context.Context, *MotorZeroRequest) (*MotorZeroResponse, error)
	// MotorPosition reports the position of the robot's motor relative to its zero position
	// This method will return an error if MotorPositionSupported is false
	MotorPosition(context.Context, *MotorPositionRequest) (*MotorPositionResponse, error)
	// MotorPositionSupported returns whether or not the robot's motor supports reporting of its position
	MotorPositionSupported(context.Context, *MotorPositionSupportedRequest) (*MotorPositionSupportedResponse, error)
	// MotorOff turns the robot's motor off
	// To Do (FA): This will be deprecated
	MotorOff(context.Context, *MotorOffRequest) (*MotorOffResponse, error)
	// MotorisOn returns true if the robot's motor off
	// To Do (FA): This will be deprecated
	MotorIsOn(context.Context, *MotorIsOnRequest) (*MotorIsOnResponse, error)
	InputControllerControls(context.Context, *InputControllerControlsRequest) (*InputControllerControlsResponse, error)
	InputControllerLastEvents(context.Context, *InputControllerLastEventsRequest) (*InputControllerLastEventsResponse, error)
	InputControllerEventStream(*InputControllerEventStreamRequest, RobotService_InputControllerEventStreamServer) error
	InputControllerInjectEvent(context.Context, *InputControllerInjectEventRequest) (*InputControllerInjectEventResponse, error)
	// ResourceRunCommand runs an arbitrary command on a resource if it supports it.
	ResourceRunCommand(context.Context, *ResourceRunCommandRequest) (*ResourceRunCommandResponse, error)
	// Frame System Service
	FrameServiceConfig(context.Context, *FrameServiceConfigRequest) (*FrameServiceConfigResponse, error)
	// Navigation Service
	NavigationServiceMode(context.Context, *NavigationServiceModeRequest) (*NavigationServiceModeResponse, error)
	NavigationServiceSetMode(context.Context, *NavigationServiceSetModeRequest) (*NavigationServiceSetModeResponse, error)
	NavigationServiceLocation(context.Context, *NavigationServiceLocationRequest) (*NavigationServiceLocationResponse, error)
	NavigationServiceWaypoints(context.Context, *NavigationServiceWaypointsRequest) (*NavigationServiceWaypointsResponse, error)
	NavigationServiceAddWaypoint(context.Context, *NavigationServiceAddWaypointRequest) (*NavigationServiceAddWaypointResponse, error)
	NavigationServiceRemoveWaypoint(context.Context, *NavigationServiceRemoveWaypointRequest) (*NavigationServiceRemoveWaypointResponse, error)
	ObjectManipulationServiceDoGrab(context.Context, *ObjectManipulationServiceDoGrabRequest) (*ObjectManipulationServiceDoGrabResponse, error)
	// IMUAngularVelocity returns the most recent angular velocity reading from the given IMU.
	IMUAngularVelocity(context.Context, *IMUAngularVelocityRequest) (*IMUAngularVelocityResponse, error)
	// IMUOrientation returns the most recent orientation reading from the given IMU.
	IMUOrientation(context.Context, *IMUOrientationRequest) (*IMUOrientationResponse, error)
	// GPSLocation returns the most recent location from the given GPS.
	GPSLocation(context.Context, *GPSLocationRequest) (*GPSLocationResponse, error)
	// GPSAltitude returns the most recent altitude from the given GPS.
	GPSAltitude(context.Context, *GPSAltitudeRequest) (*GPSAltitudeResponse, error)
	// GPSSpeed returns the most recent speed from the given GPS.
	GPSSpeed(context.Context, *GPSSpeedRequest) (*GPSSpeedResponse, error)
	// GPSAccuracy returns the most recent location accuracy from the given GPS.
	GPSAccuracy(context.Context, *GPSAccuracyRequest) (*GPSAccuracyResponse, error)
	mustEmbedUnimplementedRobotServiceServer()
}

// UnimplementedRobotServiceServer must be embedded to have forward compatible implementations.
type UnimplementedRobotServiceServer struct {
}

func (UnimplementedRobotServiceServer) Status(context.Context, *StatusRequest) (*StatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedRobotServiceServer) StatusStream(*StatusStreamRequest, RobotService_StatusStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method StatusStream not implemented")
}
func (UnimplementedRobotServiceServer) Config(context.Context, *ConfigRequest) (*ConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedRobotServiceServer) DoAction(context.Context, *DoActionRequest) (*DoActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DoAction not implemented")
}
func (UnimplementedRobotServiceServer) BaseMoveStraight(context.Context, *BaseMoveStraightRequest) (*BaseMoveStraightResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseMoveStraight not implemented")
}
func (UnimplementedRobotServiceServer) BaseMoveArc(context.Context, *BaseMoveArcRequest) (*BaseMoveArcResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseMoveArc not implemented")
}
func (UnimplementedRobotServiceServer) BaseSpin(context.Context, *BaseSpinRequest) (*BaseSpinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseSpin not implemented")
}
func (UnimplementedRobotServiceServer) BaseStop(context.Context, *BaseStopRequest) (*BaseStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseStop not implemented")
}
func (UnimplementedRobotServiceServer) BaseWidthMillis(context.Context, *BaseWidthMillisRequest) (*BaseWidthMillisResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BaseWidthMillis not implemented")
}
func (UnimplementedRobotServiceServer) LidarInfo(context.Context, *LidarInfoRequest) (*LidarInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarInfo not implemented")
}
func (UnimplementedRobotServiceServer) LidarStart(context.Context, *LidarStartRequest) (*LidarStartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarStart not implemented")
}
func (UnimplementedRobotServiceServer) LidarStop(context.Context, *LidarStopRequest) (*LidarStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarStop not implemented")
}
func (UnimplementedRobotServiceServer) LidarScan(context.Context, *LidarScanRequest) (*LidarScanResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarScan not implemented")
}
func (UnimplementedRobotServiceServer) LidarRange(context.Context, *LidarRangeRequest) (*LidarRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarRange not implemented")
}
func (UnimplementedRobotServiceServer) LidarBounds(context.Context, *LidarBoundsRequest) (*LidarBoundsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarBounds not implemented")
}
func (UnimplementedRobotServiceServer) LidarAngularResolution(context.Context, *LidarAngularResolutionRequest) (*LidarAngularResolutionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LidarAngularResolution not implemented")
}
func (UnimplementedRobotServiceServer) BoardStatus(context.Context, *BoardStatusRequest) (*BoardStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardStatus not implemented")
}
func (UnimplementedRobotServiceServer) BoardGPIOSet(context.Context, *BoardGPIOSetRequest) (*BoardGPIOSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardGPIOSet not implemented")
}
func (UnimplementedRobotServiceServer) BoardGPIOGet(context.Context, *BoardGPIOGetRequest) (*BoardGPIOGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardGPIOGet not implemented")
}
func (UnimplementedRobotServiceServer) BoardPWMSet(context.Context, *BoardPWMSetRequest) (*BoardPWMSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardPWMSet not implemented")
}
func (UnimplementedRobotServiceServer) BoardPWMSetFrequency(context.Context, *BoardPWMSetFrequencyRequest) (*BoardPWMSetFrequencyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardPWMSetFrequency not implemented")
}
func (UnimplementedRobotServiceServer) BoardAnalogReaderRead(context.Context, *BoardAnalogReaderReadRequest) (*BoardAnalogReaderReadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardAnalogReaderRead not implemented")
}
func (UnimplementedRobotServiceServer) BoardDigitalInterruptConfig(context.Context, *BoardDigitalInterruptConfigRequest) (*BoardDigitalInterruptConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardDigitalInterruptConfig not implemented")
}
func (UnimplementedRobotServiceServer) BoardDigitalInterruptValue(context.Context, *BoardDigitalInterruptValueRequest) (*BoardDigitalInterruptValueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardDigitalInterruptValue not implemented")
}
func (UnimplementedRobotServiceServer) BoardDigitalInterruptTick(context.Context, *BoardDigitalInterruptTickRequest) (*BoardDigitalInterruptTickResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BoardDigitalInterruptTick not implemented")
}
func (UnimplementedRobotServiceServer) SensorReadings(context.Context, *SensorReadingsRequest) (*SensorReadingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SensorReadings not implemented")
}
func (UnimplementedRobotServiceServer) CompassHeading(context.Context, *CompassHeadingRequest) (*CompassHeadingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassHeading not implemented")
}
func (UnimplementedRobotServiceServer) CompassStartCalibration(context.Context, *CompassStartCalibrationRequest) (*CompassStartCalibrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassStartCalibration not implemented")
}
func (UnimplementedRobotServiceServer) CompassStopCalibration(context.Context, *CompassStopCalibrationRequest) (*CompassStopCalibrationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassStopCalibration not implemented")
}
func (UnimplementedRobotServiceServer) CompassMark(context.Context, *CompassMarkRequest) (*CompassMarkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompassMark not implemented")
}
func (UnimplementedRobotServiceServer) ForceMatrixMatrix(context.Context, *ForceMatrixMatrixRequest) (*ForceMatrixMatrixResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceMatrixMatrix not implemented")
}
func (UnimplementedRobotServiceServer) ForceMatrixSlipDetection(context.Context, *ForceMatrixSlipDetectionRequest) (*ForceMatrixSlipDetectionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceMatrixSlipDetection not implemented")
}
func (UnimplementedRobotServiceServer) ExecuteFunction(context.Context, *ExecuteFunctionRequest) (*ExecuteFunctionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteFunction not implemented")
}
func (UnimplementedRobotServiceServer) ExecuteSource(context.Context, *ExecuteSourceRequest) (*ExecuteSourceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteSource not implemented")
}
func (UnimplementedRobotServiceServer) MotorGetPIDConfig(context.Context, *MotorGetPIDConfigRequest) (*MotorGetPIDConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorGetPIDConfig not implemented")
}
func (UnimplementedRobotServiceServer) MotorSetPIDConfig(context.Context, *MotorSetPIDConfigRequest) (*MotorSetPIDConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorSetPIDConfig not implemented")
}
func (UnimplementedRobotServiceServer) MotorPIDStep(*MotorPIDStepRequest, RobotService_MotorPIDStepServer) error {
	return status.Errorf(codes.Unimplemented, "method MotorPIDStep not implemented")
}
func (UnimplementedRobotServiceServer) MotorPower(context.Context, *MotorPowerRequest) (*MotorPowerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorPower not implemented")
}
func (UnimplementedRobotServiceServer) MotorGo(context.Context, *MotorGoRequest) (*MotorGoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorGo not implemented")
}
func (UnimplementedRobotServiceServer) MotorGoFor(context.Context, *MotorGoForRequest) (*MotorGoForResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorGoFor not implemented")
}
func (UnimplementedRobotServiceServer) MotorGoTo(context.Context, *MotorGoToRequest) (*MotorGoToResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorGoTo not implemented")
}
func (UnimplementedRobotServiceServer) MotorGoTillStop(context.Context, *MotorGoTillStopRequest) (*MotorGoTillStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorGoTillStop not implemented")
}
func (UnimplementedRobotServiceServer) MotorZero(context.Context, *MotorZeroRequest) (*MotorZeroResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorZero not implemented")
}
func (UnimplementedRobotServiceServer) MotorPosition(context.Context, *MotorPositionRequest) (*MotorPositionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorPosition not implemented")
}
func (UnimplementedRobotServiceServer) MotorPositionSupported(context.Context, *MotorPositionSupportedRequest) (*MotorPositionSupportedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorPositionSupported not implemented")
}
func (UnimplementedRobotServiceServer) MotorOff(context.Context, *MotorOffRequest) (*MotorOffResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorOff not implemented")
}
func (UnimplementedRobotServiceServer) MotorIsOn(context.Context, *MotorIsOnRequest) (*MotorIsOnResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MotorIsOn not implemented")
}
func (UnimplementedRobotServiceServer) InputControllerControls(context.Context, *InputControllerControlsRequest) (*InputControllerControlsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InputControllerControls not implemented")
}
func (UnimplementedRobotServiceServer) InputControllerLastEvents(context.Context, *InputControllerLastEventsRequest) (*InputControllerLastEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InputControllerLastEvents not implemented")
}
func (UnimplementedRobotServiceServer) InputControllerEventStream(*InputControllerEventStreamRequest, RobotService_InputControllerEventStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InputControllerEventStream not implemented")
}
func (UnimplementedRobotServiceServer) InputControllerInjectEvent(context.Context, *InputControllerInjectEventRequest) (*InputControllerInjectEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InputControllerInjectEvent not implemented")
}
func (UnimplementedRobotServiceServer) ResourceRunCommand(context.Context, *ResourceRunCommandRequest) (*ResourceRunCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResourceRunCommand not implemented")
}
func (UnimplementedRobotServiceServer) FrameServiceConfig(context.Context, *FrameServiceConfigRequest) (*FrameServiceConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FrameServiceConfig not implemented")
}
func (UnimplementedRobotServiceServer) NavigationServiceMode(context.Context, *NavigationServiceModeRequest) (*NavigationServiceModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavigationServiceMode not implemented")
}
func (UnimplementedRobotServiceServer) NavigationServiceSetMode(context.Context, *NavigationServiceSetModeRequest) (*NavigationServiceSetModeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavigationServiceSetMode not implemented")
}
func (UnimplementedRobotServiceServer) NavigationServiceLocation(context.Context, *NavigationServiceLocationRequest) (*NavigationServiceLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavigationServiceLocation not implemented")
}
func (UnimplementedRobotServiceServer) NavigationServiceWaypoints(context.Context, *NavigationServiceWaypointsRequest) (*NavigationServiceWaypointsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavigationServiceWaypoints not implemented")
}
func (UnimplementedRobotServiceServer) NavigationServiceAddWaypoint(context.Context, *NavigationServiceAddWaypointRequest) (*NavigationServiceAddWaypointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavigationServiceAddWaypoint not implemented")
}
func (UnimplementedRobotServiceServer) NavigationServiceRemoveWaypoint(context.Context, *NavigationServiceRemoveWaypointRequest) (*NavigationServiceRemoveWaypointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NavigationServiceRemoveWaypoint not implemented")
}
func (UnimplementedRobotServiceServer) ObjectManipulationServiceDoGrab(context.Context, *ObjectManipulationServiceDoGrabRequest) (*ObjectManipulationServiceDoGrabResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ObjectManipulationServiceDoGrab not implemented")
}
func (UnimplementedRobotServiceServer) IMUAngularVelocity(context.Context, *IMUAngularVelocityRequest) (*IMUAngularVelocityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IMUAngularVelocity not implemented")
}
func (UnimplementedRobotServiceServer) IMUOrientation(context.Context, *IMUOrientationRequest) (*IMUOrientationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IMUOrientation not implemented")
}
func (UnimplementedRobotServiceServer) GPSLocation(context.Context, *GPSLocationRequest) (*GPSLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPSLocation not implemented")
}
func (UnimplementedRobotServiceServer) GPSAltitude(context.Context, *GPSAltitudeRequest) (*GPSAltitudeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPSAltitude not implemented")
}
func (UnimplementedRobotServiceServer) GPSSpeed(context.Context, *GPSSpeedRequest) (*GPSSpeedResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPSSpeed not implemented")
}
func (UnimplementedRobotServiceServer) GPSAccuracy(context.Context, *GPSAccuracyRequest) (*GPSAccuracyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPSAccuracy not implemented")
}
func (UnimplementedRobotServiceServer) mustEmbedUnimplementedRobotServiceServer() {}

// UnsafeRobotServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RobotServiceServer will
// result in compilation errors.
type UnsafeRobotServiceServer interface {
	mustEmbedUnimplementedRobotServiceServer()
}

func RegisterRobotServiceServer(s grpc.ServiceRegistrar, srv RobotServiceServer) {
	s.RegisterService(&RobotService_ServiceDesc, srv)
}

func _RobotService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/Status",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).Status(ctx, req.(*StatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_StatusStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StatusStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotServiceServer).StatusStream(m, &robotServiceStatusStreamServer{stream})
}

type RobotService_StatusStreamServer interface {
	Send(*StatusStreamResponse) error
	grpc.ServerStream
}

type robotServiceStatusStreamServer struct {
	grpc.ServerStream
}

func (x *robotServiceStatusStreamServer) Send(m *StatusStreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RobotService_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/Config",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).Config(ctx, req.(*ConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_DoAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DoActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).DoAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/DoAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).DoAction(ctx, req.(*DoActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseMoveStraight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseMoveStraightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseMoveStraight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseMoveStraight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseMoveStraight(ctx, req.(*BaseMoveStraightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseMoveArc_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseMoveArcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseMoveArc(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseMoveArc",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseMoveArc(ctx, req.(*BaseMoveArcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseSpin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseSpinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseSpin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseSpin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseSpin(ctx, req.(*BaseSpinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseStop(ctx, req.(*BaseStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BaseWidthMillis_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BaseWidthMillisRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BaseWidthMillis(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BaseWidthMillis",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BaseWidthMillis(ctx, req.(*BaseWidthMillisRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarInfo(ctx, req.(*LidarInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarStart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarStartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarStart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarStart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarStart(ctx, req.(*LidarStartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarStop(ctx, req.(*LidarStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarScan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarScanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarScan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarScan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarScan(ctx, req.(*LidarScanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarRange(ctx, req.(*LidarRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarBounds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarBoundsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarBounds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarBounds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarBounds(ctx, req.(*LidarBoundsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_LidarAngularResolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LidarAngularResolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).LidarAngularResolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/LidarAngularResolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).LidarAngularResolution(ctx, req.(*LidarAngularResolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardStatus(ctx, req.(*BoardStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardGPIOSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardGPIOSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardGPIOSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardGPIOSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardGPIOSet(ctx, req.(*BoardGPIOSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardGPIOGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardGPIOGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardGPIOGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardGPIOGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardGPIOGet(ctx, req.(*BoardGPIOGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardPWMSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardPWMSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardPWMSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardPWMSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardPWMSet(ctx, req.(*BoardPWMSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardPWMSetFrequency_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardPWMSetFrequencyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardPWMSetFrequency(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardPWMSetFrequency",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardPWMSetFrequency(ctx, req.(*BoardPWMSetFrequencyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardAnalogReaderRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardAnalogReaderReadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardAnalogReaderRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardAnalogReaderRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardAnalogReaderRead(ctx, req.(*BoardAnalogReaderReadRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardDigitalInterruptConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardDigitalInterruptConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardDigitalInterruptConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardDigitalInterruptConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardDigitalInterruptConfig(ctx, req.(*BoardDigitalInterruptConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardDigitalInterruptValue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardDigitalInterruptValueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardDigitalInterruptValue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardDigitalInterruptValue",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardDigitalInterruptValue(ctx, req.(*BoardDigitalInterruptValueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_BoardDigitalInterruptTick_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BoardDigitalInterruptTickRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).BoardDigitalInterruptTick(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/BoardDigitalInterruptTick",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).BoardDigitalInterruptTick(ctx, req.(*BoardDigitalInterruptTickRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_SensorReadings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SensorReadingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).SensorReadings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/SensorReadings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).SensorReadings(ctx, req.(*SensorReadingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassHeading_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassHeadingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassHeading(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassHeading",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassHeading(ctx, req.(*CompassHeadingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassStartCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassStartCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassStartCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassStartCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassStartCalibration(ctx, req.(*CompassStartCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassStopCalibration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassStopCalibrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassStopCalibration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassStopCalibration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassStopCalibration(ctx, req.(*CompassStopCalibrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_CompassMark_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompassMarkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).CompassMark(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/CompassMark",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).CompassMark(ctx, req.(*CompassMarkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ForceMatrixMatrix_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceMatrixMatrixRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ForceMatrixMatrix(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ForceMatrixMatrix",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ForceMatrixMatrix(ctx, req.(*ForceMatrixMatrixRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ForceMatrixSlipDetection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceMatrixSlipDetectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ForceMatrixSlipDetection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ForceMatrixSlipDetection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ForceMatrixSlipDetection(ctx, req.(*ForceMatrixSlipDetectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ExecuteFunction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteFunctionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ExecuteFunction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ExecuteFunction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ExecuteFunction(ctx, req.(*ExecuteFunctionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ExecuteSource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteSourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ExecuteSource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ExecuteSource",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ExecuteSource(ctx, req.(*ExecuteSourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorGetPIDConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorGetPIDConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorGetPIDConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorGetPIDConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorGetPIDConfig(ctx, req.(*MotorGetPIDConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorSetPIDConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorSetPIDConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorSetPIDConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorSetPIDConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorSetPIDConfig(ctx, req.(*MotorSetPIDConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorPIDStep_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MotorPIDStepRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotServiceServer).MotorPIDStep(m, &robotServiceMotorPIDStepServer{stream})
}

type RobotService_MotorPIDStepServer interface {
	Send(*MotorPIDStepResponse) error
	grpc.ServerStream
}

type robotServiceMotorPIDStepServer struct {
	grpc.ServerStream
}

func (x *robotServiceMotorPIDStepServer) Send(m *MotorPIDStepResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RobotService_MotorPower_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorPowerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorPower(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorPower",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorPower(ctx, req.(*MotorPowerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorGo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorGoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorGo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorGo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorGo(ctx, req.(*MotorGoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorGoFor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorGoForRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorGoFor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorGoFor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorGoFor(ctx, req.(*MotorGoForRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorGoTo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorGoToRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorGoTo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorGoTo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorGoTo(ctx, req.(*MotorGoToRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorGoTillStop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorGoTillStopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorGoTillStop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorGoTillStop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorGoTillStop(ctx, req.(*MotorGoTillStopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorZero_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorZeroRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorZero(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorZero",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorZero(ctx, req.(*MotorZeroRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorPosition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorPositionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorPosition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorPosition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorPosition(ctx, req.(*MotorPositionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorPositionSupported_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorPositionSupportedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorPositionSupported(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorPositionSupported",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorPositionSupported(ctx, req.(*MotorPositionSupportedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorOff_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorOffRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorOff(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorOff",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorOff(ctx, req.(*MotorOffRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_MotorIsOn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MotorIsOnRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).MotorIsOn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/MotorIsOn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).MotorIsOn(ctx, req.(*MotorIsOnRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_InputControllerControls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputControllerControlsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).InputControllerControls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/InputControllerControls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).InputControllerControls(ctx, req.(*InputControllerControlsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_InputControllerLastEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputControllerLastEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).InputControllerLastEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/InputControllerLastEvents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).InputControllerLastEvents(ctx, req.(*InputControllerLastEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_InputControllerEventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InputControllerEventStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RobotServiceServer).InputControllerEventStream(m, &robotServiceInputControllerEventStreamServer{stream})
}

type RobotService_InputControllerEventStreamServer interface {
	Send(*InputControllerEvent) error
	grpc.ServerStream
}

type robotServiceInputControllerEventStreamServer struct {
	grpc.ServerStream
}

func (x *robotServiceInputControllerEventStreamServer) Send(m *InputControllerEvent) error {
	return x.ServerStream.SendMsg(m)
}

func _RobotService_InputControllerInjectEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InputControllerInjectEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).InputControllerInjectEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/InputControllerInjectEvent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).InputControllerInjectEvent(ctx, req.(*InputControllerInjectEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ResourceRunCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceRunCommandRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ResourceRunCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ResourceRunCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ResourceRunCommand(ctx, req.(*ResourceRunCommandRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_FrameServiceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FrameServiceConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).FrameServiceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/FrameServiceConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).FrameServiceConfig(ctx, req.(*FrameServiceConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_NavigationServiceMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationServiceModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).NavigationServiceMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/NavigationServiceMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).NavigationServiceMode(ctx, req.(*NavigationServiceModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_NavigationServiceSetMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationServiceSetModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).NavigationServiceSetMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/NavigationServiceSetMode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).NavigationServiceSetMode(ctx, req.(*NavigationServiceSetModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_NavigationServiceLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationServiceLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).NavigationServiceLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/NavigationServiceLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).NavigationServiceLocation(ctx, req.(*NavigationServiceLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_NavigationServiceWaypoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationServiceWaypointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).NavigationServiceWaypoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/NavigationServiceWaypoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).NavigationServiceWaypoints(ctx, req.(*NavigationServiceWaypointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_NavigationServiceAddWaypoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationServiceAddWaypointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).NavigationServiceAddWaypoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/NavigationServiceAddWaypoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).NavigationServiceAddWaypoint(ctx, req.(*NavigationServiceAddWaypointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_NavigationServiceRemoveWaypoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NavigationServiceRemoveWaypointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).NavigationServiceRemoveWaypoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/NavigationServiceRemoveWaypoint",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).NavigationServiceRemoveWaypoint(ctx, req.(*NavigationServiceRemoveWaypointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_ObjectManipulationServiceDoGrab_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ObjectManipulationServiceDoGrabRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).ObjectManipulationServiceDoGrab(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/ObjectManipulationServiceDoGrab",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).ObjectManipulationServiceDoGrab(ctx, req.(*ObjectManipulationServiceDoGrabRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_IMUAngularVelocity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IMUAngularVelocityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).IMUAngularVelocity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/IMUAngularVelocity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).IMUAngularVelocity(ctx, req.(*IMUAngularVelocityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_IMUOrientation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IMUOrientationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).IMUOrientation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/IMUOrientation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).IMUOrientation(ctx, req.(*IMUOrientationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_GPSLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPSLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).GPSLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/GPSLocation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).GPSLocation(ctx, req.(*GPSLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_GPSAltitude_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPSAltitudeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).GPSAltitude(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/GPSAltitude",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).GPSAltitude(ctx, req.(*GPSAltitudeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_GPSSpeed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPSSpeedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).GPSSpeed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/GPSSpeed",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).GPSSpeed(ctx, req.(*GPSSpeedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RobotService_GPSAccuracy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GPSAccuracyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RobotServiceServer).GPSAccuracy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/proto.api.v1.RobotService/GPSAccuracy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RobotServiceServer).GPSAccuracy(ctx, req.(*GPSAccuracyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RobotService_ServiceDesc is the grpc.ServiceDesc for RobotService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RobotService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "proto.api.v1.RobotService",
	HandlerType: (*RobotServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _RobotService_Status_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _RobotService_Config_Handler,
		},
		{
			MethodName: "DoAction",
			Handler:    _RobotService_DoAction_Handler,
		},
		{
			MethodName: "BaseMoveStraight",
			Handler:    _RobotService_BaseMoveStraight_Handler,
		},
		{
			MethodName: "BaseMoveArc",
			Handler:    _RobotService_BaseMoveArc_Handler,
		},
		{
			MethodName: "BaseSpin",
			Handler:    _RobotService_BaseSpin_Handler,
		},
		{
			MethodName: "BaseStop",
			Handler:    _RobotService_BaseStop_Handler,
		},
		{
			MethodName: "BaseWidthMillis",
			Handler:    _RobotService_BaseWidthMillis_Handler,
		},
		{
			MethodName: "LidarInfo",
			Handler:    _RobotService_LidarInfo_Handler,
		},
		{
			MethodName: "LidarStart",
			Handler:    _RobotService_LidarStart_Handler,
		},
		{
			MethodName: "LidarStop",
			Handler:    _RobotService_LidarStop_Handler,
		},
		{
			MethodName: "LidarScan",
			Handler:    _RobotService_LidarScan_Handler,
		},
		{
			MethodName: "LidarRange",
			Handler:    _RobotService_LidarRange_Handler,
		},
		{
			MethodName: "LidarBounds",
			Handler:    _RobotService_LidarBounds_Handler,
		},
		{
			MethodName: "LidarAngularResolution",
			Handler:    _RobotService_LidarAngularResolution_Handler,
		},
		{
			MethodName: "BoardStatus",
			Handler:    _RobotService_BoardStatus_Handler,
		},
		{
			MethodName: "BoardGPIOSet",
			Handler:    _RobotService_BoardGPIOSet_Handler,
		},
		{
			MethodName: "BoardGPIOGet",
			Handler:    _RobotService_BoardGPIOGet_Handler,
		},
		{
			MethodName: "BoardPWMSet",
			Handler:    _RobotService_BoardPWMSet_Handler,
		},
		{
			MethodName: "BoardPWMSetFrequency",
			Handler:    _RobotService_BoardPWMSetFrequency_Handler,
		},
		{
			MethodName: "BoardAnalogReaderRead",
			Handler:    _RobotService_BoardAnalogReaderRead_Handler,
		},
		{
			MethodName: "BoardDigitalInterruptConfig",
			Handler:    _RobotService_BoardDigitalInterruptConfig_Handler,
		},
		{
			MethodName: "BoardDigitalInterruptValue",
			Handler:    _RobotService_BoardDigitalInterruptValue_Handler,
		},
		{
			MethodName: "BoardDigitalInterruptTick",
			Handler:    _RobotService_BoardDigitalInterruptTick_Handler,
		},
		{
			MethodName: "SensorReadings",
			Handler:    _RobotService_SensorReadings_Handler,
		},
		{
			MethodName: "CompassHeading",
			Handler:    _RobotService_CompassHeading_Handler,
		},
		{
			MethodName: "CompassStartCalibration",
			Handler:    _RobotService_CompassStartCalibration_Handler,
		},
		{
			MethodName: "CompassStopCalibration",
			Handler:    _RobotService_CompassStopCalibration_Handler,
		},
		{
			MethodName: "CompassMark",
			Handler:    _RobotService_CompassMark_Handler,
		},
		{
			MethodName: "ForceMatrixMatrix",
			Handler:    _RobotService_ForceMatrixMatrix_Handler,
		},
		{
			MethodName: "ForceMatrixSlipDetection",
			Handler:    _RobotService_ForceMatrixSlipDetection_Handler,
		},
		{
			MethodName: "ExecuteFunction",
			Handler:    _RobotService_ExecuteFunction_Handler,
		},
		{
			MethodName: "ExecuteSource",
			Handler:    _RobotService_ExecuteSource_Handler,
		},
		{
			MethodName: "MotorGetPIDConfig",
			Handler:    _RobotService_MotorGetPIDConfig_Handler,
		},
		{
			MethodName: "MotorSetPIDConfig",
			Handler:    _RobotService_MotorSetPIDConfig_Handler,
		},
		{
			MethodName: "MotorPower",
			Handler:    _RobotService_MotorPower_Handler,
		},
		{
			MethodName: "MotorGo",
			Handler:    _RobotService_MotorGo_Handler,
		},
		{
			MethodName: "MotorGoFor",
			Handler:    _RobotService_MotorGoFor_Handler,
		},
		{
			MethodName: "MotorGoTo",
			Handler:    _RobotService_MotorGoTo_Handler,
		},
		{
			MethodName: "MotorGoTillStop",
			Handler:    _RobotService_MotorGoTillStop_Handler,
		},
		{
			MethodName: "MotorZero",
			Handler:    _RobotService_MotorZero_Handler,
		},
		{
			MethodName: "MotorPosition",
			Handler:    _RobotService_MotorPosition_Handler,
		},
		{
			MethodName: "MotorPositionSupported",
			Handler:    _RobotService_MotorPositionSupported_Handler,
		},
		{
			MethodName: "MotorOff",
			Handler:    _RobotService_MotorOff_Handler,
		},
		{
			MethodName: "MotorIsOn",
			Handler:    _RobotService_MotorIsOn_Handler,
		},
		{
			MethodName: "InputControllerControls",
			Handler:    _RobotService_InputControllerControls_Handler,
		},
		{
			MethodName: "InputControllerLastEvents",
			Handler:    _RobotService_InputControllerLastEvents_Handler,
		},
		{
			MethodName: "InputControllerInjectEvent",
			Handler:    _RobotService_InputControllerInjectEvent_Handler,
		},
		{
			MethodName: "ResourceRunCommand",
			Handler:    _RobotService_ResourceRunCommand_Handler,
		},
		{
			MethodName: "FrameServiceConfig",
			Handler:    _RobotService_FrameServiceConfig_Handler,
		},
		{
			MethodName: "NavigationServiceMode",
			Handler:    _RobotService_NavigationServiceMode_Handler,
		},
		{
			MethodName: "NavigationServiceSetMode",
			Handler:    _RobotService_NavigationServiceSetMode_Handler,
		},
		{
			MethodName: "NavigationServiceLocation",
			Handler:    _RobotService_NavigationServiceLocation_Handler,
		},
		{
			MethodName: "NavigationServiceWaypoints",
			Handler:    _RobotService_NavigationServiceWaypoints_Handler,
		},
		{
			MethodName: "NavigationServiceAddWaypoint",
			Handler:    _RobotService_NavigationServiceAddWaypoint_Handler,
		},
		{
			MethodName: "NavigationServiceRemoveWaypoint",
			Handler:    _RobotService_NavigationServiceRemoveWaypoint_Handler,
		},
		{
			MethodName: "ObjectManipulationServiceDoGrab",
			Handler:    _RobotService_ObjectManipulationServiceDoGrab_Handler,
		},
		{
			MethodName: "IMUAngularVelocity",
			Handler:    _RobotService_IMUAngularVelocity_Handler,
		},
		{
			MethodName: "IMUOrientation",
			Handler:    _RobotService_IMUOrientation_Handler,
		},
		{
			MethodName: "GPSLocation",
			Handler:    _RobotService_GPSLocation_Handler,
		},
		{
			MethodName: "GPSAltitude",
			Handler:    _RobotService_GPSAltitude_Handler,
		},
		{
			MethodName: "GPSSpeed",
			Handler:    _RobotService_GPSSpeed_Handler,
		},
		{
			MethodName: "GPSAccuracy",
			Handler:    _RobotService_GPSAccuracy_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StatusStream",
			Handler:       _RobotService_StatusStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MotorPIDStep",
			Handler:       _RobotService_MotorPIDStep_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InputControllerEventStream",
			Handler:       _RobotService_InputControllerEventStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/api/v1/robot.proto",
}
