syntax = "proto3";
option go_package = "go.viam.com/core/proto/api/v1";
option java_package = "com.viam.core.proto.api.v1";

package proto.api.v1;

import "google/protobuf/struct.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/api/annotations.proto";


// A RobotService encompasses all functionality of some robot comprised of parts, local and remote.
service RobotService {
  // Status returns the robot's underlying status.
  rpc Status(StatusRequest) returns (StatusResponse) {
      option (google.api.http) = {
        get: "/api/v1/status"
    };
  }

  // StatusStream periodically sends the robot's status.
  rpc StatusStream(StatusStreamRequest) returns (stream StatusStreamResponse) {
      option (google.api.http) = {
        get: "/api/v1/status_stream"
    };
  }

  // Config gets the config from a server
  // It is only partial a config, including the pieces relevant to remote robots,
  // And not the pieces relevant to local configuration (pins, security keys, etc...)
  rpc Config(ConfigRequest) returns (ConfigResponse) {
    option (google.api.http) = {
      get: "/api/v1/config"
    };  
  }

  // DoAction runs an action on the underlying robot.
  rpc DoAction(DoActionRequest) returns (DoActionResponse) {
    option (google.api.http) = {
      post: "/api/v1/do_action"
    };  
  }

  // Base

  // BaseMoveStraight moves a robot's base in a straight line by a given distance, expressed in millimeters
  // and a given speed, expressed in millimeters per second 
  rpc BaseMoveStraight(BaseMoveStraightRequest) returns (BaseMoveStraightResponse) {
    option (google.api.http) = {
      post: "/api/v1/base/{name}/move_straight"
    };  
  }

// MoveArc moves the robot's base in an arc by a given distance, expressed in millimeters,
// a given speed, expressed in millimeters per second of movement, and a given angle exoressed in degrees
  rpc BaseMoveArc(BaseMoveArcRequest) returns (BaseMoveArcResponse) {
    option (google.api.http) = {
      post: "/api/v1/base/{name}/move_arc"
    };  
  }

  // BaseSpin spins a robot's base by an given angle, expressed in degrees, and a given 
  // angular speed, expressed in degrees per second
  rpc BaseSpin(BaseSpinRequest) returns (BaseSpinResponse) {
    option (google.api.http) = {
      post: "/api/v1/base/{name}/spin"
    };  
  }

  // BaseStop stops a robot's base 
  rpc BaseStop(BaseStopRequest) returns (BaseStopResponse) {
    option (google.api.http) = {
      post: "/api/v1/base/{name}/stop"
    };  
  }

  // BaseWidthMillis returns the width of a robot's base expressed in millimeters
  rpc BaseWidthMillis(BaseWidthMillisRequest) returns (BaseWidthMillisResponse) {
    option (google.api.http) = {
      get: "/api/v1/base/{name}/width_millis"
    };  
  }

  // Board

  // BoardStatus returns the status of a board of the underlying robot.
  rpc BoardStatus(BoardStatusRequest) returns (BoardStatusResponse) {
    option (google.api.http) = {
      get: "/api/v1/board/{name}/status"
    };  
  }

  // BoardGPIOSet sets a given pin on a robot's board to either high or low
  rpc BoardGPIOSet(BoardGPIOSetRequest) returns (BoardGPIOSetResponse) {
    option (google.api.http) = {
      put: "/api/v1/board/{name}/gpio_set"
    };  
  }

  // BoardGPIOGet gets the high/low state of a given pin on a robot's board
  rpc BoardGPIOGet(BoardGPIOGetRequest) returns (BoardGPIOGetResponse) {
    option (google.api.http) = {
      get: "/api/v1/board/{name}/gpio_get"
    };  
  }

  // BoardPWMSet sets a given pin on a robot's board to a given duty cycle expressed as a value between 0-255 where 255 means that the pin 
  // is high 100% of the time
  rpc BoardPWMSet(BoardPWMSetRequest) returns (BoardPWMSetResponse) {
    option (google.api.http) = {
      put: "/api/v1/board/{name}/pwm_set"
    };  
  }

  // BoardPWMSetFrequency sets a given pin of a robot's board to a specified PWM frequency expressed in hertz 
  // (cycles per second). 0 will use the board's default PWM frequency
  rpc BoardPWMSetFrequency(BoardPWMSetFrequencyRequest) returns (BoardPWMSetFrequencyResponse) {
    option (google.api.http) = {
      put: "/api/v1/board/{name}/pwm_set_freq"
    };  
  }

  // Analog Reader

  // BoardAnalogReaderRead returns the value at the time that the request was recieved
  // of a specified analog reader on the robot's board
  rpc BoardAnalogReaderRead(BoardAnalogReaderReadRequest) returns (BoardAnalogReaderReadResponse) {
    option (google.api.http) = {
      get: "/api/v1/board/{board_name}/analog_reader/{analog_reader_name}/read"
    };
  }

  // Digital Interrupt

  // BoardDigitalInterruptConfig returns the config the interrupt was created with.
  rpc BoardDigitalInterruptConfig(BoardDigitalInterruptConfigRequest) returns (BoardDigitalInterruptConfigResponse) {
    option (google.api.http) = {
      get: "/api/v1/board/{board_name}/digital_interrupt/{digital_interrupt_name}/config"
    };
  }

  // BoardDigitalInterruptValue returns the value of the interrupt based on the driver. Very often, this is the number of ticks that have 
  // occurred since startup. To Do (FA): This will be removed from proto

  rpc BoardDigitalInterruptValue(BoardDigitalInterruptValueRequest) returns (BoardDigitalInterruptValueResponse) {
    option (google.api.http) = {
      get: "/api/v1/board/{board_name}/digital_interrupt/{digital_interrupt_name}/value"
    };
  }

  // BoardDigitalInterruptTick manually signals the given interrupt is high or low at a given time to be called either manually if the 
  // interrupt is a proxy to some real hardware interrupt or for tests . To Do: This will be removed from proto
  rpc BoardDigitalInterruptTick(BoardDigitalInterruptTickRequest) returns (BoardDigitalInterruptTickResponse) {
    option (google.api.http) = {
      put: "/api/v1/board/{board_name}/digital_interrupt/{digital_interrupt_name}/tick"
    };
  }

  // Sensor

  // SensorReadings returns the readings of a sensor of the underlying robot.
  rpc SensorReadings(SensorReadingsRequest) returns (SensorReadingsResponse) {
    option (google.api.http) = {
      get: "/api/v1/sensors/sensor/{name}/readings"
    };  
  }

  // Compass

  // CompassHeading returns the heading of a compass of the underlying robot.
  rpc CompassHeading(CompassHeadingRequest) returns (CompassHeadingResponse) {
      option (google.api.http) = {
      get: "/api/v1/sensors/compass/{name}/heading"
    };
  }

  // CompassStartCalibration requests the compass of the underlying robot to start calibration.
  rpc CompassStartCalibration(CompassStartCalibrationRequest) returns (CompassStartCalibrationResponse) {
    option (google.api.http) = {
      post: "/api/v1/sensors/compass/{name}/start_calibration"
    };
  }

  // CompassStopCalibration requests the compass of the underlying robot to stop calibration.
  rpc CompassStopCalibration(CompassStopCalibrationRequest) returns (CompassStopCalibrationResponse) {
    option (google.api.http) = {
      post: "/api/v1/sensors/compass/{name}/stop_calibration"
    };
  }

  // Relative Compass

  // CompassMark requests the relative compass of the underlying robot to mark its position.
  rpc CompassMark(CompassMarkRequest) returns (CompassMarkResponse) {
    option (google.api.http) = {
      post: "/api/v1/sensors/compass/{name}/mark"
    };
  }

  // Force Sensor Matrix

  // ForceMatrixMatrix returns the matrix of force readings from the force matrix sensor
  rpc ForceMatrixMatrix(ForceMatrixMatrixRequest) returns (ForceMatrixMatrixResponse) {
    option (google.api.http) = {
      get : "/api/v1/sensors/forcematrix/{name}/matrix"
    };
  }

  rpc ForceMatrixSlipDetection(ForceMatrixSlipDetectionRequest) returns (ForceMatrixSlipDetectionResponse) {
    option (google.api.http) = {
      get : "/api/v1/sensors/forcematrix/{name}/slip_detection"
    };
  }

  // TODO(erd): refactor to functions service
  rpc ExecuteFunction(ExecuteFunctionRequest) returns (ExecuteFunctionResponse) {
    option (google.api.http) = {
      post: "/api/v1/functions/by_name/{name}/execute"
    }; 
  }

  rpc ExecuteSource(ExecuteSourceRequest) returns (ExecuteSourceResponse) {
    option (google.api.http) = {
      post: "/api/v1/functions/execute_code"
    }; 
  }

  rpc InputControllerControls(InputControllerControlsRequest) returns (InputControllerControlsResponse) {
    option (google.api.http) = {
      get: "/api/v1/input/{controller}/controls"
    };
  }

  // InputControllerLastEvents returns a list of events representing the last event on each control of a give Input Controller
  rpc InputControllerLastEvents(InputControllerLastEventsRequest) returns (InputControllerLastEventsResponse) {
    option (google.api.http) = {
      get: "/api/v1/input/{controller}/last_events"
    };
  }

  // InputControllerEventStream starts a stream of InputControllerEvents for the given controls (buttons/axes) on a robot's input controller 
  rpc InputControllerEventStream(InputControllerEventStreamRequest) returns (stream InputControllerEvent) {
    option (google.api.http) = {
      get: "/api/v1/input/{controller}/event_stream"
    };
  }

  // InputControllerInjectEvent, where supported, injects an InputControllerEvent into an input controller to (virtually) generate events 
  // like button presses or axis movements  
  rpc InputControllerInjectEvent(InputControllerInjectEventRequest) returns (InputControllerInjectEventResponse) {
    option (google.api.http) = {
      post: "/api/v1/input/{controller}/inject_event"
    };
  }

  // ResourceRunCommand runs an arbitrary command on a resource if it supports it.
  rpc ResourceRunCommand(ResourceRunCommandRequest) returns (ResourceRunCommandResponse) {
    option (google.api.http) = {
      post: "/api/v1/resource/{resource_name}/run_command"
    };
  }

  // Frame System Service
  rpc FrameServiceConfig(FrameServiceConfigRequest) returns (FrameServiceConfigResponse) {
    option (google.api.http) = {
      get: "/api/v1/services/frame_system/config"
    };
  }
  
  // Navigation Service
  rpc NavigationServiceMode(NavigationServiceModeRequest) returns (NavigationServiceModeResponse) {
    option (google.api.http) = {
      get: "/api/v1/services/navigation/mode"
    };
  }

  rpc NavigationServiceSetMode(NavigationServiceSetModeRequest) returns (NavigationServiceSetModeResponse) {
    option (google.api.http) = {
      put: "/api/v1/services/navigation/mode"
    };
  }

  rpc NavigationServiceLocation(NavigationServiceLocationRequest) returns (NavigationServiceLocationResponse) {
    option (google.api.http) = {
      get: "/api/v1/services/navigation/location"
    };
  }

  rpc NavigationServiceWaypoints(NavigationServiceWaypointsRequest) returns (NavigationServiceWaypointsResponse) {
    option (google.api.http) = {
      get: "/api/v1/services/navigation/waypoints"
    };
  }

  rpc NavigationServiceAddWaypoint(NavigationServiceAddWaypointRequest) returns (NavigationServiceAddWaypointResponse) {
    option (google.api.http) = {
      post: "/api/v1/services/navigation/waypoints"
    };
  }

  rpc NavigationServiceRemoveWaypoint(NavigationServiceRemoveWaypointRequest) returns (NavigationServiceRemoveWaypointResponse) {
    option (google.api.http) = {
      delete: "/api/v1/services/navigation/waypoints/{id}"
    };
  }

  // Object Manipulation Service

  rpc ObjectManipulationServiceDoGrab(ObjectManipulationServiceDoGrabRequest) returns (ObjectManipulationServiceDoGrabResponse) {
    option (google.api.http) = {
      post: "/api/v1/services/objectmanipulation/do_grab"
    };
  }

  // GPS

  // GPSLocation returns the most recent location from the given GPS.
  rpc GPSLocation(GPSLocationRequest) returns (GPSLocationResponse) {
      option (google.api.http) = {
      get: "/api/v1/sensors/gps/{name}/location"
    };
  }

  // GPSAltitude returns the most recent altitude from the given GPS.
  rpc GPSAltitude(GPSAltitudeRequest) returns (GPSAltitudeResponse) {
      option (google.api.http) = {
      get: "/api/v1/sensors/gps/{name}/altitude"
    };
  }

  // GPSSpeed returns the most recent speed from the given GPS.
  rpc GPSSpeed(GPSSpeedRequest) returns (GPSSpeedResponse) {
      option (google.api.http) = {
      get: "/api/v1/sensors/gps/{name}/speed"
    };
  }

  // GPSAccuracy returns the most recent location accuracy from the given GPS.
  rpc GPSAccuracy(GPSAccuracyRequest) returns (GPSAccuracyResponse) {
      option (google.api.http) = {
      get: "/api/v1/sensors/gps/{name}/accuracy"
    };
  }
}

message StatusRequest {}

message StatusStreamRequest {
  google.protobuf.Duration every = 1; // how often to send a new status.
}

message StatusResponse {
  Status status = 1;
}

message StatusStreamResponse {
  Status status = 1;
}

message Status {
  map<string, ArmStatus> arms = 1;
  map<string, bool> bases = 2;
  map<string, bool> grippers = 3;
  map<string, BoardStatus> boards = 4;
  map<string, bool> cameras = 5;
  map<string, SensorStatus> sensors = 6;
  map<string, bool> functions = 7;
  map<string, ServoStatus> servos = 8;
  map<string, MotorStatus> motors = 9;
  map<string, bool> services = 10;
  map<string, InputControllerStatus> input_controllers = 11;
  map<string, GantryStatus> gantries = 12;
}

message ComponentConfig {
  string name = 1;
  string type = 2;
  string parent = 3;
  Pose pose = 4;
}

message ConfigRequest {}

message ConfigResponse {
  repeated ComponentConfig components = 1;  
}

message DoActionRequest {
  string name = 1;
}

message DoActionResponse {}

message GantryStatus {
  repeated double positions = 1;
  repeated double lengths = 2;
}

// Arm

message ArmStatus {
  Pose   grid_position = 1;
  JointPositions joint_positions = 2;
}

message Pose {
  // millimeters of the end effector from the base
  double x = 1;
  double y = 2;
  double z = 3;

  // ox, oy, oz, theta represents an orientation vector
  // Structured similarly to an angle axis, an orientation vector works differently. Rather than representing an orientation
  // with an arbitrary axis and a rotation around it from an origin, an orientation vector represents orientation
  // such that the ox/oy/oz components represent the point on the cartesian unit sphere at which your end effector is pointing
  // from the origin, and that unit vector forms an axis around which theta rotates. This means that incrementing/decrementing
  // theta will perform an in-line rotation of the end effector.
  // Theta is defined as rotation between two planes: the plane defined by the origin, the point (0,0,1), and the rx,ry,rz
  // point, and the plane defined by the origin, the rx,ry,rz point, and the new local Z axis. So if theta is kept at
  // zero as the north/south pole is circled, the Roll will correct itself to remain in-line.
  // Theta in pb.Pose should be degrees. It will be converted to radians in the internal OrientationVec.
  double o_x = 4;
  double o_y = 5;
  double o_z = 6;
  double theta = 7;
}

message JointPositions {
  repeated double degrees = 1;
}

message FrameConfig{
  string parent = 1;
  Pose  pose = 2;
}

message FrameSystemConfig {
  string name = 1;
  FrameConfig frame_config = 2;
  bytes model_json = 3; 
}

message FrameServiceConfigRequest {}

message FrameServiceConfigResponse {
  repeated FrameSystemConfig frame_system_configs = 1;
}

// Base

message BaseMoveStraightRequest {
  // Name of a base
  string name = 1;
  // Desired travel distance in millimeters
  int64 distance_millis = 2;
  // Desired travel velocity in millimeters/second
  double millis_per_sec = 3;
}

message BaseMoveStraightResponse {
  // Returns true if robot completed the requested method
  bool success = 1;
  // If success = false, this provides a description of the error 
  string error = 2;
}

message BaseMoveArcRequest {
  // Name of a base
  string name = 1;
  // Desired travel distance in millimeters
  int64 distance_millis = 2;
  // Desired speed in millimeters per second 
  double millis_per_sec = 3;
  // Desired angle in degrees
  double angle_deg = 4;
}

message BaseMoveArcResponse {
  // Returns true if robot completed the requested method
  bool success = 1;
  // If success = false, this provides a description of the error 
  string error = 2;
}

message BaseSpinRequest {
  // Name of a base
  string name = 1;
  // Desired angle
  double angle_deg = 2;
  // Desired angular velocity
  double degs_per_sec = 3;
}

message BaseSpinResponse {
  // Returns true if robot completed the requested method
  bool success = 1;
  // If success = false, this provides a description of the error 
  string error = 2;
}

message BaseStopRequest {
  // Name of a base
  string name = 1;
}

message BaseStopResponse {}

message BaseWidthMillisRequest {
  // Name of a base
  string name = 1;
}

message BaseWidthMillisResponse {
  // Width of the base represented in millimeters 
  int64 width_millis = 1;
}

message Vector3 {
  double x = 1;
  double y = 2;
  double z = 3;
}

// Board

message BoardStatus {
  map<string, AnalogStatus> analogs = 1;
  map<string, DigitalInterruptStatus> digital_interrupts = 2;
}

message AnalogStatus {
  int32 value = 1;
}

message DigitalInterruptStatus {
  int64 value = 1;
}

message SensorStatus {
  string type = 1;
}

message BoardStatusRequest {
  string name = 1;
}

message BoardStatusResponse {
  BoardStatus status = 1;
}

message BoardGPIOSetRequest {
// Name of a board
  string name = 1;
// Name of a pin
  string pin = 2;
// Defines whether the pin will be set high or low
  bool high = 3;
}

message BoardGPIOSetResponse {}

message BoardGPIOGetRequest {
// Name of a board
  string name = 1;
// Name of a pin
  string pin = 2;
}

message BoardGPIOGetResponse {
// Returns true if the given GPIO pin is high at the time that the request was recieved
  bool high = 1;
}

message BoardPWMSetRequest {
// Name of a board
  string name = 1;
// Name of a pin
  string pin = 2;
// A value between 0-255, where 255 is equivalent to being high 100% of the time 
  uint32 duty_cycle = 3; 
}

message BoardPWMSetResponse {}

message BoardPWMSetFrequencyResponse {}

message BoardPWMSetFrequencyRequest {
  // Name of a board
  string name = 1;
  // Name of a pin
  string pin = 2;
  // Frequency in hertz (cycles/second)
  uint64 frequency = 3;
}

// Analog Reader

message BoardAnalogReaderReadRequest {
  // Name of a board
  string board_name = 1;
  // Name of an analog reader on the robot's board 
  string analog_reader_name = 2;
}

message BoardAnalogReaderReadResponse {
  // Returns the value of the analog reader based on when the request was recieved 
  int32 value = 1;
}

// Digital Interrupt

message DigitalInterruptConfig {
  string name = 1;
  string pin = 2;
  string type = 3;
  string formula = 4;
}

message BoardDigitalInterruptConfigRequest {
  // Name of a board
  string board_name = 1;
  // Name of a digital interrupt on the robot's board 
  string digital_interrupt_name = 2;
}

message BoardDigitalInterruptConfigResponse {
  // Returns the specified configuration of a digital interrupt on the robot's board
  DigitalInterruptConfig config = 1;
}

message BoardDigitalInterruptValueRequest {
  // Name of a board
  string board_name = 1;
  // Name of a digital interrupt on the robot's board 
  string digital_interrupt_name = 2;
}

message BoardDigitalInterruptValueResponse {
  // Returns the returns the value of the interrupt based on the driver
  int64 value = 1;
}

message BoardDigitalInterruptTickRequest {
  // Name of a board
  string board_name = 1;
  // Name of a digital interrupt on the robot's board 
  string digital_interrupt_name = 2;
  // Sets whether the digital interrupt is high or low
  bool high = 3;
  // A number that counts up from an arbitrary point in time 
  uint64 nanos = 4;
}

message BoardDigitalInterruptTickResponse {}

// Sensor

message SensorReadingsRequest {
  string name = 1;
}

message SensorReadingsResponse {
  repeated google.protobuf.Value readings = 1;
}

// Compass

message CompassHeadingRequest {
  string name = 1;
}

message CompassHeadingResponse {
  double heading = 1;
}

message CompassStartCalibrationRequest {
  string name = 1;
}

message CompassStartCalibrationResponse {}

message CompassStopCalibrationRequest {
  string name = 1;
}

message CompassStopCalibrationResponse {}

// Relative Compass

message CompassMarkRequest {
  string name = 1;
}

message CompassMarkResponse {}

message ExecuteFunctionRequest {
  string name = 1;
  // TODO(erd): arguments
}

message ExecuteFunctionResponse {
  repeated google.protobuf.Value results = 1;
  string std_out = 2;
  string std_err = 3;
}

message ExecuteSourceRequest {
  string source = 1;
  string engine = 2;
}

message ExecuteSourceResponse {
  repeated google.protobuf.Value results = 1;
  string std_out = 2;
  string std_err = 3;
}


message MotorStatus {
  // To D0 (FA): Delete this field
  bool on = 1;
  // Returns true if the motor has position support
  bool position_supported = 2;
  // Returns current position of the motor relative to its home
  double position = 3;
  // To Do (FA): Delete this field 
  optional google.protobuf.Struct pid_config = 4;
}

message ServoStatus {
  uint32 angle = 1;
}

message ResourceRunCommandRequest {
  // Note(erd): okay in v1 because names are unique. v2 should be a VRN
  string resource_name = 1;
  string command_name = 2;
  google.protobuf.Struct args = 3;
}

message ResourceRunCommandResponse {
  google.protobuf.Struct result = 1;
}

enum NavigationServiceMode {
  NAVIGATION_SERVICE_MODE_UNSPECIFIED = 0;
  NAVIGATION_SERVICE_MODE_MANUAL = 1;
  NAVIGATION_SERVICE_MODE_WAYPOINT = 2;
}

message NavigationServiceModeRequest {

}

message NavigationServiceModeResponse {
  NavigationServiceMode mode = 1;
}

message NavigationServiceSetModeRequest {
  NavigationServiceMode mode = 1;
}

message NavigationServiceSetModeResponse {
}

message NavigationServiceWaypoint {
  string id = 1;
  GeoPoint location = 2;
}

message GeoPoint {
  double latitude = 1;
  double longitude = 2;
}

message NavigationServiceLocationRequest {

}

message NavigationServiceLocationResponse {
  GeoPoint location = 1;
}

message NavigationServiceWaypointsRequest {

}

message NavigationServiceWaypointsResponse {
  repeated NavigationServiceWaypoint waypoints = 1;
}

message NavigationServiceAddWaypointRequest {
  GeoPoint location = 1;
}

message NavigationServiceAddWaypointResponse {
}

message NavigationServiceRemoveWaypointRequest {
  string id = 1;
}

message NavigationServiceRemoveWaypointResponse {
}

// Object Manipulation Service

message ObjectManipulationServiceDoGrabRequest {
  string camera_name = 1;
  Vector3 camera_point = 2;
  string gripper_name = 3;
  string arm_name = 4;
}

message ObjectManipulationServiceDoGrabResponse {
  bool has_grabbed = 1;
}

// End Object Manipulation Service

message InputControllerControlsRequest {
  // Name of an input controller 
  string controller = 1;
}

message InputControllerControlsResponse {
  // Returns a list of all the controls (buttons and axes) that are
  // available to a given Input Controller 
  repeated string controls = 1;
}

message InputControllerLastEventsRequest {
  // Name of an input controller 
  string controller = 1;
}

message InputControllerLastEventsResponse {
  // Returns a list of the most recent event for each control on a given InputController. Effectively provides the current "state" of all 
  // buttons/axes on a given input controller 
  repeated InputControllerEvent events = 1;
}

message InputControllerStatus {
  repeated InputControllerEvent events = 1;
}

message InputControllerInjectEventRequest {
  // Name of an input controller 
  string controller = 1;
  // Digitally assert a given event 
  InputControllerEvent event = 2;
}

message InputControllerInjectEventResponse {
}

message InputControllerEvent {
  google.protobuf.Timestamp time = 1;
  // An event type (eg: ButtonPress, ButtonRelease)
  string event = 2;
  // A control, can be a button (eg: ButtonSouth) or an axis (eg: AbsoluteX)
  string control = 3;
  // 0 or 1 for buttons, -1.0 to +1.0 for axes
  double value = 4;
}

message InputControllerEventStreamRequest {
  message Events {
    // Name of a control (button or axis)
    string control = 1;
    // Specify which event types to recieve events for
    // To Do (FA): Right now this can be an empty list, but we should error in this case as opening a stream with no messages is expensive
    repeated string events = 2;
    // Specify which event types to stop recieving events for
    // This can be an empty list 
    repeated string cancelled_events = 3;
  }
  // Name of an input controller 
  string controller = 1;
  // A list of Events
  repeated Events events = 2;
}

message GPSLocationRequest {
  string name = 1;
}

message GPSLocationResponse {
  GeoPoint coordinate = 1;
}

message GPSAltitudeRequest {
  string name = 1;
}

message GPSAltitudeResponse {
  double altitude = 1;
}

message GPSSpeedRequest {
  string name = 1;
}

message GPSSpeedResponse {
  double speed_kph = 1;
}

message GPSAccuracyRequest {
  string name = 1;
}

message GPSAccuracyResponse {
  double horizontal_accuracy = 1;
  double vertical_accuracy = 2;
}


// Matrix
message Matrix {
	uint32 rows = 1;
	uint32 cols = 2;
	repeated uint32 data = 3;
}

// ForceMatrix
message ForceMatrixMatrixRequest {
	string name = 1;
}

message ForceMatrixMatrixResponse {
	Matrix matrix = 1;
}

message ForceMatrixSlipDetectionRequest {
  string name = 1;
}

message ForceMatrixSlipDetectionResponse {
  bool is_slipping = 1;
}
