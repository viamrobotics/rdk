<html>
  <head>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgo=">
    <script src="./static/main.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
    <script>
      const enableDevTools = window.__GRPCWEB_DEVTOOLS__ || (() => {});
      enableDevTools([robotService]);
      async function consumeClientCall(prom, cb) {
        try {
            const resp = await prom;
            if (cb) {
                cb(resp.toObject());
            } else {
                theData.res = JSON.stringify(resp.toObject());
            }
        } catch (e) {
            theData.error = JSON.stringify(e);
        }
      }

      {{ range $view := .Views }}
        {{ jsSafe $view.JavaScript }}
      {{ end }}

      function fixArms(old) {
          var n = [];
          for (var i=0; i<old.length; i++) {
              const [armName, armValue] = old[i];
              var newArm = { name : armName, pieces : [] };

              var fieldSetters = [ ["x", "X"], ["y", "Y"], ["z", "Z"], ["rX", "RX"], ["rY", "RY"], ["rZ", "RZ"]];
              for (var j=0; j<fieldSetters.length; j++ ){
                  newArm.pieces.push( { grid : fieldSetters[j],
                                        joint : j,
                                        gridValue : armValue.gridPosition[fieldSetters[j][0]],
                                        jointValue : armValue.jointPositions.degreesList[j],
                                      });
              }
              
              n.push(newArm);
          }
          return n;
      }

      firstResult = false;
      
      async function updateStatus(rawStatus) {
          theData.rawStatus = rawStatus;
          window.rawStatus = rawStatus;
          // toObject gives annoying suffixes; see https://github.com/protocolbuffers/protobuf/issues/6773
          const rawSatusObj = rawStatus.toObject();

          var status = {}

          // make vue friendly
          status.armsMap = rawSatusObj.armsMap;
          status.basesMap = rawSatusObj.basesMap;
          status.grippersMap = rawSatusObj.grippersMap;
          status.boardsMap = rawSatusObj.boardsMap;
          status.camerasMap = rawSatusObj.camerasMap;
          status.sensorsMap = rawSatusObj.sensorsMap;

          status.armsMap = fixArms(status.armsMap);

          if (!firstResult) {
            console.log(rawSatusObj);
            console.log(status);
            firstResult = true;
          }

          theData.status = status;
      }
      
      function startup() {
          theData = {
              error : "",
              res : {},
              rawStatus : null,
              status : {}
          };
          theApp = new Vue({
              el: '#app',
              delimiters: ['${', '}'],
              data: theData,
              methods : {
                  armGridInc : function(name, getterSetter, amount) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getGridPosition();
                      var newPosition = Object.assign(Object.create(robotApi.ArmPosition.prototype), old);
                      const getter = `get${getterSetter}`;
                      const setter = `set${getterSetter}`;
                      newPosition[setter](newPosition[getter]() + amount);
                      const req = new robotApi.ArmMoveToPositionRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      consumeClientCall(robotService.armMoveToPosition(req));
                  },
                  armJointInc : function(name, field, amount) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      newList[field] += amount;
                      newPosition.setDegreesList(newList);
                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      consumeClientCall(robotService.armMoveToJointPositions(req));
                  },
                  armHome : function(name) {
                      const arm = theData.rawStatus.getArmsMap().get(name);
                      var old = arm.getJointPositions();
                      var newPosition = Object.assign(Object.create(robotApi.JointPositions.prototype), old);
                      var newList = newPosition.getDegreesList();
                      for (var i = 0; i < newList.length; i++) {
                        newList[i] = 0;
                      }
                      newPosition.setDegreesList(newList);
                      const req = new robotApi.ArmMoveToJointPositionsRequest();
                      req.setName(name);
                      req.setTo(newPosition);
                      consumeClientCall(robotService.armMoveToJointPositions(req));
                  },
                  gripperAction : function(name, action) {
                      let req;
                      switch (action) {
                        case 'open':
                          req = new robotApi.GripperOpenRequest();
                          req.setName(name);
                          consumeClientCall(robotService.gripperOpen(req));
                          break;
                        case 'grab':
                          req = new robotApi.GripperGrabRequest();
                          req.setName(name);
                          consumeClientCall(robotService.gripperGrab(req));
                          break;
                      }
                  },
                  servoMove : function(idx, servoIdx, amount) {
                      const [boardName, boardValue] = theData.status.boardsMap[idx];
                      const [servoName, servoValue] = boardValue.servosMap[servoIdx];
                      var angle = servoValue.angle + amount;
                      const req = new robotApi.BoardServoMoveRequest();
                      req.setBoardName(boardName);
                      req.setServoName(servoName);
                      req.setAngleDeg(angle);
                      consumeClientCall(robotService.boardServoMove(req));
                  },
                  motorButton: function(board, motor, cmd) {
                      let req;
                      if (cmd.r) {
                        req = new robotApi.BoardMotorGoForRequest();
                        req.setRevolutions(cmd.r);
                        if (cmd.s) {
                          req.setRpm(cmd.s);
                        }
                      } else {
                        req = new robotApi.BoardMotorGoRequest();
                        if (cmd.s) {
                            req.setPowerPct(cmd.s);
                        }
                      }
                      req.setBoardName(board);
                      req.setMotorName(motor);
                      switch (cmd.d) {
                        case 'backward':
                          req.setDirection(robotApi.DirectionRelative.DIRECTION_RELATIVE_BACKWARD);
                          break;
                        case 'forward':
                          req.setDirection(robotApi.DirectionRelative.DIRECTION_RELATIVE_FORWARD);
                          break;
                      }
                      if (cmd.r) {
                        consumeClientCall(robotService.boardMotorGoFor(req));
                      } else {
                        consumeClientCall(robotService.boardMotorGo(req));
                      }
                  },
                  doAction : function(name) {
                      const req = new robotApi.DoActionRequest();
                      req.setName(name);
                      consumeClientCall(robotService.doAction(req));
                  },
                  baseAction : function(name, action, amount) {
                      let req;
                      switch (action) {
                        case 'straight':
                          req = new robotApi.BaseMoveStraightRequest();
                          req.setName(name);
                          req.setMillisPerSec(document.getElementById("speed").value)
                          req.setDistanceMillis(document.getElementById("distance").value * amount);
                          consumeClientCall(robotService.baseMoveStraight(req));
                          break;
                        case 'angle':
                          req = new robotApi.BaseSpinRequest();
                          req.setName(name);
                          req.setDegsPerSec(document.getElementById("speed").value)
                          req.setAngleDeg(amount);
                          consumeClientCall(robotService.baseSpin(req));
                          break;
                      }
                  },
                  renderPCD : function(cameraName) {
                      initPCDIfNeeded();

                      pcdLoad("/cameras/" + cameraName + "/data.pcd");
                      
                  },
                  doSensorReadings : function(name) {
                      var req = new robotApi.SensorReadingsRequest();
                      req.setName(name);
                      consumeClientCall(robotService.sensorReadings(req));
                      
                  },
                  nonEmpty : function(d) {
                      for ( var k in d ) {
                          return true;
                      }
                      return false;
                  }
              }
          })

          const streamReq = new robotApi.StatusStreamRequest();
          streamReq.setEvery((new proto.google.protobuf.Duration()).setNanos(500000000)); // 500ms
          const statusStream = robotService.statusStream(streamReq);
          statusStream.on('data', function(response) {
            updateStatus(response.getStatus());
          });
          statusStream.on('status', function(status) {
            console.log("error streaming robot status");
            console.log(status.code, " ", status.details);
          });
          statusStream.on('end', function(end) {
            console.log("done streaming robot status");
          });
      }

      pcdGlobal = null;
      
      function initPCDIfNeeded() {
          if (pcdGlobal) {
              return
          }

          console.log("initing pcd");
          
          pcdGlobal = {
              scene : new THREE.Scene(),
              camera : new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 2000 ),
              renderer : new THREE.WebGLRenderer(),
          };

          pcdGlobal.renderer.setSize( window.innerWidth / 2, window.innerHeight / 2 );
          document.getElementById("pcd").appendChild(pcdGlobal.renderer.domElement);
          
          pcdGlobal.controls = new orbitLib.OrbitControls( pcdGlobal.camera, pcdGlobal.renderer.domElement );
          pcdGlobal.camera.position.set( 0, 0, 1 );
          pcdGlobal.controls.update();

          console.log("pcd init done");
      }

      function pcdAnimate() {
	      pcdGlobal.renderer.render( pcdGlobal.scene, pcdGlobal.camera );
          pcdGlobal.controls.update();
          requestAnimationFrame( pcdAnimate );
      }
      
      function pcdLoad(path) {
          var loader = new pcdLib.PCDLoader();

          loader.load(
              path,
              
	          // called when the resource is loaded
	          function ( mesh ) {
                  pcdGlobal.scene.clear();
		          pcdGlobal.scene.add( mesh );
                  pcdAnimate();
	          },
	          // called when loading is in progresses
	          function ( xhr ) {
		          //console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
	          },
	          // called when loading has errors
	          function ( error ) {
		          console.log(error);
	          }
          );
          
      }

      
    </script>
  </head>
  <body onLoad="startup()">
    <div id="app">
      <div id="actions">
        {{range $r := .Actions}}
        <button v-on:click="doAction('{{$r}}')">{{$r}}</button>
        {{end}}
      </div>      

      <div style="font-color: red">${ error }</div>

      <!-- ******* BASE *******  -->
      <div class="base" v-for="base in status.basesMap" :key="base[0]">
        <h3>${base[0]}</h3>
        <ul>
          <li><button v-on:click="baseAction(base[0], 'straight', 1)">Forward</button></li>
          <li><button v-on:click="baseAction(base[0], 'straight', -1)">Backward</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', 15)">Spin Clockwise</button></li>
          <li><button v-on:click="baseAction(base[0], 'angle', -15)">Spin Counterclockwise</button></li>
        </ul>
        
        Speed (mm per sec): <input id="speed" name="speed" value="300"/><br>
        Distances (mm): <input id="distance" name="speed" value="500"/><br>
      </div>

      <!-- ******* ARM *******  -->
      <div class="arm" v-for="arm in status.armsMap" :key="arm.name">
        <h3>Arm ${arm.name}</h3>
        <table border="1">
          <tr>
            <th colspan="4"><h5>GRID</h5></th>
            <th colspan="4"><h5>JOINTS</h5></th>
          </tr>
          <tr v-for="aa in arm.pieces" :key="aa.joint">
            <th>${aa.grid[0]}</th>
            <td>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -2 )">--</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], -1 )">-</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 1 )">+</button>
              <button v-on:click="armGridInc( arm.name, aa.grid[1], 2 )">++</button>
            </td>
            <td>${aa.gridValue}</td>

            <td></td>
            
            <th>Joint ${aa.joint}</th>
            <td>
              <button v-on:click="armJointInc( arm.name, aa.joint, -2 )">--</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, -1 )">-</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 1 )">+</button>
              <button v-on:click="armJointInc( arm.name, aa.joint, 2 )">++</button>
            </td>
            <td>${aa.jointValue}</td>
          </tr>
          <tr>
            <th colspan="8"> 
              <button v-on:click="armHome( arm.name)">Home</button>
            </th>
          </tr>

        </table>
      </div> 
      
      <!-- ******* GRIPPER *******  -->
      <div class="gripper" v-for="gripper in status.grippersMap" :key="gripper[0]">
        <h3>Gripper ${ gripper[0] }</h3>
        <ul>
          <li><button v-on:click="gripperAction( gripper[0], 'open')">Open</button></li>
          <li><button v-on:click="gripperAction( gripper[0], 'grab')">Grab</button></li>
        </ul>
      </div>

      <table>
        <tr>
          <td><img id="i0" src=""/></td>
          <td><img id="i1" src=""/></td>
          {{ range $view := .Views }}
          <td>
            {{ htmlSafe $view.Body }}
          </td>
          {{ end }}
        </tr>
      </table>
      
      <!-- ******* BOARD *******  -->

      <div class="board" v-for="(board, boardIndex) in status.boardsMap" :key="board[0]">
        <h3>Board ${board[0]}</h3>
        <table border="1">
          
          <tr><th colspan="2">Motors</th></tr>
          <tbody v-for="m in board[1].motorsMap" :key="m[0]">
            <tr>
              <th>${m[0]}</th>
              <td>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: .50})">--</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: .25})">-</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'none', s: 0})">0</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: .25})">+</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: .50})">++</button>
              </td>
            </tr>
            <tr>
              <td>50rpm</td>
              <td>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: 50, r: 10})">-10</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: 50, r: 1})">-1</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: 50, r: .25})">-.25</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: 50, r: .25})">+.25</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: 50, r: 1})">+1</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: 50, r: 10})">+10</button>
              </td>
            </tr>
            <tr>
              <td>10rpm</td>
              <td>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: 10, r: 10})">-10</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: 10, r: 1})">-1</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'backward', s: 10, r: .25})">-.25</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: 10, r: .25})">+.25</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: 10, r: 1})">+1</button>
                <button v-on:click="motorButton(board[0], m[0], {d:'forward', s: 10, r: 10})">+10</button>
              </td>
            </tr>
            
            <tr>
              <td align="right">On</td>
              <td>${m[1].on}</td>
            </tr>
            <tr>
              <td align="right">PositionSupported</td>
              <td>${m[1].positionSupported}</td>
            </tr>
            <tr>
              <td align="right">Position</td>
              <td>${m[1].position}</td>
            </tr>


          </tbody>

          <tr><th colspan="2">Analogs</th></tr>
          <tr v-for="a in board[1].analogsMap" :key="a[0]">
            <th>${a[0]}</th>
            <td>${a[1].value}</td>
          </tr>

          <tr><th colspan="2">DigitalInterrupts</th></tr>
          <tr v-for="di in board[1].digitalInterruptsMap" :key="di[0]">
            <th>${di[0]}</th>
            <td>${di[1].value}</td>
          </tr>

          <tr><th colspan="2">Servos</th></tr>
          <tbody v-for="(s, servoIndex) in board[1].servosMap" :key="s[0]">
            <tr><th>${s[0]}</th><td>${s[1].angle}</td></tr>
            <tr>
              <td></td>
              <td>
                <button v-on:click="servoMove( boardIndex, servoIndex, -10)">-10</button>
                <button v-on:click="servoMove( boardIndex, servoIndex, -1)">-1</button>
                <button v-on:click="servoMove( boardIndex, servoIndex, 1)">1</button>
                <button v-on:click="servoMove( boardIndex, servoIndex, 10)">10</button>
              </td>
            </tr>
          </tbody>
          
        </table>
      </div> <!-- end boards -->

      <table border="1" v-if="nonEmpty(status.camerasMap)">
        <tr>
          <th colspan="3">
            Cameras
          </th>
        </tr>
        <tr>
          <th>Name</th>
          <th>Frame</th>
          <th>PCD</th>
        </tr>
        <tr v-for="(cam,x) in status.camerasMap">
          <td>${cam[0]}</td>
          <td><a :href="'/api/v1/camera/' + cam[0] + '/render_frame'">frame</a></td>
          <td><button v-on:click="renderPCD(cam[0])">GO</button></td>
        </tr>
      </table>

      <table border=1 v-if="nonEmpty(status.sensorsMap)">
        <tr>
          <th colspan="2">Sensors</th>
        </tr>
        
        <tr>
          <th>Name</th>
          <th>Type</th>
        </tr>
        
        <tr v-for="(sensor, x) in status.sensorsMap">
          <td>${sensor[0]}</td>
          <td>${sensor[1].type}</td>
          <td><button v-on:click="doSensorReadings(sensor[0])">Get Readings</button></td>
        </tr>
      </table>
          
      
      <div>${res}</div>
    </div> <!-- end vue app -->

    <div id="pcd"/>
    
  </body>
</html>

