package kinematics

import (
	"io/ioutil"
	"math"
	"strconv"

	"gopkg.in/yaml.v3"
	"github.com/edaniels/golog"
)

type ThreeD struct{
	X float64 `yaml:"x"`
	Y float64 `yaml:"y"`
	Z float64 `yaml:"z"`
}

type Orientation struct{
	Rotation ThreeD `yaml:"rotation"`
	Translation ThreeD `yaml:"translation"`
}

type AutoGenerated struct {
	Model struct {
		Manufacturer string `yaml:"manufacturer"`
		Name         string `yaml:"name"`
		World        struct {
			O Orientation
			G ThreeD `yaml:"g"`
		} `yaml:"world"`
		Framecount int `yaml:"framecount"`
		Bodies     []struct {
			ID      int   `yaml:"id"`
			Ignores []int `yaml:"ignores"`
		} `yaml:"bodies"`
		Fixeds []struct {
			ID    int `yaml:"id"`
			Frame struct {
				A string `yaml:"a"`
				B string `yaml:"b"`
			} `yaml:"frame"`
			O Orientation
		} `yaml:"fixeds"`
		Joints []struct {
			ID    int    `yaml:"id"`
			Type  string `yaml:"type"`
			Frame struct {
				A string `yaml:"a"`
				B string `yaml:"b"`
			} `yaml:"frame"`
			Axis ThreeD `yaml:"axis"`
			Max float64 `yaml:"max"`
			Min float64 `yaml:"min"`
		} `yaml:"joints"`
		Home []float64 `yaml:"home"`
	} `yaml:"model"`
}

func ParseYmlFile(filename string) (*Model, error) {
	model := NewModel()
	id2frame := make(map[string]*Frame)
	m := AutoGenerated{}

	ymlData, err := ioutil.ReadFile(filename)
	if err != nil {
		golog.Global.Error("failed to read yml file")
	}

	err = yaml.Unmarshal(ymlData, &m)
	if err != nil {
		golog.Global.Error("failed to unmarshall yml file")
	}

	model.manufacturer = m.Model.Manufacturer
	model.name = m.Model.Name

	// Create world frame
	wFrame := NewFrame()
	wFrame.IsWorld = true
	setOrient(m.Model.World.O, &wFrame.i)
	wFrame.SetGravity(m.Model.World.G.X, m.Model.World.G.Y, m.Model.World.G.Z)
	model.Add(wFrame)
	id2frame["world"] = wFrame

	for _, body := range m.Model.Bodies {
		bFrame := NewFrame()
		bFrame.IsBody = true
		model.Add(bFrame)
		nodeID := "body" + strconv.Itoa(body.ID)
		id2frame[nodeID] = bFrame
		bFrame.Name = nodeID
	}
	for i := 0; i < m.Model.Framecount; i++ {
		frame := NewFrame()
		model.Add(frame)
		nodeID := "frame" + strconv.Itoa(i)
		id2frame[nodeID] = frame
		frame.Name = nodeID
	}

	// Iterate over bodies a second time, setting which ones should ignore one another now that they're all in id2frame
	for _, body := range m.Model.Bodies {
		nodeID := "body" + strconv.Itoa(body.ID)

		b1 := id2frame[nodeID]
		for _, ignore := range body.Ignores {
			ignoreID := "body" + strconv.Itoa(ignore)
			b2 := id2frame[ignoreID]
			b1.selfcollision[b2] = true
			b2.selfcollision[b1] = true
		}
	}

	for _, fixed := range m.Model.Fixeds {
		frameA := id2frame[fixed.Frame.A]
		frameB := id2frame[fixed.Frame.B]

		fixedT := NewTransform()
		fixedT.SetName("fixed" + strconv.Itoa(fixed.ID))

		fixedT.SetEdgeDescriptor(model.AddEdge(frameA, frameB))
		model.Edges[fixedT.GetEdgeDescriptor()] = fixedT
		setOrient(fixed.O, fixedT)

		fixedT.x.Translation = fixedT.t.Translation()
		fixedT.x.Rotation = fixedT.t.Linear()
	}

	// Now we add all of the transforms. Will eventually support: "cylindrical|fixed|helical|prismatic|revolute|spherical"
	for _, joint := range m.Model.Joints {

		// TODO: Make this a switch once we support more than one joint type
		if joint.Type == "revolute" {
			// TODO: Add speed, wraparound, etc
			frameA := id2frame[joint.Frame.A]
			frameB := id2frame[joint.Frame.B]

			rev := NewJoint(1, 1)
			rev.SetEdgeDescriptor(model.AddEdge(frameA, frameB))
			model.Edges[rev.GetEdgeDescriptor()] = rev

			rev.max = append(rev.max, joint.Max*180/math.Pi)
			rev.min = append(rev.min, joint.Min*180/math.Pi)

			// TODO: Add default on z
			// TODO: Enforce between 0 and 1
			rev.SpatialMat.Set(0, 0, joint.Axis.X)
			rev.SpatialMat.Set(1, 0, joint.Axis.Y)
			rev.SpatialMat.Set(2, 0, joint.Axis.Z)

			rev.SetName("joint" + strconv.Itoa(joint.ID))
		} else {
			golog.Global.Error("Unsupported joint type detected:", joint.Type)
		}
	}

	model.Update()
	model.Home = m.Model.Home

	return model, err
}

func setOrient(orient Orientation, trans *Transform) {
	// Important: always rotate in ZYX order
	// Why? Matrix math is not commutative, so do it once one way, and that's the way it needs to be done everywhere
	trans.t.RotZ(orient.Rotation.Z)
	trans.t.RotY(orient.Rotation.Y)
	trans.t.RotX(orient.Rotation.X)

	trans.t.SetX(orient.Translation.X)
	trans.t.SetY(orient.Translation.Y)
	trans.t.SetZ(orient.Translation.Z)
}
